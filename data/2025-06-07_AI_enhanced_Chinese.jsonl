{"id": "2506.04544", "pdf": "https://arxiv.org/pdf/2506.04544", "abs": "https://arxiv.org/abs/2506.04544", "authors": ["Charles Hong", "Brendan Roberts", "Huijae An", "Alex Um", "Advay Ratan", "Yakun Sophia Shao"], "title": "hdl2v: A Code Translation Dataset for Enhanced LLM Verilog Generation", "categories": ["cs.AR", "cs.AI", "cs.LG", "cs.PL"], "comment": null, "summary": "Large language models (LLMs) are playing an increasingly large role in\ndomains such as code generation, including hardware code generation, where\nVerilog is the key language. However, the amount of publicly available Verilog\ncode pales in comparison to the amount of code available for software languages\nlike Python. In this work, we present hdl2v (\"HDL-to-Verilog\"), a dataset which\nseeks to increase the amount of available human-written Verilog data by\ntranslating or compiling three other hardware description languages - VHDL,\nChisel, and PyMTL3 - to Verilog. Furthermore, we demonstrate the value of hdl2v\nin enhancing LLM Verilog generation by improving performance of a 32\nbillion-parameter open-weight model by up to 23% (pass@10) in VerilogEvalV2,\nwithout utilizing any data augmentation or knowledge distillation from larger\nmodels. We also show hdl2v's ability to boost the performance of a data\naugmentation-based fine-tuning approach by 63%. Finally, we characterize and\nanalyze our dataset to better understand which characteristics of\nHDL-to-Verilog datasets can be expanded upon in future work for even better\nperformance.", "AI": {"tldr": "\u8bba\u6587\u4ecb\u7ecd\u4e86hdl2v\u6570\u636e\u96c6\uff0c\u901a\u8fc7\u5c06VHDL\u3001Chisel\u548cPyMTL3\u7ffb\u8bd1\u4e3aVerilog\uff0c\u589e\u52a0\u516c\u5f00\u53ef\u7528\u7684Verilog\u4ee3\u7801\u91cf\uff0c\u5e76\u5c55\u793a\u4e86\u5176\u5728\u63d0\u5347LLM\u751f\u6210Verilog\u4ee3\u7801\u6027\u80fd\u65b9\u9762\u7684\u4ef7\u503c\u3002", "motivation": "\u516c\u5f00\u53ef\u7528\u7684Verilog\u4ee3\u7801\u8fdc\u5c11\u4e8e\u5176\u4ed6\u8f6f\u4ef6\u8bed\u8a00\uff08\u5982Python\uff09\uff0c\u9650\u5236\u4e86LLM\u5728\u786c\u4ef6\u4ee3\u7801\u751f\u6210\u9886\u57df\u7684\u5e94\u7528\u3002", "method": "\u901a\u8fc7\u7ffb\u8bd1\u6216\u7f16\u8bd1VHDL\u3001Chisel\u548cPyMTL3\u751f\u6210Verilog\u4ee3\u7801\uff0c\u6784\u5efahdl2v\u6570\u636e\u96c6\uff0c\u5e76\u7528\u4e8e\u5fae\u8c03LLM\u3002", "result": "\u4f7f\u7528hdl2v\u540e\uff0c32B\u53c2\u6570\u6a21\u578b\u7684\u6027\u80fd\u63d0\u534723%\uff08pass@10\uff09\uff0c\u6570\u636e\u589e\u5f3a\u65b9\u6cd5\u7684\u6027\u80fd\u63d0\u534763%\u3002", "conclusion": "hdl2v\u6570\u636e\u96c6\u6709\u6548\u63d0\u5347\u4e86LLM\u751f\u6210Verilog\u4ee3\u7801\u7684\u80fd\u529b\uff0c\u672a\u6765\u53ef\u8fdb\u4e00\u6b65\u4f18\u5316\u6570\u636e\u96c6\u7279\u6027\u4ee5\u63d0\u5347\u6027\u80fd\u3002"}}
