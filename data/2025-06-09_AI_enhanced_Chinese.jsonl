{"id": "2506.05839", "pdf": "https://arxiv.org/pdf/2506.05839", "abs": "https://arxiv.org/abs/2506.05839", "authors": ["Steven Libby"], "title": "An Execution Model for RICE", "categories": ["cs.PL"], "comment": "In Proceedings LSFA 2024, arXiv:2506.05219", "summary": "In this paper, we build on the previous work of the RICE compiler by giving\nits execution model. We show the restrictions to the FlatCurry language that\nwere made to produce executable code, and present the execution model using\noperational semantics similar to Launchbury. Finally, we show that the\nexecution model conforms with the standard operational semantics for Curry.", "AI": {"tldr": "\u672c\u6587\u6269\u5c55\u4e86RICE\u7f16\u8bd1\u5668\u7684\u5de5\u4f5c\uff0c\u63d0\u51fa\u4e86\u5176\u6267\u884c\u6a21\u578b\uff0c\u5c55\u793a\u4e86\u4e3a\u751f\u6210\u53ef\u6267\u884c\u4ee3\u7801\u5bf9FlatCurry\u8bed\u8a00\u7684\u9650\u5236\uff0c\u5e76\u4f7f\u7528\u7c7b\u4f3cLaunchbury\u7684\u64cd\u4f5c\u8bed\u4e49\u63cf\u8ff0\u4e86\u6267\u884c\u6a21\u578b\u3002", "motivation": "\u57fa\u4e8eRICE\u7f16\u8bd1\u5668\u7684\u5148\u524d\u5de5\u4f5c\uff0c\u8fdb\u4e00\u6b65\u660e\u786e\u5176\u6267\u884c\u6a21\u578b\uff0c\u4ee5\u786e\u4fdd\u751f\u6210\u7684\u4ee3\u7801\u7b26\u5408Curry\u7684\u6807\u51c6\u64cd\u4f5c\u8bed\u4e49\u3002", "method": "\u901a\u8fc7\u9650\u5236FlatCurry\u8bed\u8a00\u5e76\u91c7\u7528\u7c7b\u4f3cLaunchbury\u7684\u64cd\u4f5c\u8bed\u4e49\uff0c\u6784\u5efa\u6267\u884c\u6a21\u578b\u3002", "result": "\u6267\u884c\u6a21\u578b\u4e0eCurry\u7684\u6807\u51c6\u64cd\u4f5c\u8bed\u4e49\u4e00\u81f4\u3002", "conclusion": "\u63d0\u51fa\u7684\u6267\u884c\u6a21\u578b\u6709\u6548\u4e14\u7b26\u5408\u6807\u51c6\uff0c\u4e3aRICE\u7f16\u8bd1\u5668\u7684\u8fdb\u4e00\u6b65\u5f00\u53d1\u63d0\u4f9b\u4e86\u7406\u8bba\u57fa\u7840\u3002"}}
{"id": "2506.06078", "pdf": "https://arxiv.org/pdf/2506.06078", "abs": "https://arxiv.org/abs/2506.06078", "authors": ["Mario Bravetti", "Luca Padovani", "Gianluigi Zavattaro"], "title": "A Sound and Complete Characterization of Fair Asynchronous Session Subtyping", "categories": ["cs.PL"], "comment": null, "summary": "Session types are abstractions of communication protocols enabling the static\nanalysis of message-passing processes. Refinement notions for session types are\nkey to support safe forms of process substitution while preserving their\ncompatibility with the rest of the system. Recently, a fair refinement relation\nfor asynchronous session types has been defined allowing the anticipation of\nmessage outputs with respect to an unbounded number of message inputs. This\nrefinement is useful to capture common patterns in communication protocols that\ntake advantage of asynchrony. However, while the semantic (\\`a la testing)\ndefinition of such refinement is straightforward, its characterization has\nproved to be quite challenging. In fact, only a sound but not complete\ncharacterization is known so far. In this paper we close this open problem by\npresenting a sound and complete characterization of asynchronous fair\nrefinement for session types. We relate this characterization to those given in\nthe literature for synchronous session types by leveraging a novel labelled\ntransition system of session types that embeds their asynchronous semantics.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u5bf9\u5f02\u6b65\u4f1a\u8bdd\u7c7b\u578b\u7684\u516c\u5e73\u7cbe\u5316\u5173\u7cfb\u8fdb\u884c\u5b8c\u6574\u8868\u5f81\u7684\u65b9\u6cd5\uff0c\u586b\u8865\u4e86\u73b0\u6709\u7814\u7a76\u7684\u7a7a\u767d\u3002", "motivation": "\u4f1a\u8bdd\u7c7b\u578b\u662f\u901a\u4fe1\u534f\u8bae\u7684\u62bd\u8c61\uff0c\u652f\u6301\u5bf9\u6d88\u606f\u4f20\u9012\u8fc7\u7a0b\u7684\u9759\u6001\u5206\u6790\u3002\u7cbe\u5316\u5173\u7cfb\u5bf9\u4e8e\u652f\u6301\u5b89\u5168\u7684\u8fc7\u7a0b\u66ff\u6362\u81f3\u5173\u91cd\u8981\uff0c\u4f46\u73b0\u6709\u7684\u5f02\u6b65\u4f1a\u8bdd\u7c7b\u578b\u7cbe\u5316\u5173\u7cfb\u8868\u5f81\u4e0d\u5b8c\u6574\u3002", "method": "\u901a\u8fc7\u4e00\u79cd\u65b0\u578b\u7684\u6807\u8bb0\u8f6c\u6362\u7cfb\u7edf\u5d4c\u5165\u5f02\u6b65\u8bed\u4e49\uff0c\u5bf9\u5f02\u6b65\u516c\u5e73\u7cbe\u5316\u5173\u7cfb\u8fdb\u884c\u5b8c\u6574\u8868\u5f81\u3002", "result": "\u63d0\u51fa\u4e86\u4e00\u79cd\u5bf9\u5f02\u6b65\u4f1a\u8bdd\u7c7b\u578b\u516c\u5e73\u7cbe\u5316\u7684\u5b8c\u5907\u8868\u5f81\u65b9\u6cd5\uff0c\u5e76\u4e0e\u540c\u6b65\u4f1a\u8bdd\u7c7b\u578b\u7684\u8868\u5f81\u8fdb\u884c\u4e86\u5173\u8054\u3002", "conclusion": "\u672c\u6587\u89e3\u51b3\u4e86\u5f02\u6b65\u4f1a\u8bdd\u7c7b\u578b\u516c\u5e73\u7cbe\u5316\u7684\u5b8c\u5907\u8868\u5f81\u95ee\u9898\uff0c\u4e3a\u901a\u4fe1\u534f\u8bae\u7684\u8bbe\u8ba1\u548c\u5206\u6790\u63d0\u4f9b\u4e86\u66f4\u5f3a\u5927\u7684\u5de5\u5177\u3002"}}
{"id": "2506.06227", "pdf": "https://arxiv.org/pdf/2506.06227", "abs": "https://arxiv.org/abs/2506.06227", "authors": ["Peter Pirkelbauer"], "title": "CompilerGPT: Leveraging Large Language Models for Analyzing and Acting on Compiler Optimization Reports", "categories": ["cs.PL"], "comment": "C3PO at ISC HPC 2025", "summary": "Current compiler optimization reports often present complex, technical\ninformation that is difficult for programmers to interpret and act upon\neffectively. This paper assesses the capability of large language models (LLM)\nto understand compiler optimization reports and automatically rewrite the code\naccordingly.\n  To this end, the paper introduces CompilerGPT, a novel framework that\nautomates the interaction between compilers, LLMs, and user defined test and\nevaluation harness. CompilerGPT's workflow runs several iterations and reports\non the obtained results.\n  Experiments with two leading LLM models (GPT-4o and Claude Sonnet),\noptimization reports from two compilers (Clang and GCC), and five benchmark\ncodes demonstrate the potential of this approach. Speedups of up to 6.5x were\nobtained, though not consistently in every test. This method holds promise for\nimproving compiler usability and streamlining the software optimization\nprocess.", "AI": {"tldr": "\u8bba\u6587\u63d0\u51faCompilerGPT\u6846\u67b6\uff0c\u5229\u7528\u5927\u8bed\u8a00\u6a21\u578b\uff08LLM\uff09\u7406\u89e3\u548c\u91cd\u5199\u7f16\u8bd1\u5668\u4f18\u5316\u62a5\u544a\uff0c\u5b9e\u9a8c\u663e\u793a\u6700\u9ad86.5\u500d\u52a0\u901f\u3002", "motivation": "\u5f53\u524d\u7f16\u8bd1\u5668\u4f18\u5316\u62a5\u544a\u590d\u6742\u96be\u61c2\uff0c\u7a0b\u5e8f\u5458\u96be\u4ee5\u6709\u6548\u5229\u7528\u3002", "method": "\u5f15\u5165CompilerGPT\u6846\u67b6\uff0c\u81ea\u52a8\u5316\u7f16\u8bd1\u5668\u3001LLM\u548c\u7528\u6237\u6d4b\u8bd5\u7684\u4ea4\u4e92\uff0c\u8fdb\u884c\u591a\u8f6e\u8fed\u4ee3\u5e76\u62a5\u544a\u7ed3\u679c\u3002", "result": "\u5b9e\u9a8c\u4f7f\u7528\u4e24\u79cdLLM\uff08GPT-4o\u548cClaude Sonnet\uff09\u3001\u4e24\u79cd\u7f16\u8bd1\u5668\uff08Clang\u548cGCC\uff09\u548c\u4e94\u4e2a\u57fa\u51c6\u4ee3\u7801\uff0c\u6700\u9ad8\u83b7\u5f976.5\u500d\u52a0\u901f\uff0c\u4f46\u7ed3\u679c\u4e0d\u4e00\u81f4\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u6709\u671b\u63d0\u5347\u7f16\u8bd1\u5668\u6613\u7528\u6027\u5e76\u4f18\u5316\u8f6f\u4ef6\u6d41\u7a0b\u3002"}}
