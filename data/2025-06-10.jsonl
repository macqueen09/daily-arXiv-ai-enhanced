{"id": "2506.06495", "pdf": "https://arxiv.org/pdf/2506.06495", "abs": "https://arxiv.org/abs/2506.06495", "authors": ["Hiromi Ishii", "Taro Shimizu", "Toshiki Teramura"], "title": "Optimizing Optimizations: Case Study on Detecting Specific Types of Mathematical Optimization Constraints with E-Graphs in JijModeling", "categories": ["cs.PL", "cs.MS", "math.OC"], "comment": "To be presented at EGRAPHS '25\n  https://pldi25.sigplan.org/home/egraphs-2025", "summary": "In solving mathematical optimization problems efficiently, it is crucial to\nmake use of information about specific types of constraints, such as the\none-hot or Special-Ordered Set (SOS) constraints. In many cases, exploiting\nsuch information gives asymptotically better execution time. JijModeling, an\nindustrial-strength mathematical optimization modeller, achieves this by\nseparating the symbolic representation of an optimization problem from the\ninput data. In this paper, we will report a real-world case study on a\nconstraint detection mechanism modulo the algebraic congruence using e-graphs,\nand describe heuristic criteria for designing rewriting systems. We give\nbenchmarking result that shows the performance impact of the constraint\ndetection mechanism.\n  We also introduce egg_recursive, a utility library for writing egg-terms as\nrecursive abstract syntax trees, reducing the burden of writing and maintaining\ncomplex terms in S-expressions."}
{"id": "2506.06544", "pdf": "https://arxiv.org/pdf/2506.06544", "abs": "https://arxiv.org/abs/2506.06544", "authors": ["Sophia Drossopoulou", "Julian Mackay", "Susan Eisenbach", "James Noble"], "title": "Reasoning about External Calls", "categories": ["cs.PL"], "comment": "86 pages, 25 main paper, and 58 pages of appendices, many diagrams\n  and figures", "summary": "In today's complex software, internal trusted code is tightly intertwined\nwith external untrusted code. To reason about internal code, programmers must\nreason about the potential effects of calls to external code, even though that\ncode is not trusted and may not even be available. The effects of external\ncalls can be limited, if internal code is programmed defensively, limiting\npotential effects by limiting access to the capabilities necessary to cause\nthose effects.\n  This paper addresses the specification and verification of internal code that\nrelies on encapsulation and object capabilities to limit the effects of\nexternal calls. We propose new assertions for access to capabilities, new\nspecifications for limiting effects, and a Hoare logic to verify that a module\nsatisfies its specification, even while making external calls. We illustrate\nthe approach though a running example with mechanised proofs, and prove\nsoundness of the Hoare logic."}
{"id": "2506.07834", "pdf": "https://arxiv.org/pdf/2506.07834", "abs": "https://arxiv.org/abs/2506.07834", "authors": ["Doehyun Baek", "Daniel Lehmann", "Ben L. Titzer", "Sukyoung Ryu", "Michael Pradel"], "title": "Execution-Aware Program Reduction for WebAssembly via Record and Replay", "categories": ["cs.PL", "cs.SE"], "comment": null, "summary": "WebAssembly (Wasm) programs may trigger bugs in their engine implementations.\nTo aid debugging, program reduction techniques try to produce a smaller variant\nof the input program that still triggers the bug. However, existing\nexecution-unaware program reduction techniques struggle with large and complex\nWasm programs, because they rely on static information and apply syntactic\ntransformations, while ignoring the valuable information offered by the input\nprogram's execution behavior.\n  We present RR-Reduce and Hybrid-Reduce, novel execution-aware program\nreduction techniques that leverage execution behaviors via record and replay.\nRR-Reduce identifies a bug-triggering function as the target function, isolates\nthat function from the rest of the program, and generates a reduced program\nthat replays only the interactions between the target function and the rest of\nthe program. Hybrid-Reduce combines a complementary execution-unaware reduction\ntechnique with RR-Reduce to further reduce program size.\n  We evaluate RR-Reduce and Hybrid-Reduce on 28 Wasm programs that trigger a\ndiverse set of bugs in three engines. On average, RR-Reduce reduces the\nprograms to 1.20 percent of their original size in 14.5 minutes, which\noutperforms the state of the art by 33.15 times in terms of reduction time.\nHybrid-Reduce reduces the programs to 0.13 percent of their original size in\n3.5 hours, which outperforms the state of the art by 3.42 times in terms of\nreduced program size and 2.26 times in terms of reduction time. We envision\nRR-Reduce as the go-to tool for rapid, on-demand debugging in minutes, and\nHybrid-Reduce for scenarios where developers require the smallest possible\nprograms."}
{"id": "2506.06835", "pdf": "https://arxiv.org/pdf/2506.06835", "abs": "https://arxiv.org/abs/2506.06835", "authors": ["Wang Fang", "Chris Heunen", "Robin Kaarsgaard"], "title": "Hadamard-$Î $: Equational Quantum Programming", "categories": ["quant-ph", "cs.PL"], "comment": "116 pages", "summary": "Quantum computing offers advantages over classical computation, yet the\nprecise features that set the two apart remain unclear. In the standard quantum\ncircuit model, adding a 1-qubit basis-changing gate -- commonly chosen to be\nthe Hadamard gate -- to a universal set of classical reversible gates yields\ncomputationally universal quantum computation. However, the computational\nbehaviours enabled by this addition are not fully characterised. We give such a\ncharacterisation by introducing a small quantum programming language extending\nthe universal classical reversible programming language $\\Pi$ with a single\nprimitive corresponding to the Hadamard gate. The language comes equipped with\na sound and complete categorical semantics that is specified by a purely\nequational theory, enabling reasoning about the equivalence of quantum programs\nin a way that can be automated. Completeness is shown by means of a novel\nfinite presentation, and corresponding synthesis algorithm, for the groups of\northogonal matrices with entries in the ring $\\mathbb{Z}[\\tfrac{1}{\\sqrt{2}}]$."}
