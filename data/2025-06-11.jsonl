{"id": "2506.08238", "pdf": "https://arxiv.org/pdf/2506.08238", "abs": "https://arxiv.org/abs/2506.08238", "authors": ["Parosh Abdulla", "Elli Anastasiadi", "Mohamed Faouzi Atig", "Samuel Grahn"], "title": "Verification of the Release-Acquire Semantics", "categories": ["cs.PL"], "comment": null, "summary": "The Release-Acquire (RA) semantics and its variants are some of the most\nfundamental models of concurrent semantics for architectures, programming\nlanguages, and distributed systems. Several steps have been taken in the\ndirection of testing such semantics, where one is interested in whether a\nsingle program execution is consistent with a memory model. The more general\nverification problem, i.e., checking whether all allowed program runs are\nconsistent with a memory model, has still not been studied as much. The purpose\nof this work is to bridge this gap. We tackle the verification problem, where,\ngiven an implementation described as a register machine, we check if any of its\nruns violates the RA semantics or its Strong (SRA) and Weak (WRA) variants. We\nshow that verifying WRA in this setup is in O([)n5 ], while verifying the RA\nand SRA is in both NP- and coNP-hard, and provide a PSPACE upper bound. This\nboth answers some fundamental questions about the complexity of these problems,\nbut also provides insights on the expressive power of register machines as a\nmodel."}
{"id": "2506.08396", "pdf": "https://arxiv.org/pdf/2506.08396", "abs": "https://arxiv.org/abs/2506.08396", "authors": ["Lifan Hu"], "title": "Linguine: A Natural-Language Programming Language with Formal Semantics and a Clean Compiler Pipeline", "categories": ["cs.PL"], "comment": null, "summary": "Linguine is a natural-language-inspired programming language that enables\nusers to write programs in a fluent, controlled subset of English while\npreserving formal semantics. The language introduces anaphoric constructs, such\nas pronoun variables (e.g., \"it\", \"them\"), that are statically resolved through\nreferent-tracking analysis combined with a Hindley-Milner-style type system.\nEach pronoun is guaranteed to be unambiguous and well-typed at compile time.\n  The Linguine compiler pipeline includes lexing, parsing, clause graph\nconstruction, desugaring into a typed intermediate representation, type\ninference, and abstract interpretation. This enables the early detection of\nsemantic errors, such as undefined or type-inconsistent references. A\nlightweight backend currently generates Python code.\n  This paper formalizes the core language, defines its typing and operational\nsemantics, and proves the soundness of its pronoun resolution mechanism. An\ninitial evaluation shows that Linguine allows the expression of concise and\nreadable programs while supporting static verification.\n  Linguine represents a step toward programming systems that prioritize human\nlinguistic intuition while remaining grounded in formal methods and\ntype-theoretic rigor."}
{"id": "2506.09043", "pdf": "https://arxiv.org/pdf/2506.09043", "abs": "https://arxiv.org/abs/2506.09043", "authors": ["Tianyu Chen", "Darshal Shetty", "Jeremy G. Siek", "Chao-Hong Chen", "Weixi Ma", "Arnaud Venet", "Rocky Liu"], "title": "Gradual Metaprogramming", "categories": ["cs.PL", "D.3"], "comment": "13 pages, 10 figures", "summary": "Data engineers increasingly use domain-specific languages (DSLs) to generate\nthe code for data pipelines. Such DSLs are often embedded in Python.\nUnfortunately, there are challenges in debugging the generation of data\npipelines: an error in a Python DSL script is often detected too late, after\nthe execution of the script, and the source code location that triggers the\nerror is hard to pinpoint.\n  In this paper, we focus on the F3 DSL of Meta (Facebook), which is a DSL\nembedded in Python (so it is dynamically-typed) to generate data pipeline\ndescription code that is statically-typed. We propose gradual metaprogramming\nto (1) provide a migration path toward statically typed DSLs, (2) immediately\nprovide earlier detection of code generation type errors, and (3) report the\nsource code location responsible for the type error. Gradual metaprogramming\naccomplishes this by type checking code fragments and incrementally performing\nruntime checks as they are spliced together. We define MetaGTLC, a\nmetaprogramming calculus in which a gradually-typed metalanguage manipulates a\nstatically-typed object language, and give semantics to it by translation to\nthe cast calculus MetaCC. We prove that successful metaevaluation always\ngenerates a well-typed object program and mechanize the proof in Agda."}
