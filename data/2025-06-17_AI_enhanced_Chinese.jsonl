{"id": "2506.12202", "pdf": "https://arxiv.org/pdf/2506.12202", "abs": "https://arxiv.org/abs/2506.12202", "authors": ["Stephen Mell", "Botong Zhang", "David Mell", "Shuo Li", "Ramya Ramalingam", "Nathan Yu", "Steve Zdancewic", "Osbert Bastani"], "title": "A Fast, Reliable, and Secure Programming Language for LLM Agents with Code Actions", "categories": ["cs.PL", "cs.AI", "cs.CR", "cs.LG"], "comment": null, "summary": "Modern large language models (LLMs) are often deployed as agents, calling\nexternal tools adaptively to solve tasks. Rather than directly calling tools,\nit can be more effective for LLMs to write code to perform the tool calls,\nenabling them to automatically generate complex control flow such as\nconditionals and loops. Such code actions are typically provided as Python\ncode, since LLMs are quite proficient at it; however, Python may not be the\nideal language due to limited built-in support for performance, security, and\nreliability. We propose a novel programming language for code actions, called\nQuasar, which has several benefits: (1) automated parallelization to improve\nperformance, (2) uncertainty quantification to improve reliability and mitigate\nhallucinations, and (3) security features enabling the user to validate\nactions. LLMs can write code in a subset of Python, which is automatically\ntranspiled to Quasar. We evaluate our approach on the ViperGPT visual question\nanswering agent, applied to the GQA dataset, demonstrating that LLMs with\nQuasar actions instead of Python actions retain strong performance, while\nreducing execution time when possible by 42%, improving security by reducing\nuser approval interactions when possible by 52%, and improving reliability by\napplying conformal prediction to achieve a desired target coverage level.", "AI": {"tldr": "\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u540d\u4e3aQuasar\u7684\u65b0\u7f16\u7a0b\u8bed\u8a00\uff0c\u7528\u4e8e\u66ff\u4ee3Python\u4f5c\u4e3aLLMs\u751f\u6210\u4ee3\u7801\u52a8\u4f5c\u7684\u8bed\u8a00\uff0c\u4ee5\u63d0\u9ad8\u6027\u80fd\u3001\u5b89\u5168\u6027\u548c\u53ef\u9760\u6027\u3002", "motivation": "Python\u5728\u6027\u80fd\u3001\u5b89\u5168\u6027\u548c\u53ef\u9760\u6027\u65b9\u9762\u7684\u4e0d\u8db3\u4fc3\u4f7f\u7814\u7a76\u8005\u5f00\u53d1\u66f4\u9002\u5408LLMs\u751f\u6210\u4ee3\u7801\u52a8\u4f5c\u7684\u8bed\u8a00\u3002", "method": "\u8bbe\u8ba1Quasar\u8bed\u8a00\uff0c\u652f\u6301\u81ea\u52a8\u5e76\u884c\u5316\u3001\u4e0d\u786e\u5b9a\u6027\u91cf\u5316\u548c\u5b89\u5168\u7279\u6027\uff0c\u5e76\u5c06LLMs\u751f\u6210\u7684Python\u5b50\u96c6\u4ee3\u7801\u81ea\u52a8\u8f6c\u6362\u4e3aQuasar\u3002", "result": "\u5728ViperGPT\u89c6\u89c9\u95ee\u7b54\u4ee3\u7406\u4e0a\u6d4b\u8bd5\uff0cQuasar\u4f7f\u6267\u884c\u65f6\u95f4\u51cf\u5c1142%\uff0c\u7528\u6237\u6279\u51c6\u4ea4\u4e92\u51cf\u5c1152%\uff0c\u5e76\u901a\u8fc7\u5171\u5f62\u9884\u6d4b\u63d0\u9ad8\u53ef\u9760\u6027\u3002", "conclusion": "Quasar\u662f\u4e00\u79cd\u6709\u6548\u7684\u66ff\u4ee3\u65b9\u6848\uff0c\u80fd\u5728\u4fdd\u6301\u6027\u80fd\u7684\u540c\u65f6\u663e\u8457\u63d0\u5347LLMs\u751f\u6210\u4ee3\u7801\u7684\u6548\u7387\u3001\u5b89\u5168\u6027\u548c\u53ef\u9760\u6027\u3002"}}
{"id": "2506.12212", "pdf": "https://arxiv.org/pdf/2506.12212", "abs": "https://arxiv.org/abs/2506.12212", "authors": ["Grant VanDomelen", "Gan Shen", "Lindsey Kuper", "Yao Li"], "title": "Freer Arrows and Why You Need Them in Haskell", "categories": ["cs.PL"], "comment": "In submission to the Haskell Symposium 2025", "summary": "Freer monads are a useful structure commonly used in various domains due to\ntheir expressiveness. However, a known issue with freer monads is that they are\nnot amenable to static analysis. This paper explores freer arrows, a relatively\nexpressive structure that is amenable to static analysis. We propose several\nvariants of freer arrows. We conduct a case study on choreographic programming\nto demonstrate the usefulness of freer arrows in Haskell.", "AI": {"tldr": "\u672c\u6587\u63a2\u8ba8\u4e86freer arrows\uff0c\u4e00\u79cd\u9002\u5408\u9759\u6001\u5206\u6790\u7684\u8868\u8fbe\u6027\u7ed3\u6784\uff0c\u5e76\u63d0\u51fa\u4e86\u51e0\u79cd\u53d8\u4f53\uff0c\u901a\u8fc7\u6848\u4f8b\u7814\u7a76\u5c55\u793a\u4e86\u5176\u5728Haskell\u4e2d\u7684\u5b9e\u7528\u6027\u3002", "motivation": "freer monads\u867d\u7136\u8868\u8fbe\u6027\u5f3a\uff0c\u4f46\u4e0d\u9002\u5408\u9759\u6001\u5206\u6790\uff0c\u56e0\u6b64\u9700\u8981\u63a2\u7d22\u66f4\u9002\u5408\u9759\u6001\u5206\u6790\u7684\u66ff\u4ee3\u7ed3\u6784\u3002", "method": "\u63d0\u51fa\u51e0\u79cdfreer arrows\u7684\u53d8\u4f53\uff0c\u5e76\u901a\u8fc7choreographic programming\u7684\u6848\u4f8b\u7814\u7a76\u9a8c\u8bc1\u5176\u6709\u6548\u6027\u3002", "result": "\u5c55\u793a\u4e86freer arrows\u5728Haskell\u4e2d\u7684\u5b9e\u7528\u6027\uff0c\u7279\u522b\u662f\u5728\u9759\u6001\u5206\u6790\u65b9\u9762\u7684\u4f18\u52bf\u3002", "conclusion": "freer arrows\u662f\u4e00\u79cd\u9002\u5408\u9759\u6001\u5206\u6790\u7684\u8868\u8fbe\u6027\u7ed3\u6784\uff0c\u4e3a\u76f8\u5173\u9886\u57df\u63d0\u4f9b\u4e86\u65b0\u7684\u53ef\u80fd\u6027\u3002"}}
{"id": "2506.13383", "pdf": "https://arxiv.org/pdf/2506.13383", "abs": "https://arxiv.org/abs/2506.13383", "authors": ["Jules Jacobs", "Nate Foster", "Tobias Kapp\u00e9", "Dexter Kozen", "Lily Saada", "Alexandra Silva", "Jana Wagemaker"], "title": "StacKAT: Infinite State Network Verification", "categories": ["cs.PL"], "comment": null, "summary": "We develop StacKAT, a network verification language featuring loops, finite\nstate variables, nondeterminism, and - most importantly - access to a stack\nwith accompanying push and pop operations. By viewing the variables and stack\nas the (parsed) headers and (to-be-parsed) contents of a network packet,\nStacKAT can express a wide range of network behaviors including parsing, source\nrouting, and telemetry. These behaviors are difficult or impossible to model\nusing existing languages like NetKAT. We develop a decision procedure for\nStacKAT program equivalence, based on finite automata. This decision procedure\nprovides the theoretical basis for verifying network-wide properties and is\nable to provide counterexamples for inequivalent programs. Finally, we provide\nan axiomatization of StacKAT equivalence and establish its completeness.", "AI": {"tldr": "StacKAT\u662f\u4e00\u79cd\u652f\u6301\u5faa\u73af\u3001\u6709\u9650\u72b6\u6001\u53d8\u91cf\u3001\u975e\u786e\u5b9a\u6027\u548c\u5806\u6808\u64cd\u4f5c\uff08push/pop\uff09\u7684\u7f51\u7edc\u9a8c\u8bc1\u8bed\u8a00\uff0c\u53ef\u8868\u8fbe\u590d\u6742\u7684\u7f51\u7edc\u884c\u4e3a\uff08\u5982\u89e3\u6790\u3001\u6e90\u8def\u7531\u548c\u9065\u6d4b\uff09\u3002\u5176\u7b49\u4ef7\u6027\u5224\u5b9a\u57fa\u4e8e\u6709\u9650\u81ea\u52a8\u673a\uff0c\u652f\u6301\u7f51\u7edc\u8303\u56f4\u5c5e\u6027\u9a8c\u8bc1\u5e76\u63d0\u4f9b\u53cd\u4f8b\u3002", "motivation": "\u73b0\u6709\u8bed\u8a00\uff08\u5982NetKAT\uff09\u96be\u4ee5\u5efa\u6a21\u590d\u6742\u7684\u7f51\u7edc\u884c\u4e3a\uff08\u5982\u89e3\u6790\u548c\u6e90\u8def\u7531\uff09\uff0c\u56e0\u6b64\u5f00\u53d1StacKAT\u4ee5\u586b\u8865\u8fd9\u4e00\u7a7a\u767d\u3002", "method": "\u901a\u8fc7\u5c06\u53d8\u91cf\u548c\u5806\u6808\u89c6\u4e3a\u7f51\u7edc\u5305\u7684\u5934\u90e8\u548c\u5185\u5bb9\uff0c\u8bbe\u8ba1StacKAT\u8bed\u8a00\uff0c\u5e76\u57fa\u4e8e\u6709\u9650\u81ea\u52a8\u673a\u5f00\u53d1\u7b49\u4ef7\u6027\u5224\u5b9a\u7a0b\u5e8f\u3002", "result": "StacKAT\u80fd\u8868\u8fbe\u66f4\u5e7f\u6cdb\u7684\u7f51\u7edc\u884c\u4e3a\uff0c\u4e14\u5176\u7b49\u4ef7\u6027\u5224\u5b9a\u7a0b\u5e8f\u652f\u6301\u9a8c\u8bc1\u7f51\u7edc\u5c5e\u6027\u5e76\u63d0\u4f9b\u53cd\u4f8b\u3002", "conclusion": "StacKAT\u4e3a\u590d\u6742\u7f51\u7edc\u884c\u4e3a\u5efa\u6a21\u548c\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u6709\u6548\u5de5\u5177\uff0c\u5176\u7406\u8bba\u6846\u67b6\uff08\u5305\u62ec\u7b49\u4ef7\u6027\u5224\u5b9a\u548c\u516c\u7406\u5316\uff09\u5b8c\u5907\u4e14\u5b9e\u7528\u3002"}}
