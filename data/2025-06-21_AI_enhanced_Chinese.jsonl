{"id": "2506.15174", "pdf": "https://arxiv.org/pdf/2506.15174", "abs": "https://arxiv.org/abs/2506.15174", "authors": ["Hossein Albakri", "Kazem Cheshmi"], "title": "A Novel Compiler Transformation for Fast Sparse Matrix Multiplication in GPUs", "categories": ["cs.PL"], "comment": null, "summary": "Sparse data structures are commonly used in neural networks to reduce the\nmemory footprint. These data structures are compact but cause irregularities\nsuch as random memory accesses, which prevent efficient use of the memory\nhierarchy. GPUs are a common platform for machine learning practitioners, but\nrunning compact data structures on these devices often leads to slow-downs due\nto inefficient use of computing and memory resources. This paper proposes a new\ncompiler transformation, enumerate-and-sparse-coarsen, that accelerates sparse\nmatrix-matrix multiplication (SPMM) on GPU devices. The transformation\nincreases data reuse in registers and caches while creating more balanced\nworkloads for GPU computing resources. The transformation is tested on sparse\nneural networks in convolutional and transformer models. On an A100 GPU and\nacross a columns of matrix B (bCols) in $ A \\times B = C$ from range of 32 to\n128, the transformation yields a geometric mean speedup of 1.84$\\times$ to\n2.27$\\times$ compared to cuBLAS and cuSPARSE baselines, respectively.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u7f16\u8bd1\u5668\u8f6c\u6362\u65b9\u6cd5\uff0c\u7528\u4e8e\u52a0\u901fGPU\u4e0a\u7684\u7a00\u758f\u77e9\u9635\u4e58\u6cd5\uff08SPMM\uff09\uff0c\u63d0\u9ad8\u6570\u636e\u5728\u5bc4\u5b58\u5668\u548c\u7f13\u5b58\u4e2d\u7684\u91cd\u7528\u7387\uff0c\u5e76\u5728\u7a00\u758f\u795e\u7ecf\u7f51\u7edc\u4e2d\u6d4b\u8bd5\uff0c\u53d6\u5f97\u4e86\u663e\u8457\u7684\u6027\u80fd\u63d0\u5347\u3002", "motivation": "\u7a00\u758f\u6570\u636e\u7ed3\u6784\u5728\u795e\u7ecf\u7f51\u7edc\u4e2d\u7528\u4e8e\u51cf\u5c11\u5185\u5b58\u5360\u7528\uff0c\u4f46\u4f1a\u5bfc\u81f4\u5185\u5b58\u8bbf\u95ee\u4e0d\u89c4\u5219\uff0c\u5f71\u54cdGPU\u7684\u8ba1\u7b97\u548c\u5185\u5b58\u8d44\u6e90\u5229\u7528\u6548\u7387\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u540d\u4e3aenumerate-and-sparse-coarsen\u7684\u7f16\u8bd1\u5668\u8f6c\u6362\uff0c\u4f18\u5316SPMM\u5728GPU\u4e0a\u7684\u6267\u884c\uff0c\u589e\u52a0\u6570\u636e\u91cd\u7528\u5e76\u5e73\u8861\u5de5\u4f5c\u8d1f\u8f7d\u3002", "result": "\u5728A100 GPU\u4e0a\u6d4b\u8bd5\uff0c\u4e0ecuBLAS\u548ccuSPARSE\u57fa\u7ebf\u76f8\u6bd4\uff0c\u6027\u80fd\u63d0\u5347\u51e0\u4f55\u5e73\u5747\u4e3a1.84\u500d\u81f32.27\u500d\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u663e\u8457\u63d0\u5347\u4e86\u7a00\u758f\u77e9\u9635\u4e58\u6cd5\u5728GPU\u4e0a\u7684\u6027\u80fd\uff0c\u9002\u7528\u4e8e\u5377\u79ef\u548cTransformer\u6a21\u578b\u3002"}}
{"id": "2506.15424", "pdf": "https://arxiv.org/pdf/2506.15424", "abs": "https://arxiv.org/abs/2506.15424", "authors": ["Michael Mendler", "Marc Pouzet"], "title": "PSM: Policy Synchronised Deterministic Memory", "categories": ["cs.PL"], "comment": "This report summarises work on coding the theory of\n  policy-synchronised memory (see https://rdcu.be/erBwl) in Haskell. This was\n  developed for a graduate level course on Functional Reactive Programming\n  taught at Bamberg University by the first author during 2020-2023. An early\n  version of the PSM library had been presented at the SYNCHRON Workshop\n  (Aussois, France), November 2019", "summary": "Concurrency and determinacy do not go well with each other when resources\nmust be shared. Haskell provides parallel programming abstractions such as IVar\nand LVar in the Par monad and concurrent abstractions such as MVar and TVar in\nthe in IO and STM monads, respectively. The former are determinate but have no\ndestructive updates and the latter have destructive updates but do not\nguarantee determinacy. Programming patterns that are both concurrent and\ndeterminate, such as those provided by Kahn or Berry require memory\nabstractions at a higher level than is currently available. In this paper we\ndescribe a new type context PSM for policy synchronised memory in Haskell. Like\nSTM and IO, the computations in PSM can access persistent state and, as a\nside-effect, update the memory in imperative style. Like the Par and IO monads,\nPSM supports concurrent threads and shared state. However, in contrast to IO,\nour PSM contexts are race-free since concurrent accesses are policy coordinated\nwhich guarantees determinacy.Well-typed transactions in the PSM context can\naccommodate abstract data structures that are imperative, concurrently\nshareable and still behave deterministically, by construction.", "AI": {"tldr": "\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684Haskell\u7c7b\u578b\u4e0a\u4e0b\u6587PSM\uff0c\u7528\u4e8e\u5b9e\u73b0\u5e76\u53d1\u4e14\u786e\u5b9a\u6027\u7684\u5185\u5b58\u8bbf\u95ee\uff0c\u89e3\u51b3\u4e86\u73b0\u6709\u62bd\u8c61\uff08\u5982Par\u548cIO\uff09\u5728\u5171\u4eab\u8d44\u6e90\u65f6\u65e0\u6cd5\u517c\u987e\u5e76\u53d1\u6027\u548c\u786e\u5b9a\u6027\u7684\u95ee\u9898\u3002", "motivation": "\u73b0\u6709Haskell\u7684\u5e76\u884c\u548c\u5e76\u53d1\u62bd\u8c61\uff08\u5982IVar\u3001LVar\u3001MVar\u548cTVar\uff09\u65e0\u6cd5\u540c\u65f6\u6ee1\u8db3\u5e76\u53d1\u6027\u548c\u786e\u5b9a\u6027\u9700\u6c42\uff0c\u9650\u5236\u4e86\u7f16\u7a0b\u6a21\u5f0f\u7684\u7075\u6d3b\u6027\u3002", "method": "\u5f15\u5165PSM\uff08Policy Synchronised Memory\uff09\u7c7b\u578b\u4e0a\u4e0b\u6587\uff0c\u652f\u6301\u5e76\u53d1\u7ebf\u7a0b\u548c\u5171\u4eab\u72b6\u6001\uff0c\u5e76\u901a\u8fc7\u7b56\u7565\u534f\u8c03\u4fdd\u8bc1\u786e\u5b9a\u6027\u3002", "result": "PSM\u5b9e\u73b0\u4e86\u5e76\u53d1\u4e14\u786e\u5b9a\u6027\u7684\u5185\u5b58\u8bbf\u95ee\uff0c\u652f\u6301\u62bd\u8c61\u6570\u636e\u7ed3\u6784\u7684\u5171\u4eab\u548c\u786e\u5b9a\u6027\u884c\u4e3a\u3002", "conclusion": "PSM\u4e3aHaskell\u63d0\u4f9b\u4e86\u4e00\u79cd\u65b0\u7684\u5e76\u53d1\u7f16\u7a0b\u62bd\u8c61\uff0c\u517c\u5177\u5e76\u53d1\u6027\u548c\u786e\u5b9a\u6027\uff0c\u6269\u5c55\u4e86\u7f16\u7a0b\u6a21\u5f0f\u7684\u53ef\u80fd\u6027\u3002"}}
{"id": "2506.15135", "pdf": "https://arxiv.org/pdf/2506.15135", "abs": "https://arxiv.org/abs/2506.15135", "authors": ["Zhengqun Koo"], "title": "Towards Bug-Free Distributed Go Programs", "categories": ["cs.SE", "cs.LO", "cs.PL", "F.3.1; F.1.2"], "comment": "Version 1. B.Comp. Dissertation", "summary": "Programmers of distributed systems need to reason about concurrency to avoid\nraces. However, reasoning about concurrency is difficult, and unexpected races\nshow up as bugs. Data race detection in shared memory systems is well-studied\n(dynamic data race detection [13], behavioral types [15], dynamic race\ndetection [31]). Similar to how a data race consists of reads and writes not\nrelated by happens-before at a shared memory location, a communication race\nconsists of receives and sends not related by happens-before on a shared\nchannel. Communication races are problematic: a receiver expects a specific\nmessage from a specific sender, but with a communication race, the receiver can\nreceive a message meant for another receiver, or not receive anything at all.\nIn this work, we describe a verification framework that can prove the absence\nof communication races for distributed programs that use a subset of the Go\nprogramming language, where synchronization is mainly achieved via message\npassing. We statically reason about how a distributed program executes, using a\nhappens-before order, extended to buffered and unbuffered channels.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u9759\u6001\u9a8c\u8bc1\u6846\u67b6\uff0c\u7528\u4e8e\u8bc1\u660e\u4f7f\u7528Go\u8bed\u8a00\u5b50\u96c6\u7684\u5206\u5e03\u5f0f\u7a0b\u5e8f\u4e2d\u901a\u4fe1\u7ade\u4e89\u7684\u7f3a\u5931\u3002", "motivation": "\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d\u7684\u5e76\u53d1\u95ee\u9898\uff08\u5982\u901a\u4fe1\u7ade\u4e89\uff09\u53ef\u80fd\u5bfc\u81f4\u63a5\u6536\u9519\u8bef\u6d88\u606f\u6216\u65e0\u6d88\u606f\u63a5\u6536\uff0c\u9700\u8981\u4e00\u79cd\u65b9\u6cd5\u6765\u907f\u514d\u6b64\u7c7b\u95ee\u9898\u3002", "method": "\u6269\u5c55\u4e86happens-before\u987a\u5e8f\uff0c\u652f\u6301\u7f13\u51b2\u548c\u975e\u7f13\u51b2\u901a\u9053\uff0c\u9759\u6001\u5206\u6790\u5206\u5e03\u5f0f\u7a0b\u5e8f\u7684\u6267\u884c\u3002", "result": "\u6846\u67b6\u80fd\u591f\u8bc1\u660e\u7a0b\u5e8f\u5728\u901a\u4fe1\u7ade\u4e89\u65b9\u9762\u7684\u5b89\u5168\u6027\u3002", "conclusion": "\u8be5\u6846\u67b6\u4e3a\u5206\u5e03\u5f0f\u7a0b\u5e8f\u63d0\u4f9b\u4e86\u4e00\u79cd\u9759\u6001\u9a8c\u8bc1\u901a\u4fe1\u7ade\u4e89\u7f3a\u5931\u7684\u6709\u6548\u65b9\u6cd5\u3002"}}
