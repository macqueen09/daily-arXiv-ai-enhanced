{"id": "2506.23058", "pdf": "https://arxiv.org/pdf/2506.23058", "abs": "https://arxiv.org/abs/2506.23058", "authors": ["Nikolaj Hey Hinnerskov", "Robert Schenck", "Cosmin E. Oancea"], "title": "Verifying Properties of Index Arrays in a Purely-Functional Data-Parallel Language", "categories": ["cs.PL", "cs.DC"], "comment": null, "summary": "This paper presents a novel approach to automatically verify properties of\npure data-parallel programs with non-linear indexing -- expressed as pre- and\npost-conditions on functions. Programs consist of nests of second-order array\ncombinators (e.g., map, scan, and scatter) and loops. The key idea is to\nrepresent arrays as index functions: programs are index function\ntransformations over which properties are propagated and inferred. Our\nframework proves properties on index functions by distilling them into\nalgebraic (in)equalities and discharging them to a Fourier-Motzkin-based\nsolver. The framework is practical and accessible: properties are not\nrestricted to a decidable logic, but instead are carefully selected to express\npractically useful guarantees that can be automatically reasoned about and\ninferred. These guarantees extend beyond program correctness and can be\nexploited by the entire compiler pipeline for optimization. We implement our\nsystem in the pure data-parallel language Futhark and demonstrate its\npracticality on seven applications, reporting an average verification time of 1\nsecond. Two case studies show how eliminating dynamic verification in GPU\nprograms results in significant speedups.", "AI": {"tldr": "\u63d0\u51fa\u4e00\u79cd\u65b0\u65b9\u6cd5\uff0c\u901a\u8fc7\u7d22\u5f15\u51fd\u6570\u8868\u793a\u6570\u7ec4\uff0c\u81ea\u52a8\u9a8c\u8bc1\u7eaf\u6570\u636e\u5e76\u884c\u7a0b\u5e8f\u7684\u5c5e\u6027\uff0c\u5e76\u5229\u7528\u4ee3\u6570\u4e0d\u7b49\u5f0f\u6c42\u89e3\u5668\u8fdb\u884c\u63a8\u7406\u3002", "motivation": "\u89e3\u51b3\u7eaf\u6570\u636e\u5e76\u884c\u7a0b\u5e8f\u4e2d\u975e\u7ebf\u6027\u7d22\u5f15\u5c5e\u6027\u7684\u81ea\u52a8\u9a8c\u8bc1\u95ee\u9898\uff0c\u6269\u5c55\u7f16\u8bd1\u5668\u4f18\u5316\u80fd\u529b\u3002", "method": "\u5c06\u6570\u7ec4\u8868\u793a\u4e3a\u7d22\u5f15\u51fd\u6570\uff0c\u901a\u8fc7\u4ee3\u6570\u4e0d\u7b49\u5f0f\u6c42\u89e3\u5668\u9a8c\u8bc1\u5c5e\u6027\uff0c\u9002\u7528\u4e8eFuthark\u8bed\u8a00\u3002", "result": "\u57287\u4e2a\u5e94\u7528\u4e2d\u5e73\u5747\u9a8c\u8bc1\u65f6\u95f4\u4e3a1\u79d2\uff0c\u52a8\u6001\u9a8c\u8bc1\u6d88\u9664\u53ef\u663e\u8457\u63d0\u5347GPU\u7a0b\u5e8f\u6027\u80fd\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u5b9e\u7528\u4e14\u9ad8\u6548\uff0c\u80fd\u6269\u5c55\u7f16\u8bd1\u5668\u4f18\u5316\u8303\u56f4\uff0c\u9002\u7528\u4e8e\u5b9e\u9645\u5e94\u7528\u3002"}}
{"id": "2506.23320", "pdf": "https://arxiv.org/pdf/2506.23320", "abs": "https://arxiv.org/abs/2506.23320", "authors": ["Nicola Assolini", "Alessandra Di Pierro"], "title": "A Denotational Semantics for Quantum Loops", "categories": ["cs.PL"], "comment": "17 pages", "summary": "Programming a quantum computer, i.e., implementing quantum algorithms on a\nquantum processor-based copmputer architecture, is a task that can be addressed\n(just as for classical computers) at different levels of abstraction. This\npaper proposes a denotational semantics for high-level quantum programming\nconstructs, focusing on the conceptual meaning of quantum-controlled branching\nand iteration. We introduce a denotational domain where a mathematical meaning\nof a quantum control flow with loops can be defined, which reflects the\ncoherent evolution of the quantum system implementing the program.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u7528\u4e8e\u9ad8\u7ea7\u91cf\u5b50\u7f16\u7a0b\u7ed3\u6784\u7684\u6307\u79f0\u8bed\u4e49\uff0c\u91cd\u70b9\u7814\u7a76\u91cf\u5b50\u63a7\u5236\u5206\u652f\u548c\u8fed\u4ee3\u7684\u6982\u5ff5\u610f\u4e49\u3002", "motivation": "\u91cf\u5b50\u8ba1\u7b97\u673a\u7f16\u7a0b\u9700\u8981\u5728\u4e0d\u540c\u62bd\u8c61\u5c42\u6b21\u4e0a\u5b9e\u73b0\u91cf\u5b50\u7b97\u6cd5\uff0c\u672c\u6587\u65e8\u5728\u4e3a\u91cf\u5b50\u63a7\u5236\u6d41\u63d0\u4f9b\u6570\u5b66\u5b9a\u4e49\u3002", "method": "\u5f15\u5165\u4e86\u4e00\u4e2a\u6307\u79f0\u57df\uff0c\u7528\u4e8e\u5b9a\u4e49\u91cf\u5b50\u63a7\u5236\u6d41\uff08\u5305\u62ec\u5faa\u73af\uff09\u7684\u6570\u5b66\u610f\u4e49\uff0c\u53cd\u6620\u91cf\u5b50\u7a0b\u5e8f\u7684\u76f8\u5e72\u6f14\u5316\u3002", "result": "\u63d0\u51fa\u4e86\u4e00\u79cd\u80fd\u591f\u63cf\u8ff0\u91cf\u5b50\u63a7\u5236\u6d41\u548c\u5faa\u73af\u7684\u8bed\u4e49\u6846\u67b6\u3002", "conclusion": "\u8be5\u6307\u79f0\u8bed\u4e49\u4e3a\u91cf\u5b50\u7f16\u7a0b\u63d0\u4f9b\u4e86\u7406\u8bba\u57fa\u7840\uff0c\u652f\u6301\u91cf\u5b50\u63a7\u5236\u6d41\u548c\u5faa\u73af\u7684\u6570\u5b66\u5efa\u6a21\u3002"}}
{"id": "2506.23407", "pdf": "https://arxiv.org/pdf/2506.23407", "abs": "https://arxiv.org/abs/2506.23407", "authors": ["Marcus Edwards"], "title": "Compiling a Q# Subset to QASM 3.0 in TypeScript via a JSON Based IR", "categories": ["cs.PL", "quant-ph"], "comment": null, "summary": "We implement a compile toolchain from Q# to QASM 3.0 including a\nfull-featured lexer and parser implementation, as well as a compiler that\nsupports a subset of Q# features. The lexer, parser and compiler are shown to\nwork with various input Q# programs and the implementation is compared against\nexisting Q# compile tools. Unlike the Microsoft implementation of the official\nQ# compile toolchain, our implementation is written in TypeScript in order to\nport functionality to web environments.", "AI": {"tldr": "\u5b9e\u73b0\u4e86\u4eceQ#\u5230QASM 3.0\u7684\u7f16\u8bd1\u5de5\u5177\u94fe\uff0c\u5305\u62ec\u5b8c\u6574\u7684\u8bcd\u6cd5\u5206\u6790\u548c\u8bed\u6cd5\u5206\u6790\u5668\uff0c\u652f\u6301\u90e8\u5206Q#\u529f\u80fd\u3002", "motivation": "\u4e3a\u5728Web\u73af\u5883\u4e2d\u5b9e\u73b0Q#\u529f\u80fd\uff0c\u5f00\u53d1\u4e86\u4e00\u4e2a\u57fa\u4e8eTypeScript\u7684\u7f16\u8bd1\u5de5\u5177\u94fe\u3002", "method": "\u5b9e\u73b0\u4e86\u8bcd\u6cd5\u5206\u6790\u5668\u3001\u8bed\u6cd5\u5206\u6790\u5668\u548c\u7f16\u8bd1\u5668\uff0c\u652f\u6301\u90e8\u5206Q#\u529f\u80fd\uff0c\u5e76\u4e0e\u73b0\u6709\u5de5\u5177\u8fdb\u884c\u6bd4\u8f83\u3002", "result": "\u5de5\u5177\u94fe\u6210\u529f\u5904\u7406\u591a\u79cdQ#\u7a0b\u5e8f\uff0c\u9a8c\u8bc1\u4e86\u5176\u529f\u80fd\u3002", "conclusion": "\u8be5\u5de5\u5177\u94fe\u4e3aWeb\u73af\u5883\u63d0\u4f9b\u4e86Q#\u7f16\u8bd1\u529f\u80fd\uff0c\u533a\u522b\u4e8e\u5fae\u8f6f\u7684\u5b98\u65b9\u5b9e\u73b0\u3002"}}
{"id": "2506.22776", "pdf": "https://arxiv.org/pdf/2506.22776", "abs": "https://arxiv.org/abs/2506.22776", "authors": ["Sen Fang", "Weiyuan Ding", "Antonio Mastropaolo", "Bowen Xu"], "title": "Smaller = Weaker? Benchmarking Robustness of Quantized LLMs in Code Generation", "categories": ["cs.SE", "cs.AI", "cs.PL"], "comment": "13 pages, 6 figures", "summary": "Quantization has emerged as a mainstream method for compressing Large\nLanguage Models (LLMs), reducing memory requirements and accelerating inference\nwithout architectural modifications. While existing research primarily focuses\non evaluating the effectiveness of quantized LLMs compared to their original\ncounterparts, the impact on robustness remains largely unexplored.In this\npaper, we present the first systematic investigation of how quantization\naffects the robustness of LLMs in code generation tasks. Through extensive\nexperiments across four prominent LLM families (LLaMA, DeepSeek, CodeGen, and\nStarCoder) with parameter scales ranging from 350M to 33B, we evaluate\nrobustness from dual perspectives: adversarial attacks on input prompts and\nnoise perturbations on model architecture. Our findings challenge conventional\nwisdom by demonstrating that quantized LLMs often exhibit superior robustness\ncompared to their full-precision counterparts, with 51.59% versus 42.86% of our\nadversarial experiments showing better resilience in quantized LLMs. Similarly,\nour noise perturbation experiments also confirm that LLMs after quantitation\ngenerally withstand higher levels of weight disturbances. These results suggest\nthat quantization not only reduces computational requirements but can actually\nenhance LLMs' reliability in code generation tasks, providing valuable insights\nfor developing more robust and efficient LLM deployment strategies.", "AI": {"tldr": "\u91cf\u5316\u6280\u672f\u80fd\u538b\u7f29\u5927\u578b\u8bed\u8a00\u6a21\u578b\uff08LLM\uff09\uff0c\u51cf\u5c11\u5185\u5b58\u9700\u6c42\u5e76\u52a0\u901f\u63a8\u7406\uff0c\u4f46\u5176\u5bf9\u9c81\u68d2\u6027\u7684\u5f71\u54cd\u5c1a\u672a\u5145\u5206\u7814\u7a76\u3002\u672c\u6587\u9996\u6b21\u7cfb\u7edf\u7814\u7a76\u4e86\u91cf\u5316\u5bf9LLM\u5728\u4ee3\u7801\u751f\u6210\u4efb\u52a1\u4e2d\u9c81\u68d2\u6027\u7684\u5f71\u54cd\uff0c\u53d1\u73b0\u91cf\u5316\u540e\u7684\u6a21\u578b\u5f80\u5f80\u6bd4\u5168\u7cbe\u5ea6\u6a21\u578b\u66f4\u9c81\u68d2\u3002", "motivation": "\u91cf\u5316\u6280\u672f\u88ab\u5e7f\u6cdb\u7528\u4e8e\u538b\u7f29LLM\uff0c\u4f46\u5176\u5bf9\u6a21\u578b\u9c81\u68d2\u6027\u7684\u5f71\u54cd\u5c1a\u672a\u88ab\u5145\u5206\u63a2\u7d22\u3002\u672c\u6587\u65e8\u5728\u586b\u8865\u8fd9\u4e00\u7a7a\u767d\uff0c\u7814\u7a76\u91cf\u5316\u5982\u4f55\u5f71\u54cdLLM\u5728\u4ee3\u7801\u751f\u6210\u4efb\u52a1\u4e2d\u7684\u9c81\u68d2\u6027\u3002", "method": "\u901a\u8fc7\u5b9e\u9a8c\u8bc4\u4f30\u56db\u79cd\u4e3b\u6d41LLM\u5bb6\u65cf\uff08LLaMA\u3001DeepSeek\u3001CodeGen\u548cStarCoder\uff09\uff0c\u53c2\u6570\u89c4\u6a21\u4ece350M\u523033B\uff0c\u4ece\u5bf9\u6297\u653b\u51fb\u548c\u566a\u58f0\u6270\u52a8\u4e24\u4e2a\u89d2\u5ea6\u91cf\u5316\u9c81\u68d2\u6027\u3002", "result": "\u91cf\u5316\u540e\u7684LLM\u5728\u5bf9\u6297\u653b\u51fb\u548c\u566a\u58f0\u6270\u52a8\u5b9e\u9a8c\u4e2d\u8868\u73b0\u4f18\u4e8e\u5168\u7cbe\u5ea6\u6a21\u578b\uff0c51.59%\u7684\u5bf9\u6297\u5b9e\u9a8c\u548c\u566a\u58f0\u6270\u52a8\u5b9e\u9a8c\u663e\u793a\u91cf\u5316\u6a21\u578b\u66f4\u5177\u9c81\u68d2\u6027\u3002", "conclusion": "\u91cf\u5316\u4e0d\u4ec5\u80fd\u964d\u4f4e\u8ba1\u7b97\u9700\u6c42\uff0c\u8fd8\u80fd\u589e\u5f3aLLM\u5728\u4ee3\u7801\u751f\u6210\u4efb\u52a1\u4e2d\u7684\u9c81\u68d2\u6027\uff0c\u4e3a\u5f00\u53d1\u66f4\u9ad8\u6548\u548c\u53ef\u9760\u7684LLM\u90e8\u7f72\u7b56\u7565\u63d0\u4f9b\u4e86\u65b0\u601d\u8def\u3002"}}
{"id": "2506.23281", "pdf": "https://arxiv.org/pdf/2506.23281", "abs": "https://arxiv.org/abs/2506.23281", "authors": ["Xintong Zhou", "Zhenyang Xu", "Chengnian Sun"], "title": "On the Feasibility of Deduplicating Compiler Bugs with Bisection", "categories": ["cs.SE", "cs.PL"], "comment": null, "summary": "Random testing has proven to be an effective technique for compiler\nvalidation. However, the debugging of bugs identified through random testing\npresents a significant challenge due to the frequent occurrence of duplicate\ntest programs that expose identical compiler bugs. The process to identify\nduplicates is a practical research problem known as bug deduplication. Prior\nmethodologies for compiler bug deduplication primarily rely on program analysis\nto extract bug-related features for duplicate identification, which can result\nin substantial computational overhead and limited generalizability. This paper\ninvestigates the feasibility of employing bisection, a standard debugging\nprocedure largely overlooked in prior research on compiler bug deduplication,\nfor this purpose. Our study demonstrates that the utilization of bisection to\nlocate failure-inducing commits provides a valuable criterion for\ndeduplication, albeit one that requires supplementary techniques for more\naccurate identification. Building on these results, we introduce BugLens, a\nnovel deduplication method that primarily uses bisection, enhanced by the\nidentification of bug-triggering optimizations to minimize false negatives.\nEmpirical evaluations conducted on four real-world datasets demonstrate that\nBugLens significantly outperforms the state-of-the-art analysis-based\nmethodologies Tamer and D3 by saving an average of 26.98% and 9.64% human\neffort to identify the same number of distinct bugs. Given the inherent\nsimplicity and generalizability of bisection, it presents a highly practical\nsolution for compiler bug deduplication in real-world applications.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u4e8c\u5206\u6cd5\u7684\u7f16\u8bd1\u5668Bug\u53bb\u91cd\u65b9\u6cd5BugLens\uff0c\u663e\u8457\u4f18\u4e8e\u73b0\u6709\u57fa\u4e8e\u7a0b\u5e8f\u5206\u6790\u7684\u65b9\u6cd5\u3002", "motivation": "\u968f\u673a\u6d4b\u8bd5\u4e2d\u91cd\u590d\u7684\u6d4b\u8bd5\u7a0b\u5e8f\u66b4\u9732\u76f8\u540c\u7f16\u8bd1\u5668Bug\uff0c\u73b0\u6709\u53bb\u91cd\u65b9\u6cd5\u8ba1\u7b97\u5f00\u9500\u5927\u4e14\u6cdb\u5316\u80fd\u529b\u6709\u9650\u3002", "method": "\u5229\u7528\u4e8c\u5206\u6cd5\u5b9a\u4f4d\u5bfc\u81f4Bug\u7684\u63d0\u4ea4\uff0c\u5e76\u7ed3\u5408\u89e6\u53d1Bug\u7684\u4f18\u5316\u6280\u672f\uff0c\u63d0\u51faBugLens\u65b9\u6cd5\u3002", "result": "\u5728\u56db\u4e2a\u771f\u5b9e\u6570\u636e\u96c6\u4e0a\uff0cBugLens\u6bd4Tamer\u548cD3\u5206\u522b\u8282\u770126.98%\u548c9.64%\u7684\u4eba\u529b\u3002", "conclusion": "\u4e8c\u5206\u6cd5\u56e0\u5176\u7b80\u5355\u6027\u548c\u6cdb\u5316\u80fd\u529b\uff0c\u4e3a\u7f16\u8bd1\u5668Bug\u53bb\u91cd\u63d0\u4f9b\u4e86\u5b9e\u7528\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2506.23696", "pdf": "https://arxiv.org/pdf/2506.23696", "abs": "https://arxiv.org/abs/2506.23696", "authors": ["Francisco Oliveira", "Alexandra Mendes", "Carolina Carreira"], "title": "What Challenges Do Developers Face When Using Verification-Aware Programming Languages?", "categories": ["cs.SE", "cs.PL"], "comment": null, "summary": "Software reliability is critical in ensuring that the digital systems we\ndepend on function correctly. In software development, increasing software\nreliability often involves testing. However, for complex and critical systems,\ndevelopers can use Design by Contract (DbC) methods to define precise\nspecifications that software components must satisfy. Verification-Aware (VA)\nprogramming languages support DbC and formal verification at compile-time or\nrun-time, offering stronger correctness guarantees than traditional testing.\nHowever, despite the strong guarantees provided by VA languages, their adoption\nremains limited. In this study, we investigate the barriers to adopting VA\nlanguages by analyzing developer discussions on public forums using topic\nmodeling techniques. We complement this analysis with a developer survey to\nbetter understand the practical challenges associated with VA languages. Our\nfindings reveal key obstacles to adoption, including steep learning curves and\nusability issues. Based on these insights, we identify actionable\nrecommendations to improve the usability and accessibility of VA languages. Our\nfindings suggest that simplifying tool interfaces, providing better educational\nmaterials, and improving integration with everyday development environments\ncould improve the usability and adoption of these languages. Our work provides\nactionable insights for improving the usability of VA languages and making\nverification tools more accessible.", "AI": {"tldr": "\u7814\u7a76\u63a2\u8ba8\u4e86\u9a8c\u8bc1\u611f\u77e5\uff08VA\uff09\u8bed\u8a00\u91c7\u7528\u7387\u4f4e\u7684\u539f\u56e0\uff0c\u901a\u8fc7\u5206\u6790\u5f00\u53d1\u8005\u8ba8\u8bba\u548c\u8c03\u67e5\uff0c\u53d1\u73b0\u5b66\u4e60\u66f2\u7ebf\u9661\u5ced\u548c\u53ef\u7528\u6027\u95ee\u9898\uff0c\u5e76\u63d0\u51fa\u6539\u8fdb\u5efa\u8bae\u3002", "motivation": "\u5c3d\u7ba1\u9a8c\u8bc1\u611f\u77e5\uff08VA\uff09\u8bed\u8a00\u63d0\u4f9b\u66f4\u5f3a\u7684\u6b63\u786e\u6027\u4fdd\u8bc1\uff0c\u4f46\u5176\u91c7\u7528\u7387\u4ecd\u7136\u6709\u9650\uff0c\u7814\u7a76\u65e8\u5728\u63a2\u7d22\u963b\u788d\u5176\u91c7\u7528\u7684\u539f\u56e0\u3002", "method": "\u901a\u8fc7\u4e3b\u9898\u5efa\u6a21\u6280\u672f\u5206\u6790\u5f00\u53d1\u8005\u8bba\u575b\u8ba8\u8bba\uff0c\u5e76\u8f85\u4ee5\u5f00\u53d1\u8005\u8c03\u67e5\uff0c\u4e86\u89e3VA\u8bed\u8a00\u7684\u5b9e\u9645\u6311\u6218\u3002", "result": "\u7814\u7a76\u53d1\u73b0\u4e3b\u8981\u969c\u788d\u5305\u62ec\u5b66\u4e60\u66f2\u7ebf\u9661\u5ced\u548c\u53ef\u7528\u6027\u95ee\u9898\uff0c\u5efa\u8bae\u7b80\u5316\u5de5\u5177\u754c\u9762\u3001\u63d0\u4f9b\u66f4\u597d\u7684\u6559\u80b2\u6750\u6599\u548c\u6539\u8fdb\u5f00\u53d1\u73af\u5883\u96c6\u6210\u3002", "conclusion": "\u7814\u7a76\u4e3a\u63d0\u5347VA\u8bed\u8a00\u53ef\u7528\u6027\u548c\u9a8c\u8bc1\u5de5\u5177\u7684\u53ef\u8bbf\u95ee\u6027\u63d0\u4f9b\u4e86\u53ef\u884c\u7684\u5efa\u8bae\u3002"}}
