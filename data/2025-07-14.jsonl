{"id": "2507.08759", "pdf": "https://arxiv.org/pdf/2507.08759", "abs": "https://arxiv.org/abs/2507.08759", "authors": ["Maximilian Doré"], "title": "Dependent Multiplicities in Dependent Linear Type Theory", "categories": ["cs.PL", "cs.LO"], "comment": null, "summary": "We present a novel dependent linear type theory in which the multiplicity of\nsome variable - i.e., the number of times the variable can be used in a program\n- can depend on other variables. This allows us to give precise resource\nannotations to many higher-order functions that cannot be adequately typed in\nany other system. Inspired by the Dialectica translation, our typing discipline\nis obtained by embedding linear logic into dependent type theory and specifying\nhow the embedded logic interacts with the host theory. We can then use a\nstandard natural numbers type to obtain a quantitative typing system with\ndependent multiplicities. We characterise the semantics for our theory as a\ncombination of standard models of dependent type theory and linear logic. Our\nsystem can be added to any dependently typed language, which we demonstrate\nwith an implementation in Agda."}
{"id": "2507.08796", "pdf": "https://arxiv.org/pdf/2507.08796", "abs": "https://arxiv.org/abs/2507.08796", "authors": ["Owen Lewis", "Neil Ghani", "Andrew Dudzik", "Christos Perivolaropoulos", "Razvan Pascanu", "Petar Veličković"], "title": "Filter Equivariant Functions: A symmetric account of length-general extrapolation on lists", "categories": ["cs.PL", "cs.LG"], "comment": "18 pages, 2 figures", "summary": "What should a function that extrapolates beyond known input/output examples\nlook like? This is a tricky question to answer in general, as any function\nmatching the outputs on those examples can in principle be a correct\nextrapolant. We argue that a \"good\" extrapolant should follow certain kinds of\nrules, and here we study a particularly appealing criterion for rule-following\nin list functions: that the function should behave predictably even when\ncertain elements are removed. In functional programming, a standard way to\nexpress such removal operations is by using a filter function. Accordingly, our\npaper introduces a new semantic class of functions -- the filter equivariant\nfunctions. We show that this class contains interesting examples, prove some\nbasic theorems about it, and relate it to the well-known class of map\nequivariant functions. We also present a geometric account of filter\nequivariants, showing how they correspond naturally to certain simplicial\nstructures. Our highlight result is the amalgamation algorithm, which\nconstructs any filter-equivariant function's output by first studying how it\nbehaves on sublists of the input, in a way that extrapolates perfectly."}
{"id": "2507.08581", "pdf": "https://arxiv.org/pdf/2507.08581", "abs": "https://arxiv.org/abs/2507.08581", "authors": ["Samuel Teuber", "Mattias Ulbrich", "André Platzer", "Bernhard Beckert"], "title": "Heterogeneous Dynamic Logic: Provability Modulo Program Theories", "categories": ["cs.LO", "cs.PL"], "comment": "49 pages, 4 figures", "summary": "Formally specifying, let alone verifying, properties of systems involving\nmultiple programming languages is inherently challenging. We introduce\nHeterogeneous Dynamic Logic (HDL), a framework for combining reasoning\nprinciples from distinct (dynamic) program logics in a modular and\ncompositional way. HDL mirrors the architecture of satisfiability modulo\ntheories (SMT): Individual dynamic logics, along with their calculi, are\ntreated as dynamic theories that can be flexibly combined to reason about\nheterogeneous systems whose components are verified using different program\nlogics. HDL provides two key operations: Lifting extends an individual dynamic\ntheory with new program constructs (e.g., the havoc operation or regular\nprograms) and automatically augments its calculus with sound reasoning\nprinciples for the new constructs; and Combination enables cross-language\nreasoning in a single modality via Heterogeneous Dynamic Theories, facilitating\nthe reuse of existing proof infrastructure. We formalize dynamic theories,\ntheir lifting and combination in Isabelle, and prove the soundness of all proof\nrules. We also prove relative completeness theorems for lifting and\ncombination: Under common assumptions, reasoning about lifted or combined\ntheories is no harder than reasoning about the constituent dynamic theories and\ntheir common first-order structure (i.e., the \"data theory\"). We demonstrate\nHDL's utility by verifying an automotive case study in which a Java controller\n(formalized in Java dynamic logic) steers a plant model (formalized in\ndifferential dynamic logic)."}
