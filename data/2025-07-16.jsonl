{"id": "2507.10799", "pdf": "https://arxiv.org/pdf/2507.10799", "abs": "https://arxiv.org/abs/2507.10799", "authors": ["Tyler Hou", "Michael Arntzenius", "Max Willsey"], "title": "Stream programs are monoid homomorphisms with state", "categories": ["cs.PL", "cs.DC"], "comment": null, "summary": "We define a broad class of deterministic stream functions and show they can\nbe implemented as homomorphisms into a \"state\" monoid. The homomorphism laws\nare simpler than the conditions of previous semantic frameworks for stream\nprogram optimization, yet retain support for rich equational reasoning over\nexpressive dataflow programs, including sequential composition, parallel\ncomposition, and feedback. We demonstrate this using examples of partitioned\ndatabase joins, stratified negation, and a simplified model of TCP."}
{"id": "2507.11282", "pdf": "https://arxiv.org/pdf/2507.11282", "abs": "https://arxiv.org/abs/2507.11282", "authors": ["René Rydhof Hansen", "Andreas Stenbæk Larsen", "Aslan Askarov"], "title": "The downgrading semantics of memory safety", "categories": ["cs.PL"], "comment": "56 pages, 27 figures", "summary": "Memory safety is traditionally characterized in terms of bad things that\ncannot happen, an approach that is often criticized as unprincipled. Prior work\nsuggest a connection between memory safety and noninterference, but no\nsatisfactory semantic notion of memory safety is currently known.\n  This work proposes a notion of gradual allocator independence that accurately\ncaptures many allocator-specific aspects of memory safety. We consider a\nlow-level language with access to an allocator that provides malloc and free\nprimitives in a flat memory model. Pointers are just integers, and as such it\nis trivial to write memory-unsafe programs. The basic intuition of gradual\nallocator independence is that of noninterference, namely that allocators must\nnot influence program execution. This intuition is refined in two important\nways to account for the allocators running out-of-memory and for programs to\nhave pointer-to-integer casts. The key insight of the definition is to treat\nthese extensions as forms of downgrading and give them satisfactory technical\ntreatment using the state-of-the-art information flow machinery."}
{"id": "2507.10635", "pdf": "https://arxiv.org/pdf/2507.10635", "abs": "https://arxiv.org/abs/2507.10635", "authors": ["Nicola Assolini", "Luca Marzari", "Isabella Mastroeni", "Alessandra di Pierro"], "title": "Formal Verification of Variational Quantum Circuits", "categories": ["quant-ph", "cs.LG", "cs.PL"], "comment": "Assolini and Marzari contributed equally to the paper", "summary": "Variational quantum circuits (VQCs) are a central component of many quantum\nmachine learning algorithms, offering a hybrid quantum-classical framework\nthat, under certain aspects, can be considered similar to classical deep neural\nnetworks. A shared aspect is, for instance, their vulnerability to adversarial\ninputs, small perturbations that can lead to incorrect predictions. While\nformal verification techniques have been extensively developed for classical\nmodels, no comparable framework exists for certifying the robustness of VQCs.\nHere, we present the first in-depth theoretical and practical study of the\nformal verification problem for VQCs. Inspired by abstract interpretation\nmethods used in deep learning, we analyze the applicability and limitations of\ninterval-based reachability techniques in the quantum setting. We show that\nquantum-specific aspects, such as state normalization, introduce inter-variable\ndependencies that challenge existing approaches. We investigate these issues by\nintroducing a novel semantic framework based on abstract interpretation, where\nthe verification problem for VQCs can be formally defined, and its complexity\nanalyzed. Finally, we demonstrate our approach on standard verification\nbenchmarks."}
