{"id": "2507.11676", "pdf": "https://arxiv.org/pdf/2507.11676", "abs": "https://arxiv.org/abs/2507.11676", "authors": ["Chris Heunen", "Louis Lemonnier", "Christopher McNally", "Alex Rice"], "title": "Quantum circuits are just a phase", "categories": ["cs.PL", "cs.LO", "quant-ph"], "comment": "43 pages, 5 figures", "summary": "Quantum programs today are written at a low level of abstraction - quantum\ncircuits akin to assembly languages - and even advanced quantum programming\nlanguages essentially function as circuit description languages. This state of\naffairs impedes scalability, clarity, and support for higher-level reasoning.\nMore abstract and expressive quantum programming constructs are needed.\n  To this end, we introduce a novel yet simple quantum programming language for\ngenerating unitaries from \"just a phase\"; we combine a (global) phase operation\nthat captures phase shifts with a quantum analogue of the \"if let\" construct\nthat captures subspace selection via pattern matching. This minimal language\nlifts the focus from quantum gates to eigendecomposition, conjugation, and\ncontrolled unitaries; common building blocks in quantum algorithm design.\n  We demonstrate several aspects of the expressive power of our language in\nseveral ways. Firstly, we establish that our representation is universal by\nderiving a universal quantum gate set. Secondly, we show that important quantum\nalgorithms can be expressed naturally and concisely, including Grover's search\nalgorithm, Hamiltonian simulation, Quantum Fourier Transform, Quantum Signal\nProcessing, and the Quantum Eigenvalue Transformation. Furthermore, we give\nclean denotational semantics grounded in categorical quantum mechanics.\nFinally, we implement a prototype compiler that efficiently translates terms of\nour language to quantum circuits, and prove that it is sound with respect to\nthese semantics. Collectively, these contributions show that this construct\noffers a principled and practical step toward more abstract and structured\nquantum programming."}
{"id": "2507.11731", "pdf": "https://arxiv.org/pdf/2507.11731", "abs": "https://arxiv.org/abs/2507.11731", "authors": ["Neng-Fa Zhou", "Cristian Grozea", "Håkan Kjellerstrand", "Oisín Mac Fhearaí"], "title": "Picat Through the Lens of Advent of Code", "categories": ["cs.PL", "68N15", "D.3.2"], "comment": "14 pages", "summary": "Picat is a logic-based, multi-paradigm programming language that integrates\nfeatures from logic, functional, constraint, and imperative programming\nparadigms. This paper presents solutions to several problems from the 2024\nAdvent of Code (AoC). While AoC problems are not designed for any specific\nprogramming language, certain problem types, such as reverse engineering and\npath-finding, are particularly well-suited to Picat due to its built-in\nconstraint solving, pattern matching, backtracking, and dynamic programming\nwith tabling. This paper demonstrates that Picat's features, especially its\nSAT-based constraint solving and tabling, enable concise, declarative, and\nhighly efficient implementations of problems that would require significantly\nmore effort in imperative languages."}
{"id": "2507.11827", "pdf": "https://arxiv.org/pdf/2507.11827", "abs": "https://arxiv.org/abs/2507.11827", "authors": ["Shaurya Gomber", "Debangshu Banerjee", "Gagandeep Singh"], "title": "Universal Synthesis of Differentiably Tunable Numerical Abstract Transformers", "categories": ["cs.PL"], "comment": "42 pages, 8 figures", "summary": "Numerical abstract interpretation is a widely used framework for the static\nanalysis of numerical programs. However, existing numerical abstract\ninterpreters rely on hand-crafted, instruction-specific transformers tailored\nto each domain, with no general algorithm for handling common operations across\ndomains. This limits extensibility, prevents precise compositional reasoning\nover instruction sequences, and forces all downstream tasks to use the same\nfixed transformer regardless of their precision, efficiency, or task-specific\nrequirements. To address these limitations, we propose a universal transformer\nsynthesis algorithm that constructs a parametric family of sound abstract\ntransformers for any given polyhedral numerical domain and a concrete operator\nfrom the class of Quadratic-Bounded Guarded Operators (QGO), which includes\nboth individual instructions and structured sequences. Each instantiation in\nthis family is sound by construction, enabling downstream analyses to adapt the\ntransformer to their particular needs. The space of transformers is\ndifferentiable but complex. To efficiently explore this space of transformers,\nwe introduce the Adaptive Gradient Guidance (AGG) procedure, a gradient-guided\nsearch strategy that steers the search process based on downstream analysis\nobjectives and runtime constraints. We implement these ideas in the USTAD\nframework and evaluate their effectiveness across three numerical abstract\ndomains: Zones, Octagons, and Polyhedra. Our results demonstrate that the\nuniversal synthesis algorithm successfully constructs sound families of\ntransformers across domains, and that USTAD achieves significant, tunable\nprecision gains over baselines by leveraging compositional reasoning and\nefficient gradient-guided traversal of the transformer space."}
{"id": "2507.11897", "pdf": "https://arxiv.org/pdf/2507.11897", "abs": "https://arxiv.org/abs/2507.11897", "authors": ["Tyler Hou", "Shadaj Laddad", "Joseph M. Hellerstein"], "title": "Towards Relational Contextual Equality Saturation", "categories": ["cs.PL", "cs.DB"], "comment": "Appeared at EGRAPHS 2024", "summary": "Equality saturation is a powerful technique for program optimization.\nContextual equality saturation extends this to support rewrite rules that are\nconditioned on where a term appears in an expression. Existing work has brought\ncontextual reasoning to egg; in this paper, we share our ongoing work to extend\nthis to relational equality saturation in egglog. We summarize the existing\napproaches to contextual equality saturation, outline its main applications,\nand identify key challenges in combining this approach with relational models."}
{"id": "2507.11873", "pdf": "https://arxiv.org/pdf/2507.11873", "abs": "https://arxiv.org/abs/2507.11873", "authors": ["Breandan Considine"], "title": "Syntax Repair as Language Intersection", "categories": ["cs.FL", "cs.PL"], "comment": null, "summary": "We introduce a new technique for repairing syntax errors in arbitrary\ncontext-free languages. This technique models syntax repair as a language\nintersection problem by defining a finite language that provably generates\nevery syntactically valid repair within a given edit distance. Leveraging a\ntheoretical connection between the Bar-Hillel construction from formal language\ntheory and CFL reachability from program analysis, we show that repairability\nin a finite number of typographic edits is polylogarithmic parallel time\ndecidable and provide an enumeration algorithm based on the Brzozowski\nderivative. Finally, we evaluate this algorithm and its implementation,\ndemonstrating state-of-the-art results on a Python syntax repair benchmark."}
{"id": "2507.12367", "pdf": "https://arxiv.org/pdf/2507.12367", "abs": "https://arxiv.org/abs/2507.12367", "authors": ["Diganta Misra", "Nizar Islah", "Victor May", "Brice Rauby", "Zihan Wang", "Justine Gehring", "Antonio Orvieto", "Muawiz Chaudhary", "Eilif B. Muller", "Irina Rish", "Samira Ebrahimi Kahou", "Massimo Caccia"], "title": "GitChameleon: Evaluating AI Code Generation Against Python Library Version Incompatibilities", "categories": ["cs.SE", "cs.AI", "cs.PL"], "comment": "Version 2 of the dataset from: arXiv:2411.05830", "summary": "The rapid evolution of software libraries poses a considerable hurdle for\ncode generation, necessitating continuous adaptation to frequent version\nupdates while preserving backward compatibility. While existing code evolution\nbenchmarks provide valuable insights, they typically lack execution-based\nevaluation for generating code compliant with specific library versions. To\naddress this, we introduce GitChameleon, a novel, meticulously curated dataset\ncomprising 328 Python code completion problems, each conditioned on specific\nlibrary versions and accompanied by executable unit tests. GitChameleon\nrigorously evaluates the capacity of contemporary large language models (LLMs),\nLLM-powered agents, code assistants, and RAG systems to perform\nversion-conditioned code generation that demonstrates functional accuracy\nthrough execution. Our extensive evaluations indicate that state-of-the-art\nsystems encounter significant challenges with this task; enterprise models\nachieving baseline success rates in the 48-51\\% range, underscoring the\nintricacy of the problem. By offering an execution-based benchmark emphasizing\nthe dynamic nature of code libraries, GitChameleon enables a clearer\nunderstanding of this challenge and helps guide the development of more\nadaptable and dependable AI code generation methods. We make the dataset and\nevaluation code publicly available at\nhttps://github.com/mrcabbage972/GitChameleonBenchmark."}
{"id": "2507.12443", "pdf": "https://arxiv.org/pdf/2507.12443", "abs": "https://arxiv.org/abs/2507.12443", "authors": ["Rajdeep Mondal", "Nikolaj Bjorner", "Todd Millstein", "Alan Tang", "George Varghese"], "title": "LLM-Based Config Synthesis requires Disambiguation", "categories": ["cs.NI", "cs.AI", "cs.HC", "cs.PL"], "comment": null, "summary": "Beyond hallucinations, another problem in program synthesis using LLMs is\nambiguity in user intent. We illustrate the ambiguity problem in a networking\ncontext for LLM-based incremental configuration synthesis of route-maps and\nACLs. These structures frequently overlap in header space, making the relative\npriority of actions impossible for the LLM to infer without user interaction.\nMeasurements in a large cloud identify complex ACLs with 100's of overlaps,\nshowing ambiguity is a real problem. We propose a prototype system, Clarify,\nwhich uses an LLM augmented with a new module called a Disambiguator that helps\nelicit user intent. On a small synthetic workload, Clarify incrementally\nsynthesizes routing policies after disambiguation and then verifies them. Our\ntreatment of ambiguities is useful more generally when the intent of updates\ncan be correctly synthesized by LLMs, but their integration is ambiguous and\ncan lead to different global behaviors."}
