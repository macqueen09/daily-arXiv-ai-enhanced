{"id": "2507.16051", "pdf": "https://arxiv.org/pdf/2507.16051", "abs": "https://arxiv.org/abs/2507.16051", "authors": ["Juan Altmayer Pizzorno", "Emery D. Berger"], "title": "RightTyper: Effective and Efficient Type Annotation for Python", "categories": ["cs.PL", "cs.SE"], "comment": null, "summary": "Python type annotations bring the benefits of static type checking to the\nlanguage. However, manually writing annotations can be time-consuming and\ntedious. The result is that most real-world Python code remains largely\nuntyped. Past approaches to annotating types in Python code fall short in a\nnumber of ways. Static approaches struggle with dynamic features and infer\noverly broad types. AI-based methods are inherently unsound and can miss rare\nor user-defined types. Dynamic methods can impose extreme runtime overheads,\ndegrading performance by up to 270x, abort execution as they exhaust resources,\nand even infer incorrect types that lead to runtime errors. Crucially, all\nprior work assumes implicitly that the code to be annotated is already correct.\nThis assumption is generally unwarranted, especially for large codebases that\nhave been untyped.\n  This paper presents RightTyper, a novel approach for Python that overcomes\nthese disadvantages. RightTyper not only generates precise type annotations\nbased on actual program behavior, improving recall in type checking relative to\nprior approaches. It also turns type checking into anomaly detection, allowing\nthe type checker to identify corner cases that the programmer can audit for\nunintended behavior. RightTyper is also fast and space-efficient, imposing just\n30% performance overhead on average. RightTyper achieves these characteristics\nby a principled yet pervasive use of sampling--guided by self-profiling--along\nwith statistical filtering and careful resolution and aggregation of type\ninformation.", "AI": {"tldr": "RightTyper\u662f\u4e00\u79cd\u65b0\u7684Python\u7c7b\u578b\u6ce8\u91ca\u751f\u6210\u65b9\u6cd5\uff0c\u901a\u8fc7\u91c7\u6837\u548c\u7edf\u8ba1\u8fc7\u6ee4\u6280\u672f\uff0c\u80fd\u591f\u57fa\u4e8e\u5b9e\u9645\u7a0b\u5e8f\u884c\u4e3a\u751f\u6210\u7cbe\u786e\u7684\u7c7b\u578b\u6ce8\u91ca\uff0c\u540c\u65f6\u5c06\u7c7b\u578b\u68c0\u67e5\u8f6c\u5316\u4e3a\u5f02\u5e38\u68c0\u6d4b\uff0c\u6027\u80fd\u5f00\u9500\u4ec5\u4e3a30%\u3002", "motivation": "\u73b0\u6709\u7684Python\u7c7b\u578b\u6ce8\u91ca\u65b9\u6cd5\u5b58\u5728\u8bf8\u591a\u95ee\u9898\uff1a\u9759\u6001\u65b9\u6cd5\u96be\u4ee5\u5904\u7406\u52a8\u6001\u7279\u6027\u4e14\u63a8\u65ad\u51fa\u8fc7\u4e8e\u5bbd\u6cdb\u7684\u7c7b\u578b\uff1bAI\u65b9\u6cd5\u672c\u8d28\u4e0a\u4e0d\u53ef\u9760\u4e14\u53ef\u80fd\u9057\u6f0f\u7f55\u89c1\u6216\u7528\u6237\u5b9a\u4e49\u7684\u7c7b\u578b\uff1b\u52a8\u6001\u65b9\u6cd5\u4f1a\u5e26\u6765\u6781\u9ad8\u7684\u8fd0\u884c\u65f6\u5f00\u9500\uff08\u9ad8\u8fbe270\u500d\uff09\uff0c\u751a\u81f3\u53ef\u80fd\u63a8\u65ad\u51fa\u9519\u8bef\u7684\u7c7b\u578b\u5bfc\u81f4\u8fd0\u884c\u65f6\u9519\u8bef\u3002\u6b64\u5916\uff0c\u6240\u6709\u5148\u524d\u5de5\u4f5c\u90fd\u9690\u542b\u5047\u8bbe\u5f85\u6ce8\u91ca\u7684\u4ee3\u7801\u5df2\u7ecf\u662f\u6b63\u786e\u7684\uff0c\u8fd9\u5728\u5927\u578b\u672a\u7c7b\u578b\u5316\u4ee3\u7801\u5e93\u4e2d\u901a\u5e38\u662f\u4e0d\u6210\u7acb\u7684\u3002", "method": "RightTyper\u91c7\u7528\u57fa\u4e8e\u91c7\u6837\u7684\u65b9\u6cd5\uff0c\u901a\u8fc7\u81ea\u6211\u6027\u80fd\u5206\u6790\u6307\u5bfc\u91c7\u6837\u8fc7\u7a0b\uff0c\u7ed3\u5408\u7edf\u8ba1\u8fc7\u6ee4\u4ee5\u53ca\u7c7b\u578b\u4fe1\u606f\u7684\u4ed4\u7ec6\u89e3\u6790\u548c\u805a\u5408\u3002\u8be5\u65b9\u6cd5\u57fa\u4e8e\u5b9e\u9645\u7a0b\u5e8f\u884c\u4e3a\u751f\u6210\u7c7b\u578b\u6ce8\u91ca\uff0c\u5e76\u5c06\u7c7b\u578b\u68c0\u67e5\u8f6c\u5316\u4e3a\u5f02\u5e38\u68c0\u6d4b\u673a\u5236\u3002", "result": "RightTyper\u76f8\u6bd4\u4e8e\u5148\u524d\u65b9\u6cd5\u63d0\u9ad8\u4e86\u7c7b\u578b\u68c0\u67e5\u7684\u53ec\u56de\u7387\uff0c\u80fd\u591f\u751f\u6210\u66f4\u7cbe\u786e\u7684\u7c7b\u578b\u6ce8\u91ca\u3002\u540c\u65f6\uff0c\u5b83\u5177\u6709\u5feb\u901f\u548c\u7a7a\u95f4\u9ad8\u6548\u7684\u7279\u70b9\uff0c\u5e73\u5747\u6027\u80fd\u5f00\u9500\u4ec5\u4e3a30%\u3002\u6b64\u5916\uff0c\u5b83\u8fd8\u80fd\u591f\u8bc6\u522b\u7a0b\u5e8f\u5458\u53ef\u4ee5\u5ba1\u67e5\u7684\u8fb9\u754c\u60c5\u51b5\uff0c\u7528\u4e8e\u68c0\u6d4b\u610f\u5916\u884c\u4e3a\u3002", "conclusion": "RightTyper\u901a\u8fc7\u539f\u5219\u6027\u4e14\u666e\u904d\u7684\u91c7\u6837\u4f7f\u7528\uff0c\u7ed3\u5408\u7edf\u8ba1\u8fc7\u6ee4\u548c\u7c7b\u578b\u4fe1\u606f\u7684\u7cbe\u5fc3\u5904\u7406\uff0c\u6210\u529f\u514b\u670d\u4e86\u73b0\u6709Python\u7c7b\u578b\u6ce8\u91ca\u65b9\u6cd5\u7684\u7f3a\u70b9\uff0c\u5b9e\u73b0\u4e86\u57fa\u4e8e\u5b9e\u9645\u7a0b\u5e8f\u884c\u4e3a\u7684\u7cbe\u786e\u7c7b\u578b\u6ce8\u91ca\u751f\u6210\uff0c\u5e76\u5c06\u7c7b\u578b\u68c0\u67e5\u8f6c\u5316\u4e3a\u6709\u6548\u7684\u5f02\u5e38\u68c0\u6d4b\u5de5\u5177\u3002"}}
{"id": "2507.16086", "pdf": "https://arxiv.org/pdf/2507.16086", "abs": "https://arxiv.org/abs/2507.16086", "authors": ["Andrew Marmaduke", "Apoorv Ingle", "J. Garrett Morris"], "title": "Understanding Haskell-style Overloading via Open Data and Open Functions", "categories": ["cs.PL"], "comment": null, "summary": "We present a new, uniform semantics for Haskell-style overloading. We realize\nour approach in a new core language, System F$_\\mathrm{D}$, whose metatheory we\nmechanize in the Lean4 interactive theorem prover. System F$_\\mathrm{D}$ is\ndistinguished by its open data types and open functions, each given by a\ncollection of instances rather than by a single definition. We show that System\nF$_\\mathrm{D}$ can encode advanced features of Haskell's of type class systems,\nmore expressively than current semantics of these features, and without\nassuming additional type equality axioms.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u6838\u5fc3\u8bed\u8a00System F_D\uff0c\u4e3aHaskell\u98ce\u683c\u7684\u91cd\u8f7d\u63d0\u4f9b\u7edf\u4e00\u8bed\u4e49\uff0c\u901a\u8fc7\u5f00\u653e\u6570\u636e\u7c7b\u578b\u548c\u5f00\u653e\u51fd\u6570\u5b9e\u73b0\u7c7b\u578b\u7c7b\u7cfb\u7edf\u7684\u8868\u8fbe\uff0c\u5e76\u5728Lean4\u4e2d\u8fdb\u884c\u4e86\u5f62\u5f0f\u5316\u9a8c\u8bc1\u3002", "motivation": "\u73b0\u6709\u7684Haskell\u7c7b\u578b\u7c7b\u7cfb\u7edf\u8bed\u4e49\u5b58\u5728\u8868\u8fbe\u80fd\u529b\u4e0d\u8db3\u7684\u95ee\u9898\uff0c\u9700\u8981\u989d\u5916\u7684\u7c7b\u578b\u7b49\u5f0f\u516c\u7406\uff0c\u7f3a\u4e4f\u7edf\u4e00\u4e14\u5bcc\u6709\u8868\u8fbe\u529b\u7684\u8bed\u4e49\u6846\u67b6\u6765\u5904\u7406Haskell\u98ce\u683c\u7684\u91cd\u8f7d\u673a\u5236\u3002", "method": "\u8bbe\u8ba1\u4e86\u4e00\u79cd\u65b0\u7684\u6838\u5fc3\u8bed\u8a00System F_D\uff0c\u5f15\u5165\u5f00\u653e\u6570\u636e\u7c7b\u578b\u548c\u5f00\u653e\u51fd\u6570\u7684\u6982\u5ff5\uff0c\u8fd9\u4e9b\u6784\u9020\u7531\u5b9e\u4f8b\u96c6\u5408\u800c\u975e\u5355\u4e00\u5b9a\u4e49\u7ed9\u51fa\uff0c\u5e76\u5728Lean4\u4ea4\u4e92\u5f0f\u5b9a\u7406\u8bc1\u660e\u5668\u4e2d\u5bf9\u5176\u5143\u7406\u8bba\u8fdb\u884c\u673a\u68b0\u5316\u9a8c\u8bc1\u3002", "result": "System F_D\u80fd\u591f\u7f16\u7801Haskell\u7c7b\u578b\u7c7b\u7cfb\u7edf\u7684\u9ad8\u7ea7\u7279\u6027\uff0c\u76f8\u6bd4\u73b0\u6709\u8bed\u4e49\u5177\u6709\u66f4\u5f3a\u7684\u8868\u8fbe\u80fd\u529b\uff0c\u4e14\u65e0\u9700\u5047\u8bbe\u989d\u5916\u7684\u7c7b\u578b\u7b49\u5f0f\u516c\u7406\uff0c\u6210\u529f\u63d0\u4f9b\u4e86Haskell\u98ce\u683c\u91cd\u8f7d\u7684\u7edf\u4e00\u8bed\u4e49\u3002", "conclusion": "System F_D\u4e3aHaskell\u98ce\u683c\u7684\u91cd\u8f7d\u63d0\u4f9b\u4e86\u4e00\u4e2a\u65b0\u7684\u3001\u7edf\u4e00\u7684\u8bed\u4e49\u6846\u67b6\uff0c\u901a\u8fc7\u5f00\u653e\u6570\u636e\u7c7b\u578b\u548c\u5f00\u653e\u51fd\u6570\u7684\u8bbe\u8ba1\uff0c\u5b9e\u73b0\u4e86\u5bf9\u7c7b\u578b\u7c7b\u7cfb\u7edf\u66f4\u597d\u7684\u8bed\u4e49\u8868\u8fbe\uff0c\u5e76\u901a\u8fc7\u5f62\u5f0f\u5316\u9a8c\u8bc1\u786e\u4fdd\u4e86\u7406\u8bba\u7684\u6b63\u786e\u6027\u3002"}}
{"id": "2507.16089", "pdf": "https://arxiv.org/pdf/2507.16089", "abs": "https://arxiv.org/abs/2507.16089", "authors": ["Michael J. Sullivan", "Zhibo Chen", "Elvis Pranskevichus", "Robert J. Simmons", "Victor Petrovykh", "Alja\u017e Mur Er\u017een", "Yury Selivanov"], "title": "Querying Graph-Relational Data", "categories": ["cs.PL", "cs.DB"], "comment": null, "summary": "For applications that store structured data in relational databases, there is\nan impedance mismatch between the flat representations encouraged by relational\ndata models and the deeply nested information that applications expect to\nreceive. In this work, we present the graph-relational database model, which\nprovides a flexible, compositional, and strongly-typed solution to this\n\"object-relational mismatch.\" We formally define the graph-relational database\nmodel and present a static and dynamic semantics for queries. In addition, we\ndiscuss the realization of the graph-relational database model in EdgeQL, a\ngeneral-purpose SQL-style query language, and the Gel system, which compiles\nEdgeQL schemas and queries into PostgreSQL queries. Gel facilitates the kind of\nobject-shaped data manipulation that is frequently provided inefficiently by\nobject-relational mapping (ORM) technologies, while achieving most of the\nefficiency that comes from require writing complex PostgreSQL queries directly.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u56fe\u5173\u7cfb\u6570\u636e\u5e93\u6a21\u578b\uff0c\u901a\u8fc7EdgeQL\u67e5\u8be2\u8bed\u8a00\u548cGel\u7cfb\u7edf\u89e3\u51b3\u5bf9\u8c61\u5173\u7cfb\u6620\u5c04\u4e2d\u7684\u963b\u6297\u4e0d\u5339\u914d\u95ee\u9898\uff0c\u5728\u4fdd\u6301\u6548\u7387\u7684\u540c\u65f6\u63d0\u4f9b\u7075\u6d3b\u7684\u5bf9\u8c61\u5f62\u72b6\u6570\u636e\u64cd\u4f5c\u3002", "motivation": "\u5173\u7cfb\u6570\u636e\u5e93\u7684\u6241\u5e73\u5316\u8868\u793a\u4e0e\u5e94\u7528\u7a0b\u5e8f\u671f\u671b\u7684\u6df1\u5ea6\u5d4c\u5957\u4fe1\u606f\u4e4b\u95f4\u5b58\u5728\u963b\u6297\u4e0d\u5339\u914d\u95ee\u9898\uff0c\u4f20\u7edf\u7684\u5bf9\u8c61\u5173\u7cfb\u6620\u5c04(ORM)\u6280\u672f\u5728\u5904\u7406\u5bf9\u8c61\u5f62\u72b6\u6570\u636e\u64cd\u4f5c\u65f6\u6548\u7387\u4f4e\u4e0b\u3002", "method": "\u63d0\u51fa\u56fe\u5173\u7cfb\u6570\u636e\u5e93\u6a21\u578b\uff0c\u8bbe\u8ba1EdgeQL\u67e5\u8be2\u8bed\u8a00\uff08\u7c7bSQL\u98ce\u683c\u7684\u901a\u7528\u67e5\u8be2\u8bed\u8a00\uff09\uff0c\u5f00\u53d1Gel\u7cfb\u7edf\u5c06EdgeQL\u6a21\u5f0f\u548c\u67e5\u8be2\u7f16\u8bd1\u4e3aPostgreSQL\u67e5\u8be2\uff0c\u5e76\u4e3a\u67e5\u8be2\u63d0\u4f9b\u9759\u6001\u548c\u52a8\u6001\u8bed\u4e49\u5b9a\u4e49\u3002", "result": "Gel\u7cfb\u7edf\u80fd\u591f\u9ad8\u6548\u5730\u5904\u7406\u5bf9\u8c61\u5f62\u72b6\u7684\u6570\u636e\u64cd\u4f5c\uff0c\u540c\u65f6\u83b7\u5f97\u63a5\u8fd1\u76f4\u63a5\u7f16\u5199\u590d\u6742PostgreSQL\u67e5\u8be2\u7684\u6548\u7387\uff0c\u76f8\u6bd4\u4f20\u7edfORM\u6280\u672f\u6709\u663e\u8457\u6027\u80fd\u63d0\u5347\u3002", "conclusion": "\u56fe\u5173\u7cfb\u6570\u636e\u5e93\u6a21\u578b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7075\u6d3b\u3001\u7ec4\u5408\u6027\u5f3a\u4e14\u5f3a\u7c7b\u578b\u7684\u89e3\u51b3\u65b9\u6848\u6765\u89e3\u51b3\"\u5bf9\u8c61\u5173\u7cfb\u4e0d\u5339\u914d\"\u95ee\u9898\uff0c\u901a\u8fc7EdgeQL\u548cGel\u7cfb\u7edf\u7684\u5b9e\u73b0\uff0c\u5728\u4fdd\u6301\u9ad8\u6548\u7387\u7684\u540c\u65f6\u7b80\u5316\u4e86\u5bf9\u8c61\u5f62\u72b6\u6570\u636e\u7684\u64cd\u4f5c\u3002"}}
{"id": "2507.16660", "pdf": "https://arxiv.org/pdf/2507.16660", "abs": "https://arxiv.org/abs/2507.16660", "authors": ["Xuran Cai"], "title": "Enhancing Compiler Optimization Efficiency through Grammatical Decompositions of Control-Flow Graphs", "categories": ["cs.PL"], "comment": null, "summary": "This thesis addresses the complexities of compiler optimizations, such as\nregister allocation and Lifetime-optimal Speculative Partial Redundancy\nElimination (LOSPRE), which are often handled using tree decomposition\nalgorithms. However, these methods frequently overlook important sparsity\naspects of Control Flow Graphs (CFGs) and result in high computational costs.\nWe introduce the SPL (Series-Parallel-Loop) decomposition, a novel framework\nthat offers optimal solutions to these challenges. A key contribution is the\nformulation of a general solution for Partial Constraint Satisfaction Problems\n(PCSPs) within graph structures, applied to three optimization problems. First,\nSPL decomposition enhances register allocation by accurately modeling variable\ninterference graphs, leading to efficient register assignments and improved\nperformance across benchmarks. Second, it optimizes LOSPRE by effectively\nidentifying and eliminating redundancies in program execution. Finally, the\nthesis focuses on optimizing the placement of bank selection instructions to\nenhance data retrieval efficiency and reduce latency. Extensive experimentation\ndemonstrates significant performance improvements over existing methods,\nestablishing SPL decomposition as a powerful tool for complex compiler\noptimizations, including register allocation, LOSPRE, and bank selection.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86SPL\uff08\u4e32\u5e76\u73af\uff09\u5206\u89e3\u6846\u67b6\uff0c\u7528\u4e8e\u89e3\u51b3\u7f16\u8bd1\u5668\u4f18\u5316\u4e2d\u7684\u5bc4\u5b58\u5668\u5206\u914d\u3001LOSPRE\u548c\u94f6\u884c\u9009\u62e9\u7b49\u95ee\u9898\uff0c\u76f8\u6bd4\u4f20\u7edf\u6811\u5206\u89e3\u65b9\u6cd5\u5728\u6027\u80fd\u4e0a\u6709\u663e\u8457\u63d0\u5347\u3002", "motivation": "\u4f20\u7edf\u7684\u7f16\u8bd1\u5668\u4f18\u5316\u65b9\u6cd5\uff08\u5982\u5bc4\u5b58\u5668\u5206\u914d\u548cLOSPRE\uff09\u4f7f\u7528\u6811\u5206\u89e3\u7b97\u6cd5\u65f6\u7ecf\u5e38\u5ffd\u7565\u63a7\u5236\u6d41\u56fe\u7684\u91cd\u8981\u7a00\u758f\u6027\u7279\u5f81\uff0c\u5bfc\u81f4\u8ba1\u7b97\u6210\u672c\u8fc7\u9ad8\uff0c\u9700\u8981\u4e00\u79cd\u66f4\u6709\u6548\u7684\u4f18\u5316\u6846\u67b6\u3002", "method": "\u63d0\u51faSPL\uff08\u4e32\u5e76\u73af\uff09\u5206\u89e3\u6846\u67b6\uff0c\u5e76\u4e3a\u56fe\u7ed3\u6784\u4e2d\u7684\u90e8\u5206\u7ea6\u675f\u6ee1\u8db3\u95ee\u9898\uff08PCSPs\uff09\u5236\u5b9a\u901a\u7528\u89e3\u51b3\u65b9\u6848\uff0c\u5c06\u5176\u5e94\u7528\u4e8e\u4e09\u4e2a\u4f18\u5316\u95ee\u9898\uff1a\u5bc4\u5b58\u5668\u5206\u914d\u3001LOSPRE\u4f18\u5316\u548c\u94f6\u884c\u9009\u62e9\u6307\u4ee4\u4f4d\u7f6e\u4f18\u5316\u3002", "result": "SPL\u5206\u89e3\u5728\u5bc4\u5b58\u5668\u5206\u914d\u4e2d\u51c6\u786e\u5efa\u6a21\u53d8\u91cf\u5e72\u6270\u56fe\uff0c\u5b9e\u73b0\u9ad8\u6548\u5bc4\u5b58\u5668\u5206\u914d\uff1b\u5728LOSPRE\u4e2d\u6709\u6548\u8bc6\u522b\u548c\u6d88\u9664\u7a0b\u5e8f\u6267\u884c\u5197\u4f59\uff1b\u5728\u94f6\u884c\u9009\u62e9\u4f18\u5316\u4e2d\u63d0\u9ad8\u6570\u636e\u68c0\u7d22\u6548\u7387\u5e76\u51cf\u5c11\u5ef6\u8fdf\u3002\u5b9e\u9a8c\u8bc1\u660e\u76f8\u6bd4\u73b0\u6709\u65b9\u6cd5\u6709\u663e\u8457\u6027\u80fd\u63d0\u5347\u3002", "conclusion": "SPL\u5206\u89e3\u88ab\u8bc1\u660e\u662f\u5904\u7406\u590d\u6742\u7f16\u8bd1\u5668\u4f18\u5316\u95ee\u9898\u7684\u5f3a\u5927\u5de5\u5177\uff0c\u5728\u5bc4\u5b58\u5668\u5206\u914d\u3001LOSPRE\u548c\u94f6\u884c\u9009\u62e9\u7b49\u591a\u4e2a\u9886\u57df\u90fd\u5c55\u73b0\u51fa\u4f18\u8d8a\u6027\u80fd\uff0c\u4e3a\u7f16\u8bd1\u5668\u4f18\u5316\u63d0\u4f9b\u4e86\u65b0\u7684\u6709\u6548\u89e3\u51b3\u65b9\u6848\u3002"}}
