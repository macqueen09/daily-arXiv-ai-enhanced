{"id": "2507.17233", "pdf": "https://arxiv.org/pdf/2507.17233", "abs": "https://arxiv.org/abs/2507.17233", "authors": ["Marco Ciccalè", "Daniel Jurjo-Rivas", "Jose F. Morales", "Pedro López-García", "Manuel V. Hermenegildo"], "title": "Hiord: An Approach to the Specification and Verification of Higher-Order (C)LP Programs", "categories": ["cs.PL"], "comment": "Accepted for publication in Theory and Practice of Logic Programming\n  (TPLP)", "summary": "Higher-order constructs enable more expressive and concise code by allowing\nprocedures to be parameterized by other procedures. Assertions allow expressing\npartial program specifications, which can be verified either at compile time\n(statically) or run time (dynamically). In higher-order programs, assertions\ncan also describe higher-order arguments. While in the context of (C)LP,\nrun-time verification of higher-order assertions has received some attention,\ncompile-time verification remains relatively unexplored. We propose a novel\napproach for statically verifying higher-order (C)LP programs with higher-order\nassertions. Although we use the Ciao assertion language for illustration, our\napproach is quite general and we believe is applicable to similar contexts.\nHigher-order arguments are described using predicate properties -- a special\nkind of property which exploits the (Ciao) assertion language. We refine the\nsyntax and semantics of these properties and introduce an abstract criterion to\ndetermine conformance to a predicate property at compile time, based on a\nsemantic order relation comparing the predicate property with the predicate\nassertions. We then show how to handle these properties using an abstract\ninterpretation-based static analyzer for programs with first-order assertions\nby reducing predicate properties to first-order properties. Finally, we report\non a prototype implementation and evaluate it through various examples within\nthe Ciao system."}
{"id": "2507.17087", "pdf": "https://arxiv.org/pdf/2507.17087", "abs": "https://arxiv.org/abs/2507.17087", "authors": ["Anjiang Wei", "Rohan Yadav", "Hang Song", "Wonchan Lee", "Ke Wang", "Alex Aiken"], "title": "Mapple: A Domain-Specific Language for Mapping Distributed Heterogeneous Parallel Programs", "categories": ["cs.DC", "cs.PL"], "comment": null, "summary": "Optimizing parallel programs for distributed heterogeneous systems remains a\ncomplex task, often requiring significant code modifications. Task-based\nprogramming systems improve modularity by separating performance decisions from\ncore application logic, but their mapping interfaces are often too low-level.\nIn this work, we introduce Mapple, a high-level, declarative programming\ninterface for mapping distributed applications. Mapple provides transformation\nprimitives to resolve dimensionality mismatches between iteration and processor\nspaces, including a key primitive, decompose, that helps minimize communication\nvolume. We implement Mapple on top of the Legion runtime by translating Mapple\nmappers into its low-level C++ interface. Across nine applications, including\nsix matrix multiplication algorithms and three scientific computing workloads,\nMapple reduces mapper code size by 14X and enables performance improvements of\nup to 1.34X over expert-written C++ mappers. In addition, the decompose\nprimitive achieves up to 1.83X improvement over existing\ndimensionality-resolution heuristics. These results demonstrate that Mapple\nsimplifies the development of high-performance mappers for distributed\napplications."}
{"id": "2507.17453", "pdf": "https://arxiv.org/pdf/2507.17453", "abs": "https://arxiv.org/abs/2507.17453", "authors": ["Guanqin Zhang", "Kota Fukuda", "Zhenya Zhang", "H. M. N. Dilum Bandara", "Shiping Chen", "Jianjun Zhao", "Yulei Sui"], "title": "Efficient Neural Network Verification via Order Leading Exploration of Branch-and-Bound Trees", "categories": ["cs.LG", "cs.PL", "cs.SE"], "comment": "This is an extended version of the ECOOP 2025 paper, with a\n  comparison with DATE 2025 (Figure 7 of RQ1 in Section 5.2), as well as an\n  in-depth discussion of OOPSLA 2025 in the related work (Section 6)", "summary": "The vulnerability of neural networks to adversarial perturbations has\nnecessitated formal verification techniques that can rigorously certify the\nquality of neural networks. As the state-of-the-art, branch and bound (BaB) is\na \"divide-and-conquer\" strategy that applies off-the-shelf verifiers to\nsub-problems for which they perform better. While BaB can identify the\nsub-problems that are necessary to be split, it explores the space of these\nsub-problems in a naive \"first-come-first-serve\" manner, thereby suffering from\nan issue of inefficiency to reach a verification conclusion. To bridge this\ngap, we introduce an order over different sub-problems produced by BaB,\nconcerning with their different likelihoods of containing counterexamples.\nBased on this order, we propose a novel verification framework Oliva that\nexplores the sub-problem space by prioritizing those sub-problems that are more\nlikely to find counterexamples, in order to efficiently reach the conclusion of\nthe verification. Even if no counterexample can be found in any sub-problem, it\nonly changes the order of visiting different sub-problem and so will not lead\nto a performance degradation. Specifically, Oliva has two variants, including\n$Oliva^{GR}$, a greedy strategy that always prioritizes the sub-problems that\nare more likely to find counterexamples, and $Oliva^{SA}$, a balanced strategy\ninspired by simulated annealing that gradually shifts from exploration to\nexploitation to locate the globally optimal sub-problems. We experimentally\nevaluate the performance of Oliva on 690 verification problems spanning over 5\nmodels with datasets MNIST and CIFAR10. Compared to the state-of-the-art\napproaches, we demonstrate the speedup of Oliva for up to 25X in MNIST, and up\nto 80X in CIFAR10."}
{"id": "2507.17691", "pdf": "https://arxiv.org/pdf/2507.17691", "abs": "https://arxiv.org/abs/2507.17691", "authors": ["Shan Jiang", "Pranoy Kovuri", "David Tao", "Zhixun Tan"], "title": "CASCADE: LLM-Powered JavaScript Deobfuscator at Google", "categories": ["cs.SE", "cs.AI", "cs.CR", "cs.LG", "cs.PL"], "comment": null, "summary": "Software obfuscation, particularly prevalent in JavaScript, hinders code\ncomprehension and analysis, posing significant challenges to software testing,\nstatic analysis, and malware detection. This paper introduces CASCADE, a novel\nhybrid approach that integrates the advanced coding capabilities of Gemini with\nthe deterministic transformation capabilities of a compiler Intermediate\nRepresentation (IR), specifically JavaScript IR (JSIR). By employing Gemini to\nidentify critical prelude functions, the foundational components underlying the\nmost prevalent obfuscation techniques, and leveraging JSIR for subsequent code\ntransformations, CASCADE effectively recovers semantic elements like original\nstrings and API names, and reveals original program behaviors. This method\novercomes limitations of existing static and dynamic deobfuscation techniques,\neliminating hundreds to thousands of hardcoded rules while achieving\nreliability and flexibility. CASCADE is already deployed in Google's production\nenvironment, demonstrating substantial improvements in JavaScript deobfuscation\nefficiency and reducing reverse engineering efforts."}
