<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]
- [cs.SE](#cs.SE) [Total: 1]
- [cs.CY](#cs.CY) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Efficient compilation and execution of synchronous programs via type-state programming](https://arxiv.org/abs/2508.01199)
*Avinash Malik*

Main category: cs.PL

TL;DR: 提出了一种线性时间编译技术，用于同步程序的自动机编译，显著提升了执行效率。


<details>
  <summary>Details</summary>
Motivation: 同步程序在安全关键嵌入式软件中广泛应用，但其编译过程中状态空间爆炸问题导致效率和性能挑战。

Method: 引入基于图的改写规则和线性时间算法，生成有限状态机（FSM），并通过C++模板元编程编码为类型状态程序。

Result: 实验表明，编译时间和二进制大小与现有技术相当，执行时间平均快31-60%。

Conclusion: 该技术为同步程序的高效编译提供了新方法，显著提升了执行性能。

Abstract: Synchronous programs are used extensively in implementation of safety
critical embedded software. Imperative synchronous programming languages model
multiple Finite State Machines (FSMs) executing in lockstep at logical clock
ticks. The synchronous view of time along with the FSM based design enables
easier formal verification. The synchronous composition of multiple FSMs,
during compilation, results in the well known state space explosion problem.
Hence, efficiently compiling imperative synchronous programs into small and
fast executables is challenging. This paper introduces a novel linear time
compilation technique for automata based compilation of synchronous programs.
Graph based rewrite rules for kernel programming constructs are introduced. A
linear time algorithm applies these rules to produce a FSM. The FSM is then
encoded into a type-state program using template meta-programming in C++.
Experimental results show that the compilation time and generated binary size
is comparable, while the execution times are on average 31-60% faster than
current state-of-the-art compilers.

</details>


### [2] [Proceedings 14th International Workshop on Trends in Functional Programming in Education](https://arxiv.org/abs/2508.02305)
*Rose Bohrer*

Main category: cs.PL

TL;DR: TFPIE是一个专注于教育中函数式编程的研讨会，旨在汇集研究人员、教师和专业人士，讨论新颖或经过课堂测试的想法。


<details>
  <summary>Details</summary>
Motivation: 促进教育中函数式编程的应用和交流。

Method: 通过为期一天的开放式研讨会，并在会后进行论文评审。

Result: 提供一个讨论和分享函数式编程教育经验的平台。

Conclusion: TFPIE旨在通过开放讨论和会后评审，推动函数式编程在教育中的应用。

Abstract: The goal of TFPIE is to gather researchers, teachers and professionals that
use, or are interested in the use of, functional programming in education.
TFPIE aims to be a venue where novel ideas, classroom-tested ideas and
work-in-progress on the use of functional programming in education are
discussed. The one-day workshop will foster a spirit of open discussion by
having a review process for publication after the workshop.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [3] [Flow Sensitivity without Control Flow Graph: An Efficient Andersen-Style Flow-Sensitive Pointer Analysis](https://arxiv.org/abs/2508.01974)
*Jiahao Zhang,Xiao Cheng,Yuxiang Lei*

Main category: cs.SE

TL;DR: CG-FSPTA提出了一种基于流敏感约束图的指针分析方法，显著提高了效率，同时保持了精度。


<details>
  <summary>Details</summary>
Motivation: 现有基于控制流图的流敏感指针分析方法存在计算效率低的问题，CG-FSPTA旨在解决这一问题。

Method: CG-FSPTA利用流敏感的约束图结构，结合图优化和动态求解技术，提升效率。

Result: 实验表明，CG-FSPTA平均减少33.05%内存使用，加速7.27倍，同时保持精度。

Conclusion: CG-FSPTA为大规模软件系统分析提供了高效、可扩展的解决方案。

Abstract: Flow-sensitive pointer analysis constitutes an essential component of precise
program analysis for accurately modeling pointer behaviors by incorporating
control flows. Flow-sensitive pointer analysis is extensively used in alias
analysis, taint analysis, program understanding, compiler optimization, etc.
Existing flow-sensitive pointer analysis approaches, which are conducted based
on control flow graphs, have significantly advanced the precision of pointer
analysis via sophisticated techniques to leverage control flow information.
However, they inevitably suffer from computational inefficiencies when
resolving points-to information due to the inherent complex structures of
control flow graphs. We present CG-FSPTA, a Flow-Sensitive Constraint Graph
(FSConsG) based flow-sensitive pointer analysis to overcome the inefficiency of
control-flow-graph-based analysis. CG-FSPTA uses a flow-sensitive variant to
leverage the structural advantages of set-constraint graphs (which are commonly
used in flow-insensitive pointer analysis) while keeping the flow sensitivity
of variable definitions and uses, allowing the incorporation of sophisticated
graph optimization and dynamic solving techniques. In this way, CG-FSPTA
achieves significant efficiency improvements while keeping the precision of
flow-sensitive analysis. Experimental evaluations on benchmark programs
demonstrate that CG-FSPTA, significantly reduces both memory usage and
execution time while maintaining precision. In particular, by solving in the
FSConsG, CG-FSPTA achieves an average memory reduction of 33.05\% and
accelerates flow-sensitive pointer analysis by 7.27x compared to the
state-of-art method. These experimental results underscore the efficacy of
CG-FSPTA as a scalable solution to analyze large-scale software systems,
establishing a robust foundation for future advancements in efficient program
analysis frameworks.

</details>


<div id='cs.CY'></div>

# cs.CY [[Back]](#toc)

### [4] [Academic Vibe Coding: Opportunities for Accelerating Research in an Era of Resource Constraint](https://arxiv.org/abs/2508.00952)
*Matthew G Crowson,Leo Celi A. Celi*

Main category: cs.CY

TL;DR: Vibe coding是一种利用大型语言模型（LLMs）进行结构化、提示驱动的代码生成的方法，旨在应对学术实验室资源紧张的问题，缩短从想法到分析的周期，并减少对专业数据角色的依赖。


<details>
  <summary>Details</summary>
Motivation: 学术实验室面临预算紧缩、资助上限和数据科学人才市场薪酬高于大学薪酬等资源约束问题。

Method: Vibe coding通过将LLMs嵌入可重复的工作流程中，实现结构化、提示驱动的代码生成，并提供初学者友好的工具链。

Result: 该方法可以压缩分析时间，减轻对专业数据角色的依赖，并保持严格的版本控制输出。

Conclusion: 尽管Vibe coding具有潜力，但仍需治理和谨慎应用以应对其固有局限性。

Abstract: Academic laboratories face mounting resource constraints: budgets are
tightening, grant overheads are potentially being capped, and the market rate
for data-science talent significantly outstrips university compensation. Vibe
coding, which is structured, prompt-driven code generation with large language
models (LLMs) embedded in reproducible workflows, offers one pragmatic
response. It aims to compress the idea-to-analysis timeline, reduce staffing
pressure on specialized data roles, and maintain rigorous, version-controlled
outputs. This article defines the vibe coding concept, situates it against the
current academic resourcing crisis, details a beginner-friendly toolchain for
its implementation, and analyzes inherent limitations that necessitate
governance and mindful application.

</details>
