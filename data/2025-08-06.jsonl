{"id": "2508.02857", "pdf": "https://arxiv.org/pdf/2508.02857", "abs": "https://arxiv.org/abs/2508.02857", "authors": ["Mikhail Mints", "Finn Voichick", "Leonidas Lampropoulos", "Robert Rand"], "title": "Compositional Quantum Control Flow with Efficient Compilation in Qunity", "categories": ["cs.PL", "quant-ph"], "comment": "88 pages, 30 figures", "summary": "Most existing quantum programming languages are based on the quantum circuit\nmodel of computation, as higher-level abstractions are particularly challenging\nto implement - especially ones relating to quantum control flow. The Qunity\nlanguage, proposed by Voichick et al., offered such an abstraction in the form\nof a quantum control construct, with great care taken to ensure that the\nresulting language is still realizable. However, Qunity lacked a working\nimplementation, and the originally proposed compilation procedure was very\ninefficient, with even simple quantum algorithms compiling to unreasonably\nlarge circuits.\n  In this work, we focus on the efficient compilation of high-level quantum\ncontrol flow constructs, using Qunity as our starting point. We introduce a\nwider range of abstractions on top of Qunity's core language that offer\ncompelling trade-offs compared to its existing control construct. We create a\ncomplete implementation of a Qunity compiler, which converts high-level Qunity\ncode into the quantum assembly language OpenQASM 3. We develop optimization\ntechniques for multiple stages of the Qunity compilation procedure, including\nboth low-level circuit optimizations as well as methods that consider the\nhigh-level structure of a Qunity program, greatly reducing the number of qubits\nand gates used by the compiler."}
{"id": "2508.03558", "pdf": "https://arxiv.org/pdf/2508.03558", "abs": "https://arxiv.org/abs/2508.03558", "authors": ["M Zafir Sadik Khan", "Nowfel Mashnoor", "Mohammad Akyash", "Kimia Azar", "Hadi Kamali"], "title": "SAGE-HLS: Syntax-Aware AST-Guided LLM for High-Level Synthesis Code Generation", "categories": ["cs.PL"], "comment": "Accepted to the IEEE International Conference on Computer Design\n  (ICCD 2025)", "summary": "In today's rapidly evolving field of electronic design automation (EDA), the\ncomplexity of hardware designs is increasing, necessitating more sophisticated\nautomation solutions. High-level synthesis (HLS), as a pivotal solution,\nautomates hardware designs from high-level abstractions (e.g., C/C++). However,\nit faces significant challenges, particularly in design space exploration and\noptimization. While large language models (LLMs) have shown notable\ncapabilities in code generation, their application to HLS has been limited due\nto the scarcity of (publicly) available HLS code datasets. Hence, research in\nthis domain has primarily focused on techniques such as prompt engineering and\nretrieval-augmented generation (RAG). To overcome this limitation, this paper\nintroduces SAGE-HLS, the first-of-its-kind fine-tuned LLM specifically for HLS\ncode generation. Our method includes three key advancements: (i) We implement\nVerilog-to-C/C++ porting, converting verified and synthesizable Verilog codes\ninto corresponding C, creating a dataset of 16.7K HLS codes; (ii) We implement\na fine-tuning strategy, which is based on instruction prompting to code\ngeneration guided by abstract syntax tree (AST); (iii) We develop a\nsemi-automated evaluation framework using VerilogEval to assess the\nfunctionality of the generated HLS code. Our experiments show that SAGE-HLS,\nfined-tuned on the QwenCoder (2.5) 7B model, achieves a near 100% success rate\nin code synthesizability and a 75% success rate in functional correctness."}
{"id": "2508.03640", "pdf": "https://arxiv.org/pdf/2508.03640", "abs": "https://arxiv.org/abs/2508.03640", "authors": ["Pedro Vasconcelos"], "title": "Teaching Introductory Functional Programming Using Haskelite", "categories": ["cs.PL", "D.3.2;D.3.4;K.3.1"], "comment": "In Proceedings TFPiE 2025, arXiv:2508.02305", "summary": "Learning functional programming requires learning a substitution-based\ncomputational model. While substitution should be a familiar concept from\nhigh-school algebra, students often have difficulty applying it to new\nsettings, such as recursive definitions, algebraic data types and higher-order\nfunctions. Step-by-step interpreters have been shown to help beginners by\nclarifying misconceptions and improving understanding.\n  This paper reports on the experience of using a step-by-step tracing\ninterpreter for a subset of Haskell while teaching an introductory functional\nprogramming course at the University of Porto. We describe the use of the\ninterpreter, present some feedback obtained from students, reflect on the\nlessons learned and point directions for further work."}
{"id": "2508.02721", "pdf": "https://arxiv.org/pdf/2508.02721", "abs": "https://arxiv.org/abs/2508.02721", "authors": ["Libin Qiu", "Yuhang Ye", "Zhirong Gao", "Xide Zou", "Junfu Chen", "Ziming Gui", "Weizhi Huang", "Xiaobo Xue", "Wenkai Qiu", "Kun Zhao"], "title": "Blueprint First, Model Second: A Framework for Deterministic LLM Workflow", "categories": ["cs.SE", "cs.AI", "cs.PL"], "comment": "8 pages, 6 figures, 3 tables", "summary": "While powerful, the inherent non-determinism of large language model (LLM)\nagents limits their application in structured operational environments where\nprocedural fidelity and predictable execution are strict requirements. This\nlimitation stems from current architectures that conflate probabilistic,\nhigh-level planning with low-level action execution within a single generative\nprocess. To address this, we introduce the Source Code Agent framework, a new\nparadigm built on the \"Blueprint First, Model Second\" philosophy. Our framework\ndecouples the workflow logic from the generative model. An expert-defined\noperational procedure is first codified into a source code-based Execution\nBlueprint, which is then executed by a deterministic engine. The LLM is\nstrategically invoked as a specialized tool to handle bounded, complex\nsub-tasks within the workflow, but never to decide the workflow's path. We\nconduct a comprehensive evaluation on the challenging tau-bench benchmark,\ndesigned for complex user-tool-rule scenarios. Our results demonstrate that the\nSource Code Agent establishes a new state-of-the-art, outperforming the\nstrongest baseline by 10.1 percentage points on the average Pass^1 score while\ndramatically improving execution efficiency. Our work enables the verifiable\nand reliable deployment of autonomous agents in applications governed by strict\nprocedural logic."}
{"id": "2508.02820", "pdf": "https://arxiv.org/pdf/2508.02820", "abs": "https://arxiv.org/abs/2508.02820", "authors": ["David Svoboda", "Lori Flynn", "William Klieber", "Michael Duggan", "Nicholas Reimer", "Joseph Sible"], "title": "Automated Code Repair for C/C++ Static Analysis Alerts", "categories": ["cs.SE", "cs.PL"], "comment": null, "summary": "(Note: This work is a preprint.) Static analysis (SA) tools produce many\ndiagnostic alerts indicating that source code in C or C++ may be defective and\npotentially vulnerable to security exploits. Many of these alerts are false\npositives. Identifying the true-positive alerts and repairing the defects in\nthe associated code are huge efforts that automated program repair (APR) tools\ncan help with. Our experience showed us that APR can reduce the number of SA\nalerts significantly and reduce the manual effort of analysts to review code.\nThis engineering experience paper details the application of design,\ndevelopment, and performance testing to an APR tool we built that repairs C/C++\ncode associated with 3 categories of alerts produced by multiple SA tools. Its\nrepairs are simple and local. Furthermore, our findings convinced the\nmaintainers of the CERT Coding Standards to re-assess and update the metrics\nused to assess when violations of guidelines are detectable or repairable. We\ndiscuss engineering design choices made to support goals of trustworthiness and\nacceptability to developers. Our APR tool repaired 8718 out of 9234 alerts\nproduced by one SA tool on one codebase. It can repair 3 flaw categories. For 2\nflaw categories, 2 SA tools, and 2 codebases, our tool repaired or dismissed as\nfalse positives over 80% of alerts, on average. Tests showed repairs did not\nappreciably degrade the performance of the code or cause new alerts to appear\n(with the possible exception of sqlite3.c). This paper describes unique\ncontributions that include a new empirical analysis of SA data, our selection\nmethod for flaw categories to repair, publication of our APR tool, and a\ndataset of SA alerts from open-source SA tools run on open-source codebases. It\ndiscusses positive and negative results and lessons learned."}
{"id": "2508.03435", "pdf": "https://arxiv.org/pdf/2508.03435", "abs": "https://arxiv.org/abs/2508.03435", "authors": ["Thomas S. Heinze", "André Schäfer", "Wolfram Amme"], "title": "StoneDetector: Conventional and versatile code clone detection for Java", "categories": ["cs.SE", "cs.PL"], "comment": "supplementary information available at\n  https://stonedetector.fmi.uni-jena.de/", "summary": "Copy & paste is a widespread practice when developing software and, thus,\nduplicated and subsequently modified code occurs frequently in software\nprojects. Since such code clones, i.e., identical or similar fragments of code,\ncan bloat software projects and cause issues like bug or vulnerability\npropagation, their identification is of importance. In this paper, we present\nthe StoneDetector platform and its underlying method for finding code clones in\nJava source and Bytecode. StoneDetector implements a conventional clone\ndetection approach based upon the textual comparison of paths derived from the\ncode's representation by dominator trees. In this way, the tool does not only\nfind exact and syntactically similar near-miss code clones, but also code\nclones that are harder to detect due to their larger variety in the syntax. We\ndemonstrate StoneDetector's versatility as a conventional clone detection\nplatform and analyze its various available configuration parameters, including\nthe usage of different string metrics, hashing algorithms, etc. In our\nexhaustive evaluation with other conventional clone detectors on several\nstate-of-the-art benchmarks, we can show StoneDetector's performance and\nscalability in finding code clones in both, Java source and Bytecode."}
{"id": "2508.03603", "pdf": "https://arxiv.org/pdf/2508.03603", "abs": "https://arxiv.org/abs/2508.03603", "authors": ["Iti Shree", "Karine Even-Mendoz", "Tomasz Radzik"], "title": "ReFuzzer: Feedback-Driven Approach to Enhance Validity of LLM-Generated Test Programs", "categories": ["cs.SE", "cs.PL"], "comment": null, "summary": "Existing LLM-based compiler fuzzers often produce syntactically or\nsemantically invalid test programs, limiting their effectiveness in exercising\ncompiler optimizations and backend components. We introduce ReFuzzer, a\nframework for refining LLM-generated test programs by systematically detecting\nand correcting compilation and runtime violations (e.g. division by zero or\narray out-of-bounds accesses). ReFuzzer employs a feedback loop with a local\nLLM to validate and filter erroneous programs before execution, improving\nfuzzing effectiveness beyond crash detection and enabling the generation of\ndiverse yet valid test programs.\n  We evaluated ReFuzzer's effectiveness across black-, grey- and white-box\nfuzzing approaches targeting LLVM/Clang. ReFuzzer improved test programs'\nvalidity from 47.0-49.4% to 96.6-97.3%, with an average processing time of\n2.9-3.5 s per test program on a dual-GPU machine. Further, refuzzing\nsignificantly increased code coverage in critical optimization and IR\ngeneration components. For example, vectorization coverage had an absolute\nimprovement of 9.2%, 2.3%, and 7.1% in black-, grey-, and white-box fuzzing,\nenhancing testing effectiveness."}
{"id": "2508.03638", "pdf": "https://arxiv.org/pdf/2508.03638", "abs": "https://arxiv.org/abs/2508.03638", "authors": ["Marco T. Morazán", "Oliwia Kempinski", "Andrés M. Garced"], "title": "Design Support for Multitape Turing Machines", "categories": ["cs.FL", "cs.HC", "cs.PL", "cs.SE"], "comment": "In Proceedings TFPiE 2025, arXiv:2508.02305", "summary": "Many Formal Languages and Automata Theory courses introduce students to\nTuring machine extensions. One of the most widely-used extensions endows Turing\nmachines with multiple tapes. Although multitape Turing machines are an\nabstraction to simplify Turing machine design, students find them no less\nchallenging. To aid students in understanding these machines, the FSM\nprogramming language provides support for their definition and execution. This,\nhowever, has proven insufficient for many students to understand the\noperational semantics of such machines and to understand why such machines\naccept or reject a word. To address this problem, three visualization tools\nhave been developed. The first is a dynamic visualization tool that simulates\nmachine execution. The second is a static visualization tool that automatically\nrenders a graphic for a multitape Turing machine's transition diagram. The\nthird is a static visualization tool that automatically renders computation\ngraphs for multitape Turing machines. This article presents these tools and\nillustrates how they are used to help students design and implement multitape\nTuring machines. In addition, empirical data is presented that suggests these\ntools are well-received and found useful by students."}
{"id": "2508.03639", "pdf": "https://arxiv.org/pdf/2508.03639", "abs": "https://arxiv.org/abs/2508.03639", "authors": ["Marco T. Morazán", "Shamil Dzhatdoyev", "Josephine Des Rosiers", "Tijana Minić", "Andrés M. Garced", "David Anthony K. Fields"], "title": "A Design Recipe and Recipe-Based Errors for Regular Expressions", "categories": ["cs.FL", "cs.HC", "cs.PL", "cs.SE"], "comment": "In Proceedings TFPiE 2025, arXiv:2508.02305", "summary": "This article presents a novel framework to provide Formal Languages and\nAutomata Theory students design support for the development of regular\nexpressions. This framework includes a design recipe for regular expressions\nand a customized error messaging system. The error messaging system produces\nrecipe-based errors that include the step of the design recipe not successfully\ncompleted. Furthermore, the error messages follow the established practices of\nbeing concise, succinct, jargon-free, and nonprescriptive. In addition, a\nshorthand syntax developed for writing unit tests is described. The in-class\nuse of the design recipe is illustrated, two debugging sessions using the\ndescribed system are discussed, and the implementation of the error messaging\nsystem is briefly sketched."}
{"id": "2508.03641", "pdf": "https://arxiv.org/pdf/2508.03641", "abs": "https://arxiv.org/abs/2508.03641", "authors": ["Marco T. Morazán", "David Anthony K. Fields", "Andrés M. Garced", "Tijana Minić"], "title": "Visual Execution and Validation of Finite-State Machines and Pushdown Automata", "categories": ["cs.FL", "cs.HC", "cs.PL", "cs.SE"], "comment": "In Proceedings TFPiE 2025, arXiv:2508.02305", "summary": "In Formal Languages and Automata Theory courses, students find understanding\nnondeterministic finite-state and pushdown automata difficult. In many cases,\nthis means that it is challenging for them to comprehend the operational\nsemantics of such machines and, as a consequence, determine why a word is\naccepted or rejected. This is not entirely surprising, because students are\nmostly trained to design and implement deterministic programs. Comprehension of\npushdown automata is further complicated, because reasoning about the stack is\nnecessary. A common difficulty students face, for example, is understanding\nthat two different computations on the same word may reach the same state with\ndifferent stack values. To aid student understanding, we present two novel\ndynamic visualization tools for FSM -- a domain-specific programming language\nfor the Automata Theory classroom -- to support the design of such machines.\nThese tools visualize all computations that may be performed, respectively, by\na nondeterministic finite-state machine or by a pushdown automata in a stepwise\nmanner. In addition, these tools aid the machine verification process by\nallowing users to visually validate whether the properties a state represents\nhold when a machine transitions into it."}
{"id": "2508.03678", "pdf": "https://arxiv.org/pdf/2508.03678", "abs": "https://arxiv.org/abs/2508.03678", "authors": ["Yangtian Zi", "Harshitha Menon", "Arjun Guha"], "title": "More Than a Score: Probing the Impact of Prompt Specificity on LLM Code Generation", "categories": ["cs.CL", "cs.LG", "cs.PL"], "comment": null, "summary": "State-of-the-art Large Language Models (LLMs) achieve high pass@1 on general\nbenchmarks like HumanEval but underperform on specialized suites such as\nParEval. Is this due to LLMs missing domain knowledge or insufficient prompt\ndetail is given? To answer this, we introduce PartialOrderEval, which augments\nany code generation benchmark with a partial order of prompts from minimal to\nmaximally detailed. Applying it to HumanEval and both serial and OpenMP subsets\nof ParEval, we measure how pass@1 scales with prompt specificity. Our\nexperiments with Llama-3.x and Qwen2.5-Coder demonstrate varying degrees of\nprompt sensitivity across different tasks, and a qualitative analysis\nhighlights explicit I/O specifications, edge-case handling, and stepwise\nbreakdowns as the key drivers of prompt detail improvement."}
