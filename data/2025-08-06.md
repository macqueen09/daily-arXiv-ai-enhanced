<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]
- [cs.CL](#cs.CL) [Total: 1]
- [cs.SE](#cs.SE) [Total: 4]
- [cs.FL](#cs.FL) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Compositional Quantum Control Flow with Efficient Compilation in Qunity](https://arxiv.org/abs/2508.02857)
*Mikhail Mints,Finn Voichick,Leonidas Lampropoulos,Robert Rand*

Main category: cs.PL

TL;DR: 本文改进了Qunity语言的编译效率，通过引入新的抽象和优化技术，显著减少了量子比特和门的数量。


<details>
  <summary>Details</summary>
Motivation: 现有量子编程语言（如Qunity）缺乏高效实现，编译过程效率低下，导致生成的量子电路过大。

Method: 在Qunity基础上引入更多抽象，开发完整的编译器实现，并优化编译流程的多个阶段。

Result: 实现了高效的Qunity编译器，显著减少了量子比特和门的数量。

Conclusion: 通过优化编译流程，Qunity语言的高效实现成为可能，为量子控制流提供了更实用的工具。

Abstract: Most existing quantum programming languages are based on the quantum circuit
model of computation, as higher-level abstractions are particularly challenging
to implement - especially ones relating to quantum control flow. The Qunity
language, proposed by Voichick et al., offered such an abstraction in the form
of a quantum control construct, with great care taken to ensure that the
resulting language is still realizable. However, Qunity lacked a working
implementation, and the originally proposed compilation procedure was very
inefficient, with even simple quantum algorithms compiling to unreasonably
large circuits.
  In this work, we focus on the efficient compilation of high-level quantum
control flow constructs, using Qunity as our starting point. We introduce a
wider range of abstractions on top of Qunity's core language that offer
compelling trade-offs compared to its existing control construct. We create a
complete implementation of a Qunity compiler, which converts high-level Qunity
code into the quantum assembly language OpenQASM 3. We develop optimization
techniques for multiple stages of the Qunity compilation procedure, including
both low-level circuit optimizations as well as methods that consider the
high-level structure of a Qunity program, greatly reducing the number of qubits
and gates used by the compiler.

</details>


### [2] [SAGE-HLS: Syntax-Aware AST-Guided LLM for High-Level Synthesis Code Generation](https://arxiv.org/abs/2508.03558)
*M Zafir Sadik Khan,Nowfel Mashnoor,Mohammad Akyash,Kimia Azar,Hadi Kamali*

Main category: cs.PL

TL;DR: 论文提出了SAGE-HLS，一种专为HLS代码生成优化的LLM，通过Verilog-to-C/C++转换和指令微调策略，显著提升了代码生成的成功率和功能性。


<details>
  <summary>Details</summary>
Motivation: 由于HLS代码数据集的稀缺，现有LLM在HLS领域的应用受限，亟需一种专门优化的解决方案。

Method: 1. 通过Verilog-to-C/C++转换构建16.7K的HLS代码数据集；2. 基于AST的指令微调策略；3. 使用VerilogEval半自动化评估框架。

Result: SAGE-HLS在代码可合成性上接近100%成功率，功能性正确率达75%。

Conclusion: SAGE-HLS为HLS代码生成提供了高效且可靠的解决方案，填补了LLM在该领域的空白。

Abstract: In today's rapidly evolving field of electronic design automation (EDA), the
complexity of hardware designs is increasing, necessitating more sophisticated
automation solutions. High-level synthesis (HLS), as a pivotal solution,
automates hardware designs from high-level abstractions (e.g., C/C++). However,
it faces significant challenges, particularly in design space exploration and
optimization. While large language models (LLMs) have shown notable
capabilities in code generation, their application to HLS has been limited due
to the scarcity of (publicly) available HLS code datasets. Hence, research in
this domain has primarily focused on techniques such as prompt engineering and
retrieval-augmented generation (RAG). To overcome this limitation, this paper
introduces SAGE-HLS, the first-of-its-kind fine-tuned LLM specifically for HLS
code generation. Our method includes three key advancements: (i) We implement
Verilog-to-C/C++ porting, converting verified and synthesizable Verilog codes
into corresponding C, creating a dataset of 16.7K HLS codes; (ii) We implement
a fine-tuning strategy, which is based on instruction prompting to code
generation guided by abstract syntax tree (AST); (iii) We develop a
semi-automated evaluation framework using VerilogEval to assess the
functionality of the generated HLS code. Our experiments show that SAGE-HLS,
fined-tuned on the QwenCoder (2.5) 7B model, achieves a near 100% success rate
in code synthesizability and a 75% success rate in functional correctness.

</details>


### [3] [Teaching Introductory Functional Programming Using Haskelite](https://arxiv.org/abs/2508.03640)
*Pedro Vasconcelos*

Main category: cs.PL

TL;DR: 论文探讨了在教授函数式编程时使用逐步追踪解释器的经验，展示了其在帮助学生理解替换模型方面的效果。


<details>
  <summary>Details</summary>
Motivation: 学生在学习函数式编程时对替换模型的应用存在困难，尤其是在递归定义、代数数据类型和高阶函数等新场景中。

Method: 在波尔图大学的函数式编程课程中，使用了一个针对Haskell子集的逐步追踪解释器。

Result: 学生反馈表明，解释器有助于澄清误解并提升理解。

Conclusion: 逐步追踪解释器是有效的教学工具，未来可进一步优化和扩展。

Abstract: Learning functional programming requires learning a substitution-based
computational model. While substitution should be a familiar concept from
high-school algebra, students often have difficulty applying it to new
settings, such as recursive definitions, algebraic data types and higher-order
functions. Step-by-step interpreters have been shown to help beginners by
clarifying misconceptions and improving understanding.
  This paper reports on the experience of using a step-by-step tracing
interpreter for a subset of Haskell while teaching an introductory functional
programming course at the University of Porto. We describe the use of the
interpreter, present some feedback obtained from students, reflect on the
lessons learned and point directions for further work.

</details>


<div id='cs.CL'></div>

# cs.CL [[Back]](#toc)

### [4] [More Than a Score: Probing the Impact of Prompt Specificity on LLM Code Generation](https://arxiv.org/abs/2508.03678)
*Yangtian Zi,Harshitha Menon,Arjun Guha*

Main category: cs.CL

TL;DR: 论文研究了LLMs在通用与专用代码生成基准上的表现差异，通过PartialOrderEval分析提示细节对性能的影响。


<details>
  <summary>Details</summary>
Motivation: 探究LLMs在专用基准上表现不佳的原因是缺乏领域知识还是提示细节不足。

Method: 引入PartialOrderEval，为代码生成基准提供从最小到最大细节的提示序列，并应用于HumanEval和ParEval。

Result: 实验显示不同任务对提示细节的敏感度不同，明确I/O规范、边缘案例处理和分步拆解是关键改进因素。

Conclusion: 提示细节的优化能显著提升LLMs在专用任务上的表现。

Abstract: State-of-the-art Large Language Models (LLMs) achieve high pass@1 on general
benchmarks like HumanEval but underperform on specialized suites such as
ParEval. Is this due to LLMs missing domain knowledge or insufficient prompt
detail is given? To answer this, we introduce PartialOrderEval, which augments
any code generation benchmark with a partial order of prompts from minimal to
maximally detailed. Applying it to HumanEval and both serial and OpenMP subsets
of ParEval, we measure how pass@1 scales with prompt specificity. Our
experiments with Llama-3.x and Qwen2.5-Coder demonstrate varying degrees of
prompt sensitivity across different tasks, and a qualitative analysis
highlights explicit I/O specifications, edge-case handling, and stepwise
breakdowns as the key drivers of prompt detail improvement.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [5] [Blueprint First, Model Second: A Framework for Deterministic LLM Workflow](https://arxiv.org/abs/2508.02721)
*Libin Qiu,Yuhang Ye,Zhirong Gao,Xide Zou,Junfu Chen,Ziming Gui,Weizhi Huang,Xiaobo Xue,Wenkai Qiu,Kun Zhao*

Main category: cs.SE

TL;DR: 论文提出了一种名为Source Code Agent的新框架，通过将工作流逻辑与生成模型解耦，解决了LLM在结构化操作环境中的非确定性问题。


<details>
  <summary>Details</summary>
Motivation: 大型语言模型（LLM）的非确定性限制了其在需要严格程序保真度和可预测执行的结构化环境中的应用。

Method: 采用'Blueprint First, Model Second'哲学，将专家定义的操作程序编码为基于源代码的执行蓝图，并由确定性引擎执行，LLM仅用于处理有限复杂子任务。

Result: 在tau-bench基准测试中，Source Code Agent表现优异，平均Pass^1得分比最强基线高出10.1个百分点，显著提高了执行效率。

Conclusion: 该框架为严格程序逻辑应用中的自主代理提供了可验证且可靠的部署方案。

Abstract: While powerful, the inherent non-determinism of large language model (LLM)
agents limits their application in structured operational environments where
procedural fidelity and predictable execution are strict requirements. This
limitation stems from current architectures that conflate probabilistic,
high-level planning with low-level action execution within a single generative
process. To address this, we introduce the Source Code Agent framework, a new
paradigm built on the "Blueprint First, Model Second" philosophy. Our framework
decouples the workflow logic from the generative model. An expert-defined
operational procedure is first codified into a source code-based Execution
Blueprint, which is then executed by a deterministic engine. The LLM is
strategically invoked as a specialized tool to handle bounded, complex
sub-tasks within the workflow, but never to decide the workflow's path. We
conduct a comprehensive evaluation on the challenging tau-bench benchmark,
designed for complex user-tool-rule scenarios. Our results demonstrate that the
Source Code Agent establishes a new state-of-the-art, outperforming the
strongest baseline by 10.1 percentage points on the average Pass^1 score while
dramatically improving execution efficiency. Our work enables the verifiable
and reliable deployment of autonomous agents in applications governed by strict
procedural logic.

</details>


### [6] [Automated Code Repair for C/C++ Static Analysis Alerts](https://arxiv.org/abs/2508.02820)
*David Svoboda,Lori Flynn,William Klieber,Michael Duggan,Nicholas Reimer,Joseph Sible*

Main category: cs.SE

TL;DR: 论文探讨了如何利用自动化程序修复（APR）工具减少静态分析（SA）工具产生的误报警报，并通过实际工程经验展示了其有效性。


<details>
  <summary>Details</summary>
Motivation: 静态分析工具在C/C++代码中产生大量诊断警报，其中许多是误报。手动识别和修复这些警报耗时耗力，APR工具可以显著减少警报数量并降低人工审查负担。

Method: 设计、开发和性能测试了一个APR工具，用于修复由多个SA工具产生的3类警报。修复方法简单且局部化。

Result: APR工具在一个代码库中修复了8718/9234个警报，对2类缺陷、2个SA工具和2个代码库的平均修复或误报排除率超过80%。修复未显著影响代码性能或引发新警报。

Conclusion: APR工具能有效减少SA警报，提升开发效率。研究还促使CERT编码标准维护者重新评估和更新了相关指标。论文总结了工程经验教训和贡献。

Abstract: (Note: This work is a preprint.) Static analysis (SA) tools produce many
diagnostic alerts indicating that source code in C or C++ may be defective and
potentially vulnerable to security exploits. Many of these alerts are false
positives. Identifying the true-positive alerts and repairing the defects in
the associated code are huge efforts that automated program repair (APR) tools
can help with. Our experience showed us that APR can reduce the number of SA
alerts significantly and reduce the manual effort of analysts to review code.
This engineering experience paper details the application of design,
development, and performance testing to an APR tool we built that repairs C/C++
code associated with 3 categories of alerts produced by multiple SA tools. Its
repairs are simple and local. Furthermore, our findings convinced the
maintainers of the CERT Coding Standards to re-assess and update the metrics
used to assess when violations of guidelines are detectable or repairable. We
discuss engineering design choices made to support goals of trustworthiness and
acceptability to developers. Our APR tool repaired 8718 out of 9234 alerts
produced by one SA tool on one codebase. It can repair 3 flaw categories. For 2
flaw categories, 2 SA tools, and 2 codebases, our tool repaired or dismissed as
false positives over 80% of alerts, on average. Tests showed repairs did not
appreciably degrade the performance of the code or cause new alerts to appear
(with the possible exception of sqlite3.c). This paper describes unique
contributions that include a new empirical analysis of SA data, our selection
method for flaw categories to repair, publication of our APR tool, and a
dataset of SA alerts from open-source SA tools run on open-source codebases. It
discusses positive and negative results and lessons learned.

</details>


### [7] [StoneDetector: Conventional and versatile code clone detection for Java](https://arxiv.org/abs/2508.03435)
*Thomas S. Heinze,André Schäfer,Wolfram Amme*

Main category: cs.SE

TL;DR: StoneDetector平台及其方法用于检测Java源代码和字节码中的代码克隆，基于支配树的路径文本比较，支持多种配置参数，性能优越。


<details>
  <summary>Details</summary>
Motivation: 代码克隆在软件开发中普遍存在，可能导致项目臃肿和漏洞传播，因此识别克隆代码至关重要。

Method: StoneDetector采用基于支配树路径文本比较的传统克隆检测方法，支持多种字符串度量和哈希算法。

Result: 在多个基准测试中，StoneDetector在检测Java源代码和字节码克隆方面表现出高性能和可扩展性。

Conclusion: StoneDetector是一种高效且可配置的代码克隆检测工具，适用于多种场景。

Abstract: Copy & paste is a widespread practice when developing software and, thus,
duplicated and subsequently modified code occurs frequently in software
projects. Since such code clones, i.e., identical or similar fragments of code,
can bloat software projects and cause issues like bug or vulnerability
propagation, their identification is of importance. In this paper, we present
the StoneDetector platform and its underlying method for finding code clones in
Java source and Bytecode. StoneDetector implements a conventional clone
detection approach based upon the textual comparison of paths derived from the
code's representation by dominator trees. In this way, the tool does not only
find exact and syntactically similar near-miss code clones, but also code
clones that are harder to detect due to their larger variety in the syntax. We
demonstrate StoneDetector's versatility as a conventional clone detection
platform and analyze its various available configuration parameters, including
the usage of different string metrics, hashing algorithms, etc. In our
exhaustive evaluation with other conventional clone detectors on several
state-of-the-art benchmarks, we can show StoneDetector's performance and
scalability in finding code clones in both, Java source and Bytecode.

</details>


### [8] [ReFuzzer: Feedback-Driven Approach to Enhance Validity of LLM-Generated Test Programs](https://arxiv.org/abs/2508.03603)
*Iti Shree,Karine Even-Mendoz,Tomasz Radzik*

Main category: cs.SE

TL;DR: ReFuzzer是一个框架，通过检测和修正LLM生成的测试程序中的编译和运行时错误，显著提高了测试程序的有效性和代码覆盖率。


<details>
  <summary>Details</summary>
Motivation: 现有基于LLM的编译器模糊测试工具生成的测试程序常存在语法或语义错误，限制了其对编译器优化和后端组件的测试效果。

Method: ReFuzzer采用反馈循环机制，利用本地LLM验证和过滤错误程序，确保生成的测试程序有效。

Result: ReFuzzer将测试程序的有效性从47.0-49.4%提升至96.6-97.3%，并显著提高了关键组件的代码覆盖率。

Conclusion: ReFuzzer通过改进测试程序的有效性和覆盖率，提升了编译器模糊测试的效果。

Abstract: Existing LLM-based compiler fuzzers often produce syntactically or
semantically invalid test programs, limiting their effectiveness in exercising
compiler optimizations and backend components. We introduce ReFuzzer, a
framework for refining LLM-generated test programs by systematically detecting
and correcting compilation and runtime violations (e.g. division by zero or
array out-of-bounds accesses). ReFuzzer employs a feedback loop with a local
LLM to validate and filter erroneous programs before execution, improving
fuzzing effectiveness beyond crash detection and enabling the generation of
diverse yet valid test programs.
  We evaluated ReFuzzer's effectiveness across black-, grey- and white-box
fuzzing approaches targeting LLVM/Clang. ReFuzzer improved test programs'
validity from 47.0-49.4% to 96.6-97.3%, with an average processing time of
2.9-3.5 s per test program on a dual-GPU machine. Further, refuzzing
significantly increased code coverage in critical optimization and IR
generation components. For example, vectorization coverage had an absolute
improvement of 9.2%, 2.3%, and 7.1% in black-, grey-, and white-box fuzzing,
enhancing testing effectiveness.

</details>


<div id='cs.FL'></div>

# cs.FL [[Back]](#toc)

### [9] [Design Support for Multitape Turing Machines](https://arxiv.org/abs/2508.03638)
*Marco T. Morazán,Oliwia Kempinski,Andrés M. Garced*

Main category: cs.FL

TL;DR: 论文介绍了三种可视化工具，帮助学生理解多带图灵机的操作语义和设计。


<details>
  <summary>Details</summary>
Motivation: 学生在学习多带图灵机时面临挑战，现有的FSM编程语言支持不足。

Method: 开发了三种可视化工具：动态模拟执行、静态渲染转移图和计算图。

Result: 工具受到学生欢迎，并被证明有助于理解和设计多带图灵机。

Conclusion: 可视化工具能有效提升学生对多带图灵机的理解与设计能力。

Abstract: Many Formal Languages and Automata Theory courses introduce students to
Turing machine extensions. One of the most widely-used extensions endows Turing
machines with multiple tapes. Although multitape Turing machines are an
abstraction to simplify Turing machine design, students find them no less
challenging. To aid students in understanding these machines, the FSM
programming language provides support for their definition and execution. This,
however, has proven insufficient for many students to understand the
operational semantics of such machines and to understand why such machines
accept or reject a word. To address this problem, three visualization tools
have been developed. The first is a dynamic visualization tool that simulates
machine execution. The second is a static visualization tool that automatically
renders a graphic for a multitape Turing machine's transition diagram. The
third is a static visualization tool that automatically renders computation
graphs for multitape Turing machines. This article presents these tools and
illustrates how they are used to help students design and implement multitape
Turing machines. In addition, empirical data is presented that suggests these
tools are well-received and found useful by students.

</details>


### [10] [A Design Recipe and Recipe-Based Errors for Regular Expressions](https://arxiv.org/abs/2508.03639)
*Marco T. Morazán,Shamil Dzhatdoyev,Josephine Des Rosiers,Tijana Minić,Andrés M. Garced,David Anthony K. Fields*

Main category: cs.FL

TL;DR: 本文提出了一种新颖框架，为形式语言与自动机理论学生提供正则表达式设计支持，包括设计方法和定制错误消息系统。


<details>
  <summary>Details</summary>
Motivation: 帮助学生更高效地设计和调试正则表达式，减少学习障碍。

Method: 框架包含正则表达式的设计方法和基于步骤的错误消息系统，同时介绍了简写的单元测试语法。

Result: 展示了设计方法在课堂中的应用、调试会话示例，并简要描述了错误消息系统的实现。

Conclusion: 该框架通过结构化设计和清晰错误反馈，提升了学生学习正则表达式的效率。

Abstract: This article presents a novel framework to provide Formal Languages and
Automata Theory students design support for the development of regular
expressions. This framework includes a design recipe for regular expressions
and a customized error messaging system. The error messaging system produces
recipe-based errors that include the step of the design recipe not successfully
completed. Furthermore, the error messages follow the established practices of
being concise, succinct, jargon-free, and nonprescriptive. In addition, a
shorthand syntax developed for writing unit tests is described. The in-class
use of the design recipe is illustrated, two debugging sessions using the
described system are discussed, and the implementation of the error messaging
system is briefly sketched.

</details>


### [11] [Visual Execution and Validation of Finite-State Machines and Pushdown Automata](https://arxiv.org/abs/2508.03641)
*Marco T. Morazán,David Anthony K. Fields,Andrés M. Garced,Tijana Minić*

Main category: cs.FL

TL;DR: 论文提出两种动态可视化工具，帮助学生理解非确定性有限状态机和下推自动机的操作语义。


<details>
  <summary>Details</summary>
Motivation: 学生在形式语言与自动机理论课程中难以理解非确定性有限状态机和下推自动机，尤其是其操作语义和栈的推理。

Method: 开发了两种动态可视化工具，分别用于非确定性有限状态机和下推自动机，逐步展示所有可能的计算过程。

Result: 工具支持学生通过视觉验证状态转换时属性的正确性，提升理解。

Conclusion: 动态可视化工具能有效帮助学生理解和验证自动机的行为。

Abstract: In Formal Languages and Automata Theory courses, students find understanding
nondeterministic finite-state and pushdown automata difficult. In many cases,
this means that it is challenging for them to comprehend the operational
semantics of such machines and, as a consequence, determine why a word is
accepted or rejected. This is not entirely surprising, because students are
mostly trained to design and implement deterministic programs. Comprehension of
pushdown automata is further complicated, because reasoning about the stack is
necessary. A common difficulty students face, for example, is understanding
that two different computations on the same word may reach the same state with
different stack values. To aid student understanding, we present two novel
dynamic visualization tools for FSM -- a domain-specific programming language
for the Automata Theory classroom -- to support the design of such machines.
These tools visualize all computations that may be performed, respectively, by
a nondeterministic finite-state machine or by a pushdown automata in a stepwise
manner. In addition, these tools aid the machine verification process by
allowing users to visually validate whether the properties a state represents
hold when a machine transitions into it.

</details>
