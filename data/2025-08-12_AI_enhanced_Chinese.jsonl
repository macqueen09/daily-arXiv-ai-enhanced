{"id": "2508.07855", "pdf": "https://arxiv.org/pdf/2508.07855", "abs": "https://arxiv.org/abs/2508.07855", "authors": ["Parosh Aziz Abdulla", "Mohamed Faouzi Atig", "R. Govind", "Samuel Grahn", "Ramanathan S. Thinniyam"], "title": "Checking Consistency of Event-driven Traces", "categories": ["cs.PL"], "comment": null, "summary": "Event-driven programming is a popular paradigm where the flow of execution is\ncontrolled by two features: (1) shared memory and (2) sending and receiving of\nmessages between multiple handler threads (just called handler). Each handler\nhas a mailbox (modelled as a queue) for receiving messages, with the constraint\nthat the handler processes its messages sequentially. Executions of messages by\ndifferent handlers may be interleaved. A central problem in this setting is\nchecking whether a candidate execution is consistent with the semantics of\nevent-driven programs. In this paper, we propose an axiomatic semantics for\neventdriven programs based on the standard notion of traces (also known as\nexecution graphs). We prove the equivalence of axiomatic and operational\nsemantics. This allows us to rephrase the consistency problem axiomatically,\nresulting in the event-driven consistency problem: checking whether a given\ntrace is consistent. We analyze the computational complexity of this problem\nand show that it is NP-complete, even when the number of handler threads is\nbounded. We then identify a tractable fragment: in the absence of nested\nposting, where handlers do not post new messages while processing a message,\nconsistency checking can be performed in polynomial time. Finally, we implement\nour approach in a prototype tool and report on experimental results on a wide\nrange of benchmarks.", "AI": {"tldr": "\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u6267\u884c\u56fe\u7684\u516c\u7406\u5316\u8bed\u4e49\u65b9\u6cd5\uff0c\u7528\u4e8e\u9a8c\u8bc1\u4e8b\u4ef6\u9a71\u52a8\u7a0b\u5e8f\u7684\u6267\u884c\u4e00\u81f4\u6027\uff0c\u8bc1\u660e\u4e86\u5176\u4e0e\u64cd\u4f5c\u8bed\u4e49\u7684\u7b49\u4ef7\u6027\uff0c\u5e76\u5206\u6790\u4e86\u95ee\u9898\u7684\u8ba1\u7b97\u590d\u6742\u6027\u3002", "motivation": "\u4e8b\u4ef6\u9a71\u52a8\u7a0b\u5e8f\u7684\u6267\u884c\u4e00\u81f4\u6027\u9a8c\u8bc1\u662f\u4e00\u4e2a\u6838\u5fc3\u95ee\u9898\uff0c\u73b0\u6709\u65b9\u6cd5\u7f3a\u4e4f\u7edf\u4e00\u7684\u8bed\u4e49\u6846\u67b6\u3002", "method": "\u63d0\u51fa\u57fa\u4e8e\u6267\u884c\u56fe\u7684\u516c\u7406\u5316\u8bed\u4e49\uff0c\u8bc1\u660e\u5176\u4e0e\u64cd\u4f5c\u8bed\u4e49\u7684\u7b49\u4ef7\u6027\uff0c\u5e76\u5206\u6790\u4e00\u81f4\u6027\u95ee\u9898\u7684\u8ba1\u7b97\u590d\u6742\u6027\u3002", "result": "\u8bc1\u660e\u4e8b\u4ef6\u9a71\u52a8\u4e00\u81f4\u6027\u95ee\u9898\u662fNP\u5b8c\u5168\u7684\uff0c\u4f46\u5728\u65e0\u5d4c\u5957\u53d1\u5e03\u7684\u60c5\u51b5\u4e0b\u53ef\u5728\u591a\u9879\u5f0f\u65f6\u95f4\u5185\u89e3\u51b3\u3002", "conclusion": "\u901a\u8fc7\u516c\u7406\u5316\u8bed\u4e49\u548c\u539f\u578b\u5de5\u5177\u9a8c\u8bc1\u4e86\u65b9\u6cd5\u7684\u6709\u6548\u6027\uff0c\u4e3a\u4e8b\u4ef6\u9a71\u52a8\u7a0b\u5e8f\u7684\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u65b0\u601d\u8def\u3002"}}
