<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 4]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [StackPilot: Autonomous Function Agents for Scalable and Environment-Free Code Execution](https://arxiv.org/abs/2508.11665)
*Xinkui Zhao,Yifan Zhang,Zhengyi Zhou,Yueshen Xu*

Main category: cs.PL

TL;DR: StackPilot是一个LLM原生的多智能体框架，用于语言无关的代码验证和执行，无需传统工具链，通过函数即智能体、LLM作为执行器和快照机制实现高可靠性验证。


<details>
  <summary>Details</summary>
Motivation: 大型语言模型生成的代码验证面临依赖语言特定编译器和环境运行时的挑战，需要一种语言无关的验证方法来克服这些限制。

Method: 采用多智能体框架，包括：1)函数即智能体范式，每个函数作为自主智能体进行细粒度推理和协作验证；2)LLM作为执行器策略，通过基于堆栈的调度实现可扩展验证；3)快照机制保存完整执行上下文，支持确定性无损耗上下文切换。

Result: 实证评估显示StackPilot达到89%-97%的框架可靠性率，显著优于基线方法，能够可靠验证和执行更多LLM生成的代码。

Conclusion: StackPilot提供了一种有效的语言无关代码验证解决方案，大幅提升了LLM生成代码的可验证性和可执行性。

Abstract: Recent advances in large language models (LLMs) have substantially enhanced
automated code generation across a wide range of programming languages.
Nonetheless, verifying the correctness and executability of LLM-generated code
remains a significant challenge, as traditional methods rely on
language-specific compilers and environment-dependent runtimes. To overcome
these limitations, we introduce StackPilot, an LLM-native, multi-agent
framework designed for language-agnostic code verification and execution, which
operates independently of conventional toolchains. StackPilot offers three
principal innovations: (1) a Function-as-Agents paradigm, in which each
function is modeled as an autonomous agent capable of fine-grained reasoning
and collaborative verification; (2) an LLM-as-Executor strategy, which enables
scalable verification via stack-based scheduling; and (3) a novel snapshot
mechanism that preserves complete execution contexts, facilitating
deterministic and lossless context switching during verification. Empirical
evaluations demonstrate that StackPilot achieves framework reliability rates
between 89% and 97%, substantially outperforming baseline approaches. These
results indicate that StackPilot can reliably verify and execute a
significantly larger proportion of LLM-generated code across diverse
programming tasks compared to existing methods.

</details>


### [2] [Certified Compilation based on Gödel Numbers](https://arxiv.org/abs/2508.12054)
*Guilherme de Oliveira Silva,Fernando Magno Quintão Pereira*

Main category: cs.PL

TL;DR: 提出一种新的证书生成方法，通过整数证书来验证二进制代码是否忠实表示源代码，确保编译过程的可信性。


<details>
  <summary>Details</summary>
Motivation: 解决Ken Thompson提出的编译器后门问题，现有防御方法如DDC等仍然需要信任基础编译器，需要从根本上验证编译过程的正确性。

Method: 设计一种证书生成机制，从源代码和二进制代码分别推导出相同的整数证书，验证二进制包含且仅包含源代码语句、保持顺序和def-use依赖关系。开发Charon编译器处理C语言子集来验证方法实用性。

Result: 提出了可行的证书验证框架，能够确保二进制代码忠实表示源代码，解决了编译器信任的根本问题。

Conclusion: 该方法提供了一种新的可信编译验证途径，通过数学证书机制从根本上防御Thompson式后门攻击，具有实际应用价值。

Abstract: In his 1984 Turing Award lecture, Ken Thompson showed that a compiler could
be maliciously altered to insert backdoors into programs it compiles and
perpetuate this behavior by modifying any compiler it subsequently builds.
Thompson's hack has been reproduced in real-world systems for demonstration
purposes. Several countermeasures have been proposed to defend against
Thompson-style backdoors, including the well-known {\it Diverse
Double-Compiling} (DDC) technique, as well as methods like translation
validation and CompCert-style compilation. However, these approaches ultimately
circle back to the fundamental question: "How can we trust the compiler used to
compile the tools we rely on?" In this paper, we introduce a novel approach to
generating certificates to guarantee that a binary image faithfully represents
the source code. These certificates ensure that the binary contains all and
only the statements from the source code, preserves their order, and maintains
equivalent def-use dependencies. The certificate is represented as an integer
derivable from both the source code and the binary using a concise set of
derivation rules, each applied in constant time. To demonstrate the
practicality of our method, we present Charon, a compiler designed to handle a
subset of C expressive enough to compile FaCT, the Flexible and Constant Time
cryptographic programming language.

</details>


### [3] [Controlling Copatterns: There and Back Again (Extended Version)](https://arxiv.org/abs/2508.12427)
*Paul Downen*

Main category: cs.PL

TL;DR: 通过Danvy的力学对应方法，从操作语义到抽象机器再到续体传递风格，两次求寻copatterns的完整语义套件，包括单一性和组合性计算法。


<details>
  <summary>Details</summary>
Motivation: 解决copatterns在函数式编程中虽然提供了灵活的上下文响应机制，但其强大的表达力也给程序行为的精确规范带来了困难。

Method: 采用Danvy的力学对应方法，首先对单一性copatterns进行从小步操作语义到抽象机器再到续体传递风格的求寻，然后在续体传递风格中重构语义得到更通用的组合性copatterns计算法，并逆向求寻得到其他语义产物。

Result: 得到了一套完整的copatterns语义套件，包括单一性和组合性两种计算法的各种语义表示形式。

Conclusion: 通过系统性的力学对应分析，成功为copatterns提供了严格的语义规范，为其在函数式编程中的安全使用奠定了基础。

Abstract: Copatterns give functional programs a flexible mechanism for responding to
their context, and composition can greatly enhance their expressiveness.
However, that same expressive power makes it harder to precisely specify the
behavior of programs. Using Danvy's functional and syntactic correspondence
between different semantic artifacts, we derive a full suite of semantics for
copatterns, twice. First, a calculus of monolithic copatterns is taken on a
journey from small-step operational semantics to abstract machine to
continuation-passing style. Then within continuation-passing style, we refactor
the semantics to derive a more general calculus of compositional copatterns,
and take the return journey back to derive the other semantic artifacts in
reverse order.

</details>


### [4] [Type-Driven Prompt Programming: From Typed Interfaces to a Calculus of Constraints](https://arxiv.org/abs/2508.12475)
*Abhijit Paul*

Main category: cs.PL

TL;DR: 提示编程将大语言模型提示视为具有类型接口的软件组件。基于对2023-2025年15篇文献的调查，发现类型系统是新兴提示编程框架的核心，但在约束表达性和算法支持方面存在不足。提出了Lambda Prompt概念，这是一个具有概率细化的依赖类型演算，用于语法和语义约束。


<details>
  <summary>Details</summary>
Motivation: 解决当前提示编程框架在约束表达能力和算法支持方面的不足，为提示编程建立类型理论基础。

Method: 引入Lambda Prompt概念——一个具有概率细化的依赖类型演算系统，包含13种约束类型，并提出约束保持优化规则。

Result: 提出了一个类型理论框架来形式化提示编程，识别了约束表达性方面的未探索领域（约束9-13），并提出了相应的算法解决方案。

Conclusion: Lambda Prompt为提示编程提供了类型理论基础，指出了未来研究方向，包括开发提示程序编译器。

Abstract: Prompt programming treats large language model prompts as software components
with typed interfaces. Based on a literature survey of 15 recent works from
2023 to 2025, we observe a consistent trend: type systems are central to
emerging prompt programming frameworks. However, there are gaps in constraint
expressiveness and in supporting algorithms. To address these issues, we
introduce the notion of Lambda Prompt, a dependently typed calculus with
probabilistic refinements for syntactic and semantic constraints. While this is
not yet a full calculus, the formulation motivates a type-theoretic foundation
for prompt programming. Our catalog of 13 constraints highlights underexplored
areas in constraint expressiveness (constraints 9 through 13). To address the
algorithmic gap, we propose a constraint-preserving optimization rule. Finally,
we outline research directions on developing a compiler for prompt programs.

</details>
