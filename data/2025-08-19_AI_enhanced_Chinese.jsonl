{"id": "2508.11665", "pdf": "https://arxiv.org/pdf/2508.11665", "abs": "https://arxiv.org/abs/2508.11665", "authors": ["Xinkui Zhao", "Yifan Zhang", "Zhengyi Zhou", "Yueshen Xu"], "title": "StackPilot: Autonomous Function Agents for Scalable and Environment-Free Code Execution", "categories": ["cs.PL", "cs.MA"], "comment": null, "summary": "Recent advances in large language models (LLMs) have substantially enhanced\nautomated code generation across a wide range of programming languages.\nNonetheless, verifying the correctness and executability of LLM-generated code\nremains a significant challenge, as traditional methods rely on\nlanguage-specific compilers and environment-dependent runtimes. To overcome\nthese limitations, we introduce StackPilot, an LLM-native, multi-agent\nframework designed for language-agnostic code verification and execution, which\noperates independently of conventional toolchains. StackPilot offers three\nprincipal innovations: (1) a Function-as-Agents paradigm, in which each\nfunction is modeled as an autonomous agent capable of fine-grained reasoning\nand collaborative verification; (2) an LLM-as-Executor strategy, which enables\nscalable verification via stack-based scheduling; and (3) a novel snapshot\nmechanism that preserves complete execution contexts, facilitating\ndeterministic and lossless context switching during verification. Empirical\nevaluations demonstrate that StackPilot achieves framework reliability rates\nbetween 89% and 97%, substantially outperforming baseline approaches. These\nresults indicate that StackPilot can reliably verify and execute a\nsignificantly larger proportion of LLM-generated code across diverse\nprogramming tasks compared to existing methods.", "AI": {"tldr": "StackPilot\u662f\u4e00\u4e2aLLM\u539f\u751f\u7684\u591a\u667a\u80fd\u4f53\u6846\u67b6\uff0c\u7528\u4e8e\u8bed\u8a00\u65e0\u5173\u7684\u4ee3\u7801\u9a8c\u8bc1\u548c\u6267\u884c\uff0c\u65e0\u9700\u4f20\u7edf\u5de5\u5177\u94fe\uff0c\u901a\u8fc7\u51fd\u6570\u5373\u667a\u80fd\u4f53\u3001LLM\u4f5c\u4e3a\u6267\u884c\u5668\u548c\u5feb\u7167\u673a\u5236\u5b9e\u73b0\u9ad8\u53ef\u9760\u6027\u9a8c\u8bc1\u3002", "motivation": "\u5927\u578b\u8bed\u8a00\u6a21\u578b\u751f\u6210\u7684\u4ee3\u7801\u9a8c\u8bc1\u9762\u4e34\u4f9d\u8d56\u8bed\u8a00\u7279\u5b9a\u7f16\u8bd1\u5668\u548c\u73af\u5883\u8fd0\u884c\u65f6\u7684\u6311\u6218\uff0c\u9700\u8981\u4e00\u79cd\u8bed\u8a00\u65e0\u5173\u7684\u9a8c\u8bc1\u65b9\u6cd5\u6765\u514b\u670d\u8fd9\u4e9b\u9650\u5236\u3002", "method": "\u91c7\u7528\u591a\u667a\u80fd\u4f53\u6846\u67b6\uff0c\u5305\u62ec\uff1a1)\u51fd\u6570\u5373\u667a\u80fd\u4f53\u8303\u5f0f\uff0c\u6bcf\u4e2a\u51fd\u6570\u4f5c\u4e3a\u81ea\u4e3b\u667a\u80fd\u4f53\u8fdb\u884c\u7ec6\u7c92\u5ea6\u63a8\u7406\u548c\u534f\u4f5c\u9a8c\u8bc1\uff1b2)LLM\u4f5c\u4e3a\u6267\u884c\u5668\u7b56\u7565\uff0c\u901a\u8fc7\u57fa\u4e8e\u5806\u6808\u7684\u8c03\u5ea6\u5b9e\u73b0\u53ef\u6269\u5c55\u9a8c\u8bc1\uff1b3)\u5feb\u7167\u673a\u5236\u4fdd\u5b58\u5b8c\u6574\u6267\u884c\u4e0a\u4e0b\u6587\uff0c\u652f\u6301\u786e\u5b9a\u6027\u65e0\u635f\u8017\u4e0a\u4e0b\u6587\u5207\u6362\u3002", "result": "\u5b9e\u8bc1\u8bc4\u4f30\u663e\u793aStackPilot\u8fbe\u523089%-97%\u7684\u6846\u67b6\u53ef\u9760\u6027\u7387\uff0c\u663e\u8457\u4f18\u4e8e\u57fa\u7ebf\u65b9\u6cd5\uff0c\u80fd\u591f\u53ef\u9760\u9a8c\u8bc1\u548c\u6267\u884c\u66f4\u591aLLM\u751f\u6210\u7684\u4ee3\u7801\u3002", "conclusion": "StackPilot\u63d0\u4f9b\u4e86\u4e00\u79cd\u6709\u6548\u7684\u8bed\u8a00\u65e0\u5173\u4ee3\u7801\u9a8c\u8bc1\u89e3\u51b3\u65b9\u6848\uff0c\u5927\u5e45\u63d0\u5347\u4e86LLM\u751f\u6210\u4ee3\u7801\u7684\u53ef\u9a8c\u8bc1\u6027\u548c\u53ef\u6267\u884c\u6027\u3002"}}
{"id": "2508.12054", "pdf": "https://arxiv.org/pdf/2508.12054", "abs": "https://arxiv.org/abs/2508.12054", "authors": ["Guilherme de Oliveira Silva", "Fernando Magno Quint\u00e3o Pereira"], "title": "Certified Compilation based on G\u00f6del Numbers", "categories": ["cs.PL", "11A51", "D.3.1"], "comment": "32 pages, 19 figures", "summary": "In his 1984 Turing Award lecture, Ken Thompson showed that a compiler could\nbe maliciously altered to insert backdoors into programs it compiles and\nperpetuate this behavior by modifying any compiler it subsequently builds.\nThompson's hack has been reproduced in real-world systems for demonstration\npurposes. Several countermeasures have been proposed to defend against\nThompson-style backdoors, including the well-known {\\it Diverse\nDouble-Compiling} (DDC) technique, as well as methods like translation\nvalidation and CompCert-style compilation. However, these approaches ultimately\ncircle back to the fundamental question: \"How can we trust the compiler used to\ncompile the tools we rely on?\" In this paper, we introduce a novel approach to\ngenerating certificates to guarantee that a binary image faithfully represents\nthe source code. These certificates ensure that the binary contains all and\nonly the statements from the source code, preserves their order, and maintains\nequivalent def-use dependencies. The certificate is represented as an integer\nderivable from both the source code and the binary using a concise set of\nderivation rules, each applied in constant time. To demonstrate the\npracticality of our method, we present Charon, a compiler designed to handle a\nsubset of C expressive enough to compile FaCT, the Flexible and Constant Time\ncryptographic programming language.", "AI": {"tldr": "\u63d0\u51fa\u4e00\u79cd\u65b0\u7684\u8bc1\u4e66\u751f\u6210\u65b9\u6cd5\uff0c\u901a\u8fc7\u6574\u6570\u8bc1\u4e66\u6765\u9a8c\u8bc1\u4e8c\u8fdb\u5236\u4ee3\u7801\u662f\u5426\u5fe0\u5b9e\u8868\u793a\u6e90\u4ee3\u7801\uff0c\u786e\u4fdd\u7f16\u8bd1\u8fc7\u7a0b\u7684\u53ef\u4fe1\u6027\u3002", "motivation": "\u89e3\u51b3Ken Thompson\u63d0\u51fa\u7684\u7f16\u8bd1\u5668\u540e\u95e8\u95ee\u9898\uff0c\u73b0\u6709\u9632\u5fa1\u65b9\u6cd5\u5982DDC\u7b49\u4ecd\u7136\u9700\u8981\u4fe1\u4efb\u57fa\u7840\u7f16\u8bd1\u5668\uff0c\u9700\u8981\u4ece\u6839\u672c\u4e0a\u9a8c\u8bc1\u7f16\u8bd1\u8fc7\u7a0b\u7684\u6b63\u786e\u6027\u3002", "method": "\u8bbe\u8ba1\u4e00\u79cd\u8bc1\u4e66\u751f\u6210\u673a\u5236\uff0c\u4ece\u6e90\u4ee3\u7801\u548c\u4e8c\u8fdb\u5236\u4ee3\u7801\u5206\u522b\u63a8\u5bfc\u51fa\u76f8\u540c\u7684\u6574\u6570\u8bc1\u4e66\uff0c\u9a8c\u8bc1\u4e8c\u8fdb\u5236\u5305\u542b\u4e14\u4ec5\u5305\u542b\u6e90\u4ee3\u7801\u8bed\u53e5\u3001\u4fdd\u6301\u987a\u5e8f\u548cdef-use\u4f9d\u8d56\u5173\u7cfb\u3002\u5f00\u53d1Charon\u7f16\u8bd1\u5668\u5904\u7406C\u8bed\u8a00\u5b50\u96c6\u6765\u9a8c\u8bc1\u65b9\u6cd5\u5b9e\u7528\u6027\u3002", "result": "\u63d0\u51fa\u4e86\u53ef\u884c\u7684\u8bc1\u4e66\u9a8c\u8bc1\u6846\u67b6\uff0c\u80fd\u591f\u786e\u4fdd\u4e8c\u8fdb\u5236\u4ee3\u7801\u5fe0\u5b9e\u8868\u793a\u6e90\u4ee3\u7801\uff0c\u89e3\u51b3\u4e86\u7f16\u8bd1\u5668\u4fe1\u4efb\u7684\u6839\u672c\u95ee\u9898\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u63d0\u4f9b\u4e86\u4e00\u79cd\u65b0\u7684\u53ef\u4fe1\u7f16\u8bd1\u9a8c\u8bc1\u9014\u5f84\uff0c\u901a\u8fc7\u6570\u5b66\u8bc1\u4e66\u673a\u5236\u4ece\u6839\u672c\u4e0a\u9632\u5fa1Thompson\u5f0f\u540e\u95e8\u653b\u51fb\uff0c\u5177\u6709\u5b9e\u9645\u5e94\u7528\u4ef7\u503c\u3002"}}
{"id": "2508.12427", "pdf": "https://arxiv.org/pdf/2508.12427", "abs": "https://arxiv.org/abs/2508.12427", "authors": ["Paul Downen"], "title": "Controlling Copatterns: There and Back Again (Extended Version)", "categories": ["cs.PL", "D.3.3; F.3.2; F.3.3"], "comment": "To find the detailed step-by-step process, which serves as their\n  proof of correctness, see https://github.com/pdownen/derive-copat", "summary": "Copatterns give functional programs a flexible mechanism for responding to\ntheir context, and composition can greatly enhance their expressiveness.\nHowever, that same expressive power makes it harder to precisely specify the\nbehavior of programs. Using Danvy's functional and syntactic correspondence\nbetween different semantic artifacts, we derive a full suite of semantics for\ncopatterns, twice. First, a calculus of monolithic copatterns is taken on a\njourney from small-step operational semantics to abstract machine to\ncontinuation-passing style. Then within continuation-passing style, we refactor\nthe semantics to derive a more general calculus of compositional copatterns,\nand take the return journey back to derive the other semantic artifacts in\nreverse order.", "AI": {"tldr": "\u901a\u8fc7Danvy\u7684\u529b\u5b66\u5bf9\u5e94\u65b9\u6cd5\uff0c\u4ece\u64cd\u4f5c\u8bed\u4e49\u5230\u62bd\u8c61\u673a\u5668\u518d\u5230\u7eed\u4f53\u4f20\u9012\u98ce\u683c\uff0c\u4e24\u6b21\u6c42\u5bfbcopatterns\u7684\u5b8c\u6574\u8bed\u4e49\u5957\u4ef6\uff0c\u5305\u62ec\u5355\u4e00\u6027\u548c\u7ec4\u5408\u6027\u8ba1\u7b97\u6cd5\u3002", "motivation": "\u89e3\u51b3copatterns\u5728\u51fd\u6570\u5f0f\u7f16\u7a0b\u4e2d\u867d\u7136\u63d0\u4f9b\u4e86\u7075\u6d3b\u7684\u4e0a\u4e0b\u6587\u54cd\u5e94\u673a\u5236\uff0c\u4f46\u5176\u5f3a\u5927\u7684\u8868\u8fbe\u529b\u4e5f\u7ed9\u7a0b\u5e8f\u884c\u4e3a\u7684\u7cbe\u786e\u89c4\u8303\u5e26\u6765\u4e86\u56f0\u96be\u3002", "method": "\u91c7\u7528Danvy\u7684\u529b\u5b66\u5bf9\u5e94\u65b9\u6cd5\uff0c\u9996\u5148\u5bf9\u5355\u4e00\u6027copatterns\u8fdb\u884c\u4ece\u5c0f\u6b65\u64cd\u4f5c\u8bed\u4e49\u5230\u62bd\u8c61\u673a\u5668\u518d\u5230\u7eed\u4f53\u4f20\u9012\u98ce\u683c\u7684\u6c42\u5bfb\uff0c\u7136\u540e\u5728\u7eed\u4f53\u4f20\u9012\u98ce\u683c\u4e2d\u91cd\u6784\u8bed\u4e49\u5f97\u5230\u66f4\u901a\u7528\u7684\u7ec4\u5408\u6027copatterns\u8ba1\u7b97\u6cd5\uff0c\u5e76\u9006\u5411\u6c42\u5bfb\u5f97\u5230\u5176\u4ed6\u8bed\u4e49\u4ea7\u7269\u3002", "result": "\u5f97\u5230\u4e86\u4e00\u5957\u5b8c\u6574\u7684copatterns\u8bed\u4e49\u5957\u4ef6\uff0c\u5305\u62ec\u5355\u4e00\u6027\u548c\u7ec4\u5408\u6027\u4e24\u79cd\u8ba1\u7b97\u6cd5\u7684\u5404\u79cd\u8bed\u4e49\u8868\u793a\u5f62\u5f0f\u3002", "conclusion": "\u901a\u8fc7\u7cfb\u7edf\u6027\u7684\u529b\u5b66\u5bf9\u5e94\u5206\u6790\uff0c\u6210\u529f\u4e3acopatterns\u63d0\u4f9b\u4e86\u4e25\u683c\u7684\u8bed\u4e49\u89c4\u8303\uff0c\u4e3a\u5176\u5728\u51fd\u6570\u5f0f\u7f16\u7a0b\u4e2d\u7684\u5b89\u5168\u4f7f\u7528\u5960\u5b9a\u4e86\u57fa\u7840\u3002"}}
{"id": "2508.12475", "pdf": "https://arxiv.org/pdf/2508.12475", "abs": "https://arxiv.org/abs/2508.12475", "authors": ["Abhijit Paul"], "title": "Type-Driven Prompt Programming: From Typed Interfaces to a Calculus of Constraints", "categories": ["cs.PL", "cs.FL"], "comment": "Accepted as Extended Abstract in TyDe Workshop 2025,co-located with\n  ICFP", "summary": "Prompt programming treats large language model prompts as software components\nwith typed interfaces. Based on a literature survey of 15 recent works from\n2023 to 2025, we observe a consistent trend: type systems are central to\nemerging prompt programming frameworks. However, there are gaps in constraint\nexpressiveness and in supporting algorithms. To address these issues, we\nintroduce the notion of Lambda Prompt, a dependently typed calculus with\nprobabilistic refinements for syntactic and semantic constraints. While this is\nnot yet a full calculus, the formulation motivates a type-theoretic foundation\nfor prompt programming. Our catalog of 13 constraints highlights underexplored\nareas in constraint expressiveness (constraints 9 through 13). To address the\nalgorithmic gap, we propose a constraint-preserving optimization rule. Finally,\nwe outline research directions on developing a compiler for prompt programs.", "AI": {"tldr": "\u63d0\u793a\u7f16\u7a0b\u5c06\u5927\u8bed\u8a00\u6a21\u578b\u63d0\u793a\u89c6\u4e3a\u5177\u6709\u7c7b\u578b\u63a5\u53e3\u7684\u8f6f\u4ef6\u7ec4\u4ef6\u3002\u57fa\u4e8e\u5bf92023-2025\u5e7415\u7bc7\u6587\u732e\u7684\u8c03\u67e5\uff0c\u53d1\u73b0\u7c7b\u578b\u7cfb\u7edf\u662f\u65b0\u5174\u63d0\u793a\u7f16\u7a0b\u6846\u67b6\u7684\u6838\u5fc3\uff0c\u4f46\u5728\u7ea6\u675f\u8868\u8fbe\u6027\u548c\u7b97\u6cd5\u652f\u6301\u65b9\u9762\u5b58\u5728\u4e0d\u8db3\u3002\u63d0\u51fa\u4e86Lambda Prompt\u6982\u5ff5\uff0c\u8fd9\u662f\u4e00\u4e2a\u5177\u6709\u6982\u7387\u7ec6\u5316\u7684\u4f9d\u8d56\u7c7b\u578b\u6f14\u7b97\uff0c\u7528\u4e8e\u8bed\u6cd5\u548c\u8bed\u4e49\u7ea6\u675f\u3002", "motivation": "\u89e3\u51b3\u5f53\u524d\u63d0\u793a\u7f16\u7a0b\u6846\u67b6\u5728\u7ea6\u675f\u8868\u8fbe\u80fd\u529b\u548c\u7b97\u6cd5\u652f\u6301\u65b9\u9762\u7684\u4e0d\u8db3\uff0c\u4e3a\u63d0\u793a\u7f16\u7a0b\u5efa\u7acb\u7c7b\u578b\u7406\u8bba\u57fa\u7840\u3002", "method": "\u5f15\u5165Lambda Prompt\u6982\u5ff5\u2014\u2014\u4e00\u4e2a\u5177\u6709\u6982\u7387\u7ec6\u5316\u7684\u4f9d\u8d56\u7c7b\u578b\u6f14\u7b97\u7cfb\u7edf\uff0c\u5305\u542b13\u79cd\u7ea6\u675f\u7c7b\u578b\uff0c\u5e76\u63d0\u51fa\u7ea6\u675f\u4fdd\u6301\u4f18\u5316\u89c4\u5219\u3002", "result": "\u63d0\u51fa\u4e86\u4e00\u4e2a\u7c7b\u578b\u7406\u8bba\u6846\u67b6\u6765\u5f62\u5f0f\u5316\u63d0\u793a\u7f16\u7a0b\uff0c\u8bc6\u522b\u4e86\u7ea6\u675f\u8868\u8fbe\u6027\u65b9\u9762\u7684\u672a\u63a2\u7d22\u9886\u57df\uff08\u7ea6\u675f9-13\uff09\uff0c\u5e76\u63d0\u51fa\u4e86\u76f8\u5e94\u7684\u7b97\u6cd5\u89e3\u51b3\u65b9\u6848\u3002", "conclusion": "Lambda Prompt\u4e3a\u63d0\u793a\u7f16\u7a0b\u63d0\u4f9b\u4e86\u7c7b\u578b\u7406\u8bba\u57fa\u7840\uff0c\u6307\u51fa\u4e86\u672a\u6765\u7814\u7a76\u65b9\u5411\uff0c\u5305\u62ec\u5f00\u53d1\u63d0\u793a\u7a0b\u5e8f\u7f16\u8bd1\u5668\u3002"}}
