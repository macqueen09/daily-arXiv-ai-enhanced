<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]
- [cs.LO](#cs.LO) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Tuning Random Generators: Property-Based Testing as Probabilistic Programming](https://arxiv.org/abs/2508.14394)
*Ryan Tjoa,Poorva Garg,Harrison Goldstein,Todd Millstein,Benjamin Pierce,Guy Van den Broeck*

Main category: cs.PL

TL;DR: 本文提出了自动调优属性基测试生成器的方法，通过符号权重和目标函数优化输入分布，实现3.1-7.4倍的bug发现加速


<details>
  <summary>Details</summary>
Motivation: 传统属性基测试中，用户需要手动调整生成器的权重参数来获得理想的测试输入分布，这个过程既繁琐又难以达到预期效果，限制了测试分布的质量和多样性

Method: 开发了Loaded Dice离散概率编程系统，支持符号权重和参数学习。给定带有未确定符号权重的生成器和目标函数，自动学习优化这些权重值以实现目标

Result: 实验证明该方法能有效优化生成器分布，在针对多样性和有效性自动调优后，生成器在bug发现方面表现出3.1-7.4倍的加速效果

Conclusion: 提出的自动调优技术能够显著改善属性基测试的生成器性能，通过优化权重参数实现更好的测试输入分布，大幅提升bug发现效率

Abstract: Property-based testing validates software against an executable specification
by evaluating it on randomly generated inputs. The standard way that PBT users
generate test inputs is via generators that describe how to sample test inputs
through random choices. To achieve a good distribution over test inputs, users
must tune their generators, i.e., decide on the weights of these individual
random choices. Unfortunately, it is very difficult to understand how to choose
individual generator weights in order to achieve a desired distribution, so
today this process is tedious and limits the distributions that can be
practically achieved.
  In this paper, we develop techniques for the automatic and offline tuning of
generators. Given a generator with undetermined symbolic weights and an
objective function, our approach automatically learns values for these weights
that optimize for the objective. We describe useful objective functions that
allow users to (1) target desired distributions and (2) improve the diversity
and validity of their test cases. We have implemented our approach in a novel
discrete probabilistic programming system, Loaded Dice, that supports
differentiation and parameter learning, and use it as a language for
generators. We empirically demonstrate that our approach is effective at
optimizing generator distributions according to the specified objective
functions. We also perform a thorough evaluation on PBT benchmarks,
demonstrating that, when automatically tuned for diversity and validity, the
generators exhibit a 3.1-7.4x speedup in bug finding.

</details>


### [2] [Close is Good Enough: Component-Based Synthesis Modulo Logical Similarity](https://arxiv.org/abs/2508.14614)
*Ashish Mishra,Suresh Jagannathan*

Main category: cs.PL

TL;DR: 该论文提出了一种基于组件合成(CBS)的新方法，通过利用路径间的逻辑相似性来优化搜索过程，使用精化类型规范和限定树自动机来避免探索语义相似的路径。


<details>
  <summary>Details</summary>
Motivation: 传统CBS算法在处理具有精确约束的查询时面临搜索空间稀疏的问题，当库方法具有更丰富的规范时，搜索需要处理仅在少数执行路径上成立的约束，导致效率低下。

Method: 采用精化类型规范来丰富库方法，使用限定树自动机(QTA)变体进行搜索，通过子类型约束对精化类型进行推理，记录枚举项信息并利用路径间的逻辑相似性来避免冗余探索。

Result: 实现了名为\name的工具，综合评估表明该工具能够合成复杂CBS查询的解决方案，其能力远超现有最先进技术。

Conclusion: 通过引入逻辑相似性推理机制，显著提升了CBS在处理精确约束和丰富规范时的搜索效率，为解决复杂合成问题提供了有效方法。

Abstract: Component-based synthesis (CBS) aims to generate loop-free programs from a
set of libraries whose methods are annotated with specifications and whose
output must satisfy a set of logical constraints, expressed as a query. The
effectiveness of a CBS algorithm critically depends on the severity of the
constraints imposed by the query. The more exact these constraints are, the
sparser the space of feasible solutions. This maxim also applies when we enrich
the expressiveness of the specifications affixed to library methods. In both
cases, the search must now contend with constraints that may only hold over a
small number of the possible execution paths that can be enumerated by a CBS
procedure.
  In this paper, we address this challenge by equipping CBS search with the
ability to reason about logical similarities among the paths it explores. Our
setting considers library methods equipped with refinement-type specifications
that enrich ordinary base types with a set of rich logical qualifiers to
constrain the set of values accepted by that type. We perform a search over a
tree automata variant called Qualified Tree Automata that intelligently records
information about enumerated terms, leveraging subtyping constraints over the
refinement types associated with these terms to enable reasoning about
similarity among candidate solutions as search proceeds, thereby avoiding
exploration of semantically similar paths.
  We present an implementation of this idea in a tool called \name, and provide
a comprehensive evaluation that demonstrates \name's ability to synthesize
solutions to complex CBS queries that go well-beyond the capabilities of the
existing state-of-the-art.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [3] [Correct Black-Box Monitors for Distributed Deadlock Detection: Formalisation and Implementation (Technical Report)](https://arxiv.org/abs/2508.14851)
*Radosław Jan Rowicki,Adrian Francalanza,Alceste Scalas*

Main category: cs.LO

TL;DR: 提出了分布式黑盒监控器DDMon，通过观察消息流和交换探测来检测Erlang/OTP等RPC系统中的死锁，无需修改应用代码


<details>
  <summary>Details</summary>
Motivation: 随着并发分布式系统的有机演化和规模增长，死锁风险增加且影响范围扩大，传统诊断方法难以应对分布式环境下的死锁问题

Method: 为每个服务部署分布式黑盒监控器，仅观察进出消息并与其他监控器交换探测信息，基于形式化模型开发监控算法

Result: 证明了算法的正确性（无假阳性和假阴性），实现了DDMon工具并在Erlang/OTP应用中验证性能

Conclusion: 这是首个形式化、证明正确性并实现分布式黑盒死锁检测监控器的工作，为RPC系统提供了有效的死锁检测解决方案

Abstract: Many software applications rely on concurrent and distributed (micro)services
that interact via message-passing and various forms of remote procedure calls
(RPC). As these systems organically evolve and grow in scale and complexity,
the risk of introducing deadlocks increases and their impact may worsen: even
if only a few services deadlock, many other services may block while awaiting
responses from the deadlocked ones. As a result, the "core" of the deadlock can
be obfuscated by its consequences on the rest of the system, and diagnosing and
fixing the problem can be challenging.
  In this work we tackle the challenge by proposing distributed black-box
monitors that are deployed alongside each service and detect deadlocks by only
observing the incoming and outgoing messages, and exchanging probes with other
monitors. We present a formal model that captures popular RPC-based application
styles (e.g., gen_servers in Erlang/OTP), and a distributed black-box
monitoring algorithm that we prove sound and complete (i.e., identifies
deadlocked services with neither false positives nor false negatives). We
implement our results in a tool called DDMon for the monitoring of Erlang/OTP
applications, and we evaluate its performance.
  This is the first work that formalises, proves the correctness, and
implements distributed black-box monitors for deadlock detection. Our results
are mechanised in Coq. DDMon is the companion artifact of this paper.

</details>
