{"id": "2508.14394", "pdf": "https://arxiv.org/pdf/2508.14394", "abs": "https://arxiv.org/abs/2508.14394", "authors": ["Ryan Tjoa", "Poorva Garg", "Harrison Goldstein", "Todd Millstein", "Benjamin Pierce", "Guy Van den Broeck"], "title": "Tuning Random Generators: Property-Based Testing as Probabilistic Programming", "categories": ["cs.PL", "cs.SE", "D.3; D.2.5; G.3"], "comment": "Extended version of OOPSLA '25 paper", "summary": "Property-based testing validates software against an executable specification\nby evaluating it on randomly generated inputs. The standard way that PBT users\ngenerate test inputs is via generators that describe how to sample test inputs\nthrough random choices. To achieve a good distribution over test inputs, users\nmust tune their generators, i.e., decide on the weights of these individual\nrandom choices. Unfortunately, it is very difficult to understand how to choose\nindividual generator weights in order to achieve a desired distribution, so\ntoday this process is tedious and limits the distributions that can be\npractically achieved.\n  In this paper, we develop techniques for the automatic and offline tuning of\ngenerators. Given a generator with undetermined symbolic weights and an\nobjective function, our approach automatically learns values for these weights\nthat optimize for the objective. We describe useful objective functions that\nallow users to (1) target desired distributions and (2) improve the diversity\nand validity of their test cases. We have implemented our approach in a novel\ndiscrete probabilistic programming system, Loaded Dice, that supports\ndifferentiation and parameter learning, and use it as a language for\ngenerators. We empirically demonstrate that our approach is effective at\noptimizing generator distributions according to the specified objective\nfunctions. We also perform a thorough evaluation on PBT benchmarks,\ndemonstrating that, when automatically tuned for diversity and validity, the\ngenerators exhibit a 3.1-7.4x speedup in bug finding.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u81ea\u52a8\u8c03\u4f18\u5c5e\u6027\u57fa\u6d4b\u8bd5\u751f\u6210\u5668\u7684\u65b9\u6cd5\uff0c\u901a\u8fc7\u7b26\u53f7\u6743\u91cd\u548c\u76ee\u6807\u51fd\u6570\u4f18\u5316\u8f93\u5165\u5206\u5e03\uff0c\u5b9e\u73b03.1-7.4\u500d\u7684bug\u53d1\u73b0\u52a0\u901f", "motivation": "\u4f20\u7edf\u5c5e\u6027\u57fa\u6d4b\u8bd5\u4e2d\uff0c\u7528\u6237\u9700\u8981\u624b\u52a8\u8c03\u6574\u751f\u6210\u5668\u7684\u6743\u91cd\u53c2\u6570\u6765\u83b7\u5f97\u7406\u60f3\u7684\u6d4b\u8bd5\u8f93\u5165\u5206\u5e03\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u65e2\u7e41\u7410\u53c8\u96be\u4ee5\u8fbe\u5230\u9884\u671f\u6548\u679c\uff0c\u9650\u5236\u4e86\u6d4b\u8bd5\u5206\u5e03\u7684\u8d28\u91cf\u548c\u591a\u6837\u6027", "method": "\u5f00\u53d1\u4e86Loaded Dice\u79bb\u6563\u6982\u7387\u7f16\u7a0b\u7cfb\u7edf\uff0c\u652f\u6301\u7b26\u53f7\u6743\u91cd\u548c\u53c2\u6570\u5b66\u4e60\u3002\u7ed9\u5b9a\u5e26\u6709\u672a\u786e\u5b9a\u7b26\u53f7\u6743\u91cd\u7684\u751f\u6210\u5668\u548c\u76ee\u6807\u51fd\u6570\uff0c\u81ea\u52a8\u5b66\u4e60\u4f18\u5316\u8fd9\u4e9b\u6743\u91cd\u503c\u4ee5\u5b9e\u73b0\u76ee\u6807", "result": "\u5b9e\u9a8c\u8bc1\u660e\u8be5\u65b9\u6cd5\u80fd\u6709\u6548\u4f18\u5316\u751f\u6210\u5668\u5206\u5e03\uff0c\u5728\u9488\u5bf9\u591a\u6837\u6027\u548c\u6709\u6548\u6027\u81ea\u52a8\u8c03\u4f18\u540e\uff0c\u751f\u6210\u5668\u5728bug\u53d1\u73b0\u65b9\u9762\u8868\u73b0\u51fa3.1-7.4\u500d\u7684\u52a0\u901f\u6548\u679c", "conclusion": "\u63d0\u51fa\u7684\u81ea\u52a8\u8c03\u4f18\u6280\u672f\u80fd\u591f\u663e\u8457\u6539\u5584\u5c5e\u6027\u57fa\u6d4b\u8bd5\u7684\u751f\u6210\u5668\u6027\u80fd\uff0c\u901a\u8fc7\u4f18\u5316\u6743\u91cd\u53c2\u6570\u5b9e\u73b0\u66f4\u597d\u7684\u6d4b\u8bd5\u8f93\u5165\u5206\u5e03\uff0c\u5927\u5e45\u63d0\u5347bug\u53d1\u73b0\u6548\u7387"}}
{"id": "2508.14614", "pdf": "https://arxiv.org/pdf/2508.14614", "abs": "https://arxiv.org/abs/2508.14614", "authors": ["Ashish Mishra", "Suresh Jagannathan"], "title": "Close is Good Enough: Component-Based Synthesis Modulo Logical Similarity", "categories": ["cs.PL", "D.3.0; D.3.1"], "comment": null, "summary": "Component-based synthesis (CBS) aims to generate loop-free programs from a\nset of libraries whose methods are annotated with specifications and whose\noutput must satisfy a set of logical constraints, expressed as a query. The\neffectiveness of a CBS algorithm critically depends on the severity of the\nconstraints imposed by the query. The more exact these constraints are, the\nsparser the space of feasible solutions. This maxim also applies when we enrich\nthe expressiveness of the specifications affixed to library methods. In both\ncases, the search must now contend with constraints that may only hold over a\nsmall number of the possible execution paths that can be enumerated by a CBS\nprocedure.\n  In this paper, we address this challenge by equipping CBS search with the\nability to reason about logical similarities among the paths it explores. Our\nsetting considers library methods equipped with refinement-type specifications\nthat enrich ordinary base types with a set of rich logical qualifiers to\nconstrain the set of values accepted by that type. We perform a search over a\ntree automata variant called Qualified Tree Automata that intelligently records\ninformation about enumerated terms, leveraging subtyping constraints over the\nrefinement types associated with these terms to enable reasoning about\nsimilarity among candidate solutions as search proceeds, thereby avoiding\nexploration of semantically similar paths.\n  We present an implementation of this idea in a tool called \\name, and provide\na comprehensive evaluation that demonstrates \\name's ability to synthesize\nsolutions to complex CBS queries that go well-beyond the capabilities of the\nexisting state-of-the-art.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u7ec4\u4ef6\u5408\u6210(CBS)\u7684\u65b0\u65b9\u6cd5\uff0c\u901a\u8fc7\u5229\u7528\u8def\u5f84\u95f4\u7684\u903b\u8f91\u76f8\u4f3c\u6027\u6765\u4f18\u5316\u641c\u7d22\u8fc7\u7a0b\uff0c\u4f7f\u7528\u7cbe\u5316\u7c7b\u578b\u89c4\u8303\u548c\u9650\u5b9a\u6811\u81ea\u52a8\u673a\u6765\u907f\u514d\u63a2\u7d22\u8bed\u4e49\u76f8\u4f3c\u7684\u8def\u5f84\u3002", "motivation": "\u4f20\u7edfCBS\u7b97\u6cd5\u5728\u5904\u7406\u5177\u6709\u7cbe\u786e\u7ea6\u675f\u7684\u67e5\u8be2\u65f6\u9762\u4e34\u641c\u7d22\u7a7a\u95f4\u7a00\u758f\u7684\u95ee\u9898\uff0c\u5f53\u5e93\u65b9\u6cd5\u5177\u6709\u66f4\u4e30\u5bcc\u7684\u89c4\u8303\u65f6\uff0c\u641c\u7d22\u9700\u8981\u5904\u7406\u4ec5\u5728\u5c11\u6570\u6267\u884c\u8def\u5f84\u4e0a\u6210\u7acb\u7684\u7ea6\u675f\uff0c\u5bfc\u81f4\u6548\u7387\u4f4e\u4e0b\u3002", "method": "\u91c7\u7528\u7cbe\u5316\u7c7b\u578b\u89c4\u8303\u6765\u4e30\u5bcc\u5e93\u65b9\u6cd5\uff0c\u4f7f\u7528\u9650\u5b9a\u6811\u81ea\u52a8\u673a(QTA)\u53d8\u4f53\u8fdb\u884c\u641c\u7d22\uff0c\u901a\u8fc7\u5b50\u7c7b\u578b\u7ea6\u675f\u5bf9\u7cbe\u5316\u7c7b\u578b\u8fdb\u884c\u63a8\u7406\uff0c\u8bb0\u5f55\u679a\u4e3e\u9879\u4fe1\u606f\u5e76\u5229\u7528\u8def\u5f84\u95f4\u7684\u903b\u8f91\u76f8\u4f3c\u6027\u6765\u907f\u514d\u5197\u4f59\u63a2\u7d22\u3002", "result": "\u5b9e\u73b0\u4e86\u540d\u4e3a\\name\u7684\u5de5\u5177\uff0c\u7efc\u5408\u8bc4\u4f30\u8868\u660e\u8be5\u5de5\u5177\u80fd\u591f\u5408\u6210\u590d\u6742CBS\u67e5\u8be2\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u5176\u80fd\u529b\u8fdc\u8d85\u73b0\u6709\u6700\u5148\u8fdb\u6280\u672f\u3002", "conclusion": "\u901a\u8fc7\u5f15\u5165\u903b\u8f91\u76f8\u4f3c\u6027\u63a8\u7406\u673a\u5236\uff0c\u663e\u8457\u63d0\u5347\u4e86CBS\u5728\u5904\u7406\u7cbe\u786e\u7ea6\u675f\u548c\u4e30\u5bcc\u89c4\u8303\u65f6\u7684\u641c\u7d22\u6548\u7387\uff0c\u4e3a\u89e3\u51b3\u590d\u6742\u5408\u6210\u95ee\u9898\u63d0\u4f9b\u4e86\u6709\u6548\u65b9\u6cd5\u3002"}}
{"id": "2508.14851", "pdf": "https://arxiv.org/pdf/2508.14851", "abs": "https://arxiv.org/abs/2508.14851", "authors": ["Rados\u0142aw Jan Rowicki", "Adrian Francalanza", "Alceste Scalas"], "title": "Correct Black-Box Monitors for Distributed Deadlock Detection: Formalisation and Implementation (Technical Report)", "categories": ["cs.LO", "cs.PL"], "comment": null, "summary": "Many software applications rely on concurrent and distributed (micro)services\nthat interact via message-passing and various forms of remote procedure calls\n(RPC). As these systems organically evolve and grow in scale and complexity,\nthe risk of introducing deadlocks increases and their impact may worsen: even\nif only a few services deadlock, many other services may block while awaiting\nresponses from the deadlocked ones. As a result, the \"core\" of the deadlock can\nbe obfuscated by its consequences on the rest of the system, and diagnosing and\nfixing the problem can be challenging.\n  In this work we tackle the challenge by proposing distributed black-box\nmonitors that are deployed alongside each service and detect deadlocks by only\nobserving the incoming and outgoing messages, and exchanging probes with other\nmonitors. We present a formal model that captures popular RPC-based application\nstyles (e.g., gen_servers in Erlang/OTP), and a distributed black-box\nmonitoring algorithm that we prove sound and complete (i.e., identifies\ndeadlocked services with neither false positives nor false negatives). We\nimplement our results in a tool called DDMon for the monitoring of Erlang/OTP\napplications, and we evaluate its performance.\n  This is the first work that formalises, proves the correctness, and\nimplements distributed black-box monitors for deadlock detection. Our results\nare mechanised in Coq. DDMon is the companion artifact of this paper.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u5206\u5e03\u5f0f\u9ed1\u76d2\u76d1\u63a7\u5668DDMon\uff0c\u901a\u8fc7\u89c2\u5bdf\u6d88\u606f\u6d41\u548c\u4ea4\u6362\u63a2\u6d4b\u6765\u68c0\u6d4bErlang/OTP\u7b49RPC\u7cfb\u7edf\u4e2d\u7684\u6b7b\u9501\uff0c\u65e0\u9700\u4fee\u6539\u5e94\u7528\u4ee3\u7801", "motivation": "\u968f\u7740\u5e76\u53d1\u5206\u5e03\u5f0f\u7cfb\u7edf\u7684\u6709\u673a\u6f14\u5316\u548c\u89c4\u6a21\u589e\u957f\uff0c\u6b7b\u9501\u98ce\u9669\u589e\u52a0\u4e14\u5f71\u54cd\u8303\u56f4\u6269\u5927\uff0c\u4f20\u7edf\u8bca\u65ad\u65b9\u6cd5\u96be\u4ee5\u5e94\u5bf9\u5206\u5e03\u5f0f\u73af\u5883\u4e0b\u7684\u6b7b\u9501\u95ee\u9898", "method": "\u4e3a\u6bcf\u4e2a\u670d\u52a1\u90e8\u7f72\u5206\u5e03\u5f0f\u9ed1\u76d2\u76d1\u63a7\u5668\uff0c\u4ec5\u89c2\u5bdf\u8fdb\u51fa\u6d88\u606f\u5e76\u4e0e\u5176\u4ed6\u76d1\u63a7\u5668\u4ea4\u6362\u63a2\u6d4b\u4fe1\u606f\uff0c\u57fa\u4e8e\u5f62\u5f0f\u5316\u6a21\u578b\u5f00\u53d1\u76d1\u63a7\u7b97\u6cd5", "result": "\u8bc1\u660e\u4e86\u7b97\u6cd5\u7684\u6b63\u786e\u6027\uff08\u65e0\u5047\u9633\u6027\u548c\u5047\u9634\u6027\uff09\uff0c\u5b9e\u73b0\u4e86DDMon\u5de5\u5177\u5e76\u5728Erlang/OTP\u5e94\u7528\u4e2d\u9a8c\u8bc1\u6027\u80fd", "conclusion": "\u8fd9\u662f\u9996\u4e2a\u5f62\u5f0f\u5316\u3001\u8bc1\u660e\u6b63\u786e\u6027\u5e76\u5b9e\u73b0\u5206\u5e03\u5f0f\u9ed1\u76d2\u6b7b\u9501\u68c0\u6d4b\u76d1\u63a7\u5668\u7684\u5de5\u4f5c\uff0c\u4e3aRPC\u7cfb\u7edf\u63d0\u4f9b\u4e86\u6709\u6548\u7684\u6b7b\u9501\u68c0\u6d4b\u89e3\u51b3\u65b9\u6848"}}
