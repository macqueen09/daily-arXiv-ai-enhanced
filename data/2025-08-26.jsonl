{"id": "2508.16746", "pdf": "https://arxiv.org/pdf/2508.16746", "abs": "https://arxiv.org/abs/2508.16746", "authors": ["Karuna Grewal", "P. Brighten Godfrey", "Justin Hsu"], "title": "SafeTree: Expressive Tree Policies for Microservices", "categories": ["cs.PL"], "comment": null, "summary": "A microservice-based application is composed of multiple self-contained\ncomponents called microservices, and controlling inter-service communication is\nimportant for enforcing safety properties. Presently, inter-service\ncommunication is configured using microservice deployment tools. However, such\ntools only support a limited class of single-hop policies, which can be overly\npermissive because they ignore the rich service tree structure of microservice\ncalls. Policies that can express the service tree structure can offer\ndevelopment and security teams more fine-grained control over communication\npatterns.\n  To this end, we design an expressive policy language to specify service tree\nstructures, and we develop a visibly pushdown automata-based dynamic\nenforcement mechanism to enforce service tree policies. Our technique is\nnon-invasive: it does not require any changes to service implementations, and\ndoes not require access to microservice code. To realize our method, we build a\nruntime monitor on top of a service mesh, an emerging network infrastructure\nlayer that can control inter-service communication during deployment. In\nparticular, we employ the programmable network traffic filtering capabilities\nof Istio, a popular service mesh implementation, to implement an online and\ndistributed monitor. Our experiments show that our monitor can enforce rich\nsafety properties while adding minimal latency overhead on the order of\nmilliseconds."}
{"id": "2508.16848", "pdf": "https://arxiv.org/pdf/2508.16848", "abs": "https://arxiv.org/abs/2508.16848", "authors": ["David Moon", "Andrew Blinn", "Thomas J. Porter", "Cyrus Omar"], "title": "Syntactic Completions with Material Obligations", "categories": ["cs.PL"], "comment": null, "summary": "Code editors provide essential services that help developers understand,\nnavigate, and modify programs. However, these services often fail in the\npresence of syntax errors. Existing syntax error recovery techniques, like\npanic mode and multi-option repairs, are either too coarse, e.g. in deleting\nlarge swathes of code, or lead to a proliferation of possible completions. This\npaper introduces $\\texttt{tylr}$, a parser and editor generator that completes\narbitrarily malformed code by inserting obligations, which generalize holes to\ncover missing operands, operators, mixfix keywords, and sort transitions.\n$\\texttt{tylr}$ is backed by a novel theory of tile-based parsing, which\nextends operator-precedence parsing in two ways. First, traditional token\nprecedence comparisons are replaced by a notion of grammar walks, which form\nthe basis for generating obligations. Second, a distinct \"molding\" system based\non grammar zippers expand grammar expressivity by allowing the system to\ndisambiguate between possible parses and completions based on an obligation\nminimization criterion. In addition to serving as a novel approach to error\ncorrection, $\\texttt{tylr}$'s design enables the development of an editor that\nvisually materializes obligations to the human user, serving as a novel hybrid\nbetween a text editor and a structure editor. We introduce $\\texttt{tylr}$ by\nexample, then formalize its key ideas. Finally, we conduct a human subjects\nstudy to evaluate the extent to which an editor like $\\texttt{tylr}$ that\nmaterializes syntactic obligations might be usable and useful, finding both\npoints of positivity and interesting new avenues for future work."}
{"id": "2508.17190", "pdf": "https://arxiv.org/pdf/2508.17190", "abs": "https://arxiv.org/abs/2508.17190", "authors": ["Bonan Su", "Li Zhou", "Yuan Feng", "Mingsheng Ying"], "title": "Borrowing Dirty Qubits in Quantum Programs", "categories": ["quant-ph", "cs.PL"], "comment": null, "summary": "Dirty qubits are ancillary qubits that can be borrowed from idle parts of a\ncomputation, enabling qubit reuse and reducing the demand for fresh, clean\nqubits-a resource that is typically scarce in practice. For such reuse to be\nvalid, the initial states of the dirty qubits must not affect the functionality\nof the quantum circuits in which they are employed. Moreover, their original\nstates, including any entanglement they possess, must be fully restored after\nuse-a requirement commonly known as safe uncomputation. In this paper, we\nformally define the semantics of dirty-qubit borrowing as a feature in quantum\nprogramming languages, and introduce a notion of safe uncomputation for dirty\nqubits in quantum programs. We also present an efficient algorithm, along with\nexperimental results, for verifying safe uncomputation of dirty qubits in\ncertain quantum circuits."}
{"id": "2508.17344", "pdf": "https://arxiv.org/pdf/2508.17344", "abs": "https://arxiv.org/abs/2508.17344", "authors": ["Rajrupa Chattaraj", "Sridhar Chimalakonda", "Vibhu Saujanya Sharma", "Vikrant Kaulgud"], "title": "Who Wins the Race? (R Vs Python) - An Exploratory Study on Energy Consumption of Machine Learning Algorithms", "categories": ["cs.SE", "cs.LG", "cs.PF", "cs.PL"], "comment": "18 pages including references, 5 figures", "summary": "The utilization of Machine Learning (ML) in contemporary software systems is\nextensive and continually expanding. However, its usage is energy-intensive,\ncontributing to increased carbon emissions and demanding significant resources.\nWhile numerous studies examine the performance and accuracy of ML, only a\nlimited few focus on its environmental aspects, particularly energy\nconsumption. In addition, despite emerging efforts to compare energy\nconsumption across various programming languages for specific algorithms and\ntasks, there remains a gap specifically in comparing these languages for\nML-based tasks. This paper aims to raise awareness of the energy costs\nassociated with employing different programming languages for ML model training\nand inference. Through this empirical study, we measure and compare the energy\nconsumption along with run-time performance of five regression and five\nclassification tasks implemented in Python and R, the two most popular\nprogramming languages in this context. Our study results reveal a statistically\nsignificant difference in costs between the two languages in 95% of the cases\nexamined. Furthermore, our analysis demonstrates that the choice of programming\nlanguage can influence energy efficiency significantly, up to 99.16% during\nmodel training and up to 99.8% during inferences, for a given ML task."}
{"id": "2508.17568", "pdf": "https://arxiv.org/pdf/2508.17568", "abs": "https://arxiv.org/abs/2508.17568", "authors": ["Liane Makatura", "Benjamin Jones", "Siyuan Bian", "Wojciech Matusik"], "title": "MetaGen: A DSL, Database, and Benchmark for VLM-Assisted Metamaterial Generation", "categories": ["cs.CV", "cs.AI", "cs.CE", "cs.LG", "cs.PL"], "comment": null, "summary": "Metamaterials are micro-architected structures whose geometry imparts highly\ntunable-often counter-intuitive-bulk properties. Yet their design is difficult\nbecause of geometric complexity and a non-trivial mapping from architecture to\nbehaviour. We address these challenges with three complementary contributions.\n(i) MetaDSL: a compact, semantically rich domain-specific language that\ncaptures diverse metamaterial designs in a form that is both human-readable and\nmachine-parsable. (ii) MetaDB: a curated repository of more than 150,000\nparameterized MetaDSL programs together with their\nderivatives-three-dimensional geometry, multi-view renderings, and simulated\nelastic properties. (iii) MetaBench: benchmark suites that test three core\ncapabilities of vision-language metamaterial assistants-structure\nreconstruction, property-driven inverse design, and performance prediction. We\nestablish baselines by fine-tuning state-of-the-art vision-language models and\ndeploy an omni-model within an interactive, CAD-like interface. Case studies\nshow that our framework provides a strong first step toward integrated design\nand understanding of structure-representation-property relationships."}
{"id": "2508.18115", "pdf": "https://arxiv.org/pdf/2508.18115", "abs": "https://arxiv.org/abs/2508.18115", "authors": ["Quang Loc Le"], "title": "Compositional Verification in Concurrent Separation Logic with Permissions Regions", "categories": ["cs.LO", "cs.PL"], "comment": null, "summary": "Concurrent separation logic with fractional permissions (CSLPerm) provides a\npromising reasoning system to verify most complex sequential and concurrent\nfine-grained programs. The logic with strong and weak separating conjunctions\noffers a solid foundation for producing concise and precise proofs. However, it\nlacks automation and compositionality support. This paper addresses this\nlimitation by introducing a compositional verification system for concurrent\nprograms that manipulate regions of shared memory. The centre of our system is\nnovel logical principles and an entailment procedure that can infer the\nresidual heaps in the frame rule for a fragment of CSL-Perm with explicit\narithmetical constraints for memory heaps' disjointness. This procedure enables\nthe compositional reasoning for concurrent threads and function calls. We have\nimplemented the proposal in a prototype tool called CoSl, tested it with 10\nchallenging concurrent programs, including those beyond the state-of-the-art,\nand confirmed the advantage of our approach."}
{"id": "2508.18231", "pdf": "https://arxiv.org/pdf/2508.18231", "abs": "https://arxiv.org/abs/2508.18231", "authors": ["Anjo Seidel", "Sarah Winkler", "Alessandro Gianola", "Marco Montali", "Mathias Weske"], "title": "To bind or not to bind? Discovering Stable Relationships in Object-centric Processes (Extended Version)", "categories": ["cs.LO", "cs.MA", "cs.PL"], "comment": null, "summary": "Object-centric process mining investigates the intertwined behavior of\nmultiple objects in business processes. From object-centric event logs,\nobject-centric Petri nets (OCPN) can be discovered to replay the behavior of\nprocesses accessing different object types. Although they indicate how objects\nflow through the process and co-occur in events, OCPNs remain underspecified\nabout the relationships of objects. Hence, they are not able to represent\nsynchronization, i.e. executing objects only according to their intended\nrelationships, and fail to identify violating executions. Existing formal\nmodeling approaches, such as object-centric Petri nets with identifiers (OPID),\nrepresent object identities and relationships to synchronize them correctly.\nHowever, OPID discovery has not yet been studied. This paper uses explicit data\nmodels to bridge the gap between OCPNs and formal OPIDs. We identify the\nimplicit assumptions of stable many-to-one relationships in object-centric\nevent logs, which implies synchronization of related objects. To formally\nunderpin this observation, we combine OCPNs with explicit stable many-to-one\nrelationships in a rigorous mapping from OCPNs to OPIDs explicitly capturing\nthe intended stable relationships and the synchronization of related objects.\nWe prove that the original OCPNs and the resulting OPIDs coincide for those\nexecutions that satisfy the intended relationships. Moreover, we provide an\nimplementation of the mapping from OCPN to OPID under stable relationships."}
