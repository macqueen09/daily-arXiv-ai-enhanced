{"id": "2508.19558", "pdf": "https://arxiv.org/pdf/2508.19558", "abs": "https://arxiv.org/abs/2508.19558", "authors": ["Zhuohao Li", "Wenqing Chen", "Jianxing Yu", "Zhichao Lu"], "title": "Functional Consistency of LLM Code Embeddings: A Self-Evolving Data Synthesis Framework for Benchmarking", "categories": ["cs.SE", "cs.CL", "cs.PL"], "comment": null, "summary": "Embedding models have demonstrated strong performance in tasks like\nclustering, retrieval, and feature extraction while offering computational\nadvantages over generative models and cross-encoders. Benchmarks such as MTEB\nhave shown that text embeddings from large language models (LLMs) capture rich\nsemantic information, but their ability to reflect code-level functional\nsemantics remains unclear. Existing studies largely focus on code clone\ndetection, which emphasizes syntactic similarity and overlooks functional\nunderstanding. In this paper, we focus on the functional consistency of LLM\ncode embeddings, which determines if two code snippets perform the same\nfunction regardless of syntactic differences. We propose a novel data synthesis\nframework called Functionality-Oriented Code Self-Evolution to construct\ndiverse and challenging benchmarks. Specifically, we define code examples\nacross four semantic and syntactic categories and find that existing datasets\npredominantly capture syntactic properties. Our framework generates four unique\nvariations from a single code instance, providing a broader spectrum of code\nexamples that better reflect functional differences. Extensive experiments on\nthree downstream tasks-code clone detection, code functional consistency\nidentification, and code retrieval-demonstrate that embedding models\nsignificantly improve their performance when trained on our evolved datasets.\nThese results highlight the effectiveness and generalization of our data\nsynthesis framework, advancing the functional understanding of code.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u9762\u5411\u529f\u80fd\u7684\u4ee3\u7801\u81ea\u8fdb\u5316\u6846\u67b6\uff0c\u7528\u4e8e\u6784\u5efa\u591a\u6837\u5316\u7684\u4ee3\u7801\u529f\u80fd\u8bed\u4e49\u57fa\u51c6\u6d4b\u8bd5\uff0c\u901a\u8fc7\u5b9e\u9a8c\u8bc1\u660e\u8be5\u6846\u67b6\u80fd\u663e\u8457\u63d0\u5347\u5d4c\u5165\u6a21\u578b\u5728\u4ee3\u7801\u514b\u9686\u68c0\u6d4b\u3001\u529f\u80fd\u4e00\u81f4\u6027\u8bc6\u522b\u548c\u4ee3\u7801\u68c0\u7d22\u7b49\u4efb\u52a1\u4e2d\u7684\u6027\u80fd\u3002", "motivation": "\u73b0\u6709\u7814\u7a76\u4e3b\u8981\u5173\u6ce8\u4ee3\u7801\u514b\u9686\u68c0\u6d4b\uff0c\u5f3a\u8c03\u8bed\u6cd5\u76f8\u4f3c\u6027\u800c\u5ffd\u89c6\u4e86\u529f\u80fd\u7406\u89e3\u3002\u5927\u578b\u8bed\u8a00\u6a21\u578b\u7684\u6587\u672c\u5d4c\u5165\u867d\u7136\u80fd\u6355\u83b7\u4e30\u5bcc\u7684\u8bed\u4e49\u4fe1\u606f\uff0c\u4f46\u5176\u53cd\u6620\u4ee3\u7801\u7ea7\u529f\u80fd\u8bed\u4e49\u7684\u80fd\u529b\u5c1a\u4e0d\u660e\u786e\u3002", "method": "\u63d0\u51fa\u4e86Functionality-Oriented Code Self-Evolution\u6570\u636e\u5408\u6210\u6846\u67b6\uff0c\u4ece\u5355\u4e2a\u4ee3\u7801\u5b9e\u4f8b\u751f\u6210\u56db\u79cd\u72ec\u7279\u7684\u53d8\u4f53\uff0c\u6784\u5efa\u66f4\u5e7f\u6cdb\u53cd\u6620\u529f\u80fd\u5dee\u5f02\u7684\u4ee3\u7801\u793a\u4f8b\u3002\u5b9a\u4e49\u4e86\u56db\u4e2a\u8bed\u4e49\u548c\u8bed\u6cd5\u7c7b\u522b\u7684\u4ee3\u7801\u793a\u4f8b\u3002", "result": "\u5728\u4e09\u4e2a\u4e0b\u6e38\u4efb\u52a1\uff08\u4ee3\u7801\u514b\u9686\u68c0\u6d4b\u3001\u4ee3\u7801\u529f\u80fd\u4e00\u81f4\u6027\u8bc6\u522b\u548c\u4ee3\u7801\u68c0\u7d22\uff09\u4e0a\u7684\u5927\u91cf\u5b9e\u9a8c\u8868\u660e\uff0c\u4f7f\u7528\u8fdb\u5316\u6570\u636e\u96c6\u8bad\u7ec3\u7684\u5d4c\u5165\u6a21\u578b\u6027\u80fd\u663e\u8457\u63d0\u5347\u3002", "conclusion": "\u8be5\u6570\u636e\u5408\u6210\u6846\u67b6\u5728\u63d0\u5347\u4ee3\u7801\u529f\u80fd\u7406\u89e3\u65b9\u9762\u5177\u6709\u6709\u6548\u6027\u548c\u6cdb\u5316\u80fd\u529b\uff0c\u63a8\u52a8\u4e86\u4ee3\u7801\u529f\u80fd\u8bed\u4e49\u7406\u89e3\u7684\u53d1\u5c55\u3002"}}
