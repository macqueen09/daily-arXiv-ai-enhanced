<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]
- [cs.SE](#cs.SE) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Solvable Tuple Patterns and Their Applications to Program Verification](https://arxiv.org/abs/2508.20365)
*Naoki Kobayashi,Ryosuke Sato,Ayumi Shinohara,Ryo Yoshinaka*

Main category: cs.PL

TL;DR: 提出了可解元组模式(STP)的概念，用于表达列表式递归数据结构的程序不变量，无需负样本即可从少量正样本高效推断，并集成到CHC求解器中实现自动化程序验证


<details>
  <summary>Details</summary>
Motivation: 尽管程序验证技术有所进展，但完全自动化验证操作递归数据结构的程序仍然是一个挑战，特别是需要高效推断程序不变量

Method: 引入可解元组模式(STP)表达数据结构间的不变量关系，设计STP推断算法仅需正样本，利用支持序列理论的SMT求解器验证推断的STP是否为归纳不变量，并将STP推断集成到支持列表式数据结构的CHC求解器中

Result: 集成STP推断的CHC求解器在CHC-COMP 2025的ADT-LIN类别中以显著优势获胜

Conclusion: STP方法能够有效解决递归数据结构的自动化程序验证问题，仅需少量正样本即可高效推断不变量，为自动化程序验证工具提供了统一的后端解决方案

Abstract: Despite the recent progress of automated program verification techniques,
fully automated verification of programs manipulating recursive data structures
remains a challenge. We introduce the notion of solvable tuple patterns (STPs)
to express invariants between list-like recursive data structures. A
distinguishing feature of STPs is that they can be efficiently inferred from
only a small number of positive samples; no negative samples are required. An
SMT solver that supports the sequence theory can be used to check that an
inferred STP is indeed an inductive invariant. After presenting basic
properties of STPs and an STP inference algorithm, we show how to incorporate
the STP inference into a CHC (Constrained Horn Clauses) solver supporting
list-like data structures, which serves as a uniform backend for automated
program verification tools. A CHC solver incorporating the STP inference has
won the ADT-LIN category of CHC-COMP 2025 by a big margin.

</details>


### [2] [Static Factorisation of Probabilistic Programs With User-Labelled Sample Statements and While Loops](https://arxiv.org/abs/2508.20922)
*Markus Böck,Jürgen Cito*

Main category: cs.PL

TL;DR: 该研究解决了概率程序与贝叶斯网络之间的双向表示问题，提出了支持循环和动态标签的概率程序的图形化表示方法，并开发了基于程序切片的三类优化技术。


<details>
  <summary>Details</summary>
Motivation: 虽然贝叶斯网络可以表示为概率程序，但具有循环和动态标签的概率程序如何图形化表示仍是一个开放性问题。现有方法无法处理包含while循环和用户标记采样语句的程序。

Method: 扩展操作语义以支持语言特性，通过控制流图转换程序，定义静态分析来近似程序中的随机变量依赖结构，获得静态因子分解表示，并开发程序切片技术。

Result: 获得了无循环和常量标签程序的贝叶斯网络等价因子分解，以及定义无限随机变量程序的新图形表示。优化技术在变分推理、Metropolis Hastings和顺序蒙特卡洛中表现优异。

Conclusion: 该工作为具有复杂控制流的概率程序提供了系统的图形化表示框架，并证明了基于该框架的优化技术在理论和实证上都优于现有方法。

Abstract: It is commonly known that any Bayesian network can be implemented as a
probabilistic program, but the reverse direction is not so clear. In this work,
we address the open question to what extent a probabilistic program with
user-labelled sample statements and while loops - features found in languages
like Gen, Turing, and Pyro - can be represented graphically. To this end, we
extend existing operational semantics to support these language features. By
translating a program to its control-flow graph, we define a sound static
analysis that approximates the dependency structure of the random variables in
the program. As a result, we obtain a static factorisation of the implicitly
defined program density, which is equivalent to the known Bayesian network
factorisation for programs without loops and constant labels, but constitutes a
novel graphical representation for programs that define an unbounded number of
random variables via loops or dynamic labels. We further develop a sound
program slicing technique to leverage this structure to statically enable three
well-known optimisations for the considered program class: we reduce the
variance of gradient estimates in variational inference and we speed up both
single-site Metropolis Hastings and sequential Monte Carlo. These optimisations
are proven correct and empirically shown to match or outperform existing
techniques.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [3] [Boosting Skeleton-Driven SMT Solver Fuzzing by Leveraging LLM to Produce Formula Generators](https://arxiv.org/abs/2508.20340)
*Maolin Sun,Yibiao Yang,Yuming Zhou*

Main category: cs.SE

TL;DR: Chimera是一个基于LLM的SMT求解器模糊测试框架，通过生成可重用的项生成器而非直接生成公式，解决了现有方法中语法无效和计算开销大的问题，在Z3和cvc5中发现了43个已确认的bug。


<details>
  <summary>Details</summary>
Motivation: SMT求解器在现代系统和编程语言研究中至关重要，但其正确性测试面临挑战。现有测试技术难以跟上求解器快速发展的特性，而基于LLM的方法存在语法无效和计算开销大的问题。

Method: Chimera框架使用LLM：(1)从文档中自动提取SMT理论的上下文无关文法；(2)合成符合这些文法的可组合布尔项生成器。在模糊测试时，用LLM合成的生成器产生的项填充现有公式的结构骨架。

Result: 在Z3和cvc5两个主流SMT求解器上评估，Chimera发现了43个已确认的bug，其中40个已被开发者修复。

Conclusion: Chimera通过转向生成可重用的项生成器而非直接生成公式，确保了语法有效性并提高了语义多样性，同时大幅降低了运行时成本，只需一次LLM交互投资。

Abstract: Satisfiability Modulo Theory (SMT) solvers are foundational to modern systems
and programming languages research, providing the foundation for tasks like
symbolic execution and automated verification. Because these solvers sit on the
critical path, their correctness is essential, and high-quality test formulas
are key to uncovering bugs. However, while prior testing techniques performed
well on earlier solver versions, they struggle to keep pace with rapidly
evolving features. Recent approaches based on Large Language Models (LLMs) show
promise in exploring advanced solver capabilities, but two obstacles remain:
nearly half of the generated formulas are syntactically invalid, and iterative
interactions with the LLMs introduce substantial computational overhead. In
this study, we present Chimera, a novel LLM-assisted fuzzing framework that
addresses both issues by shifting from direct formula generation to the
synthesis of reusable term (i.e., logical expression) generators. Particularly,
Chimera uses LLMs to (1) automatically extract context-free grammars (CFGs) for
SMT theories, including solver-specific extensions, from documentation, and (2)
synthesize composable Boolean term generators that adhere to these grammars.
During fuzzing, Chimera populates structural skeletons derived from existing
formulas with the terms iteratively produced by the LLM-synthesized generators.
This design ensures syntactic validity while promoting semantic diversity.
Notably, Chimera requires only one-time LLM interaction investment,
dramatically reducing runtime cost. We evaluated Chimera on two leading SMT
solvers: Z3 and cvc5. Our experiments show that Chimera has identified 43
confirmed bugs, 40 of which have already been fixed by developers.

</details>
