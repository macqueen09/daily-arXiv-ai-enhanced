{"id": "2508.20365", "pdf": "https://arxiv.org/pdf/2508.20365", "abs": "https://arxiv.org/abs/2508.20365", "authors": ["Naoki Kobayashi", "Ryosuke Sato", "Ayumi Shinohara", "Ryo Yoshinaka"], "title": "Solvable Tuple Patterns and Their Applications to Program Verification", "categories": ["cs.PL"], "comment": null, "summary": "Despite the recent progress of automated program verification techniques,\nfully automated verification of programs manipulating recursive data structures\nremains a challenge. We introduce the notion of solvable tuple patterns (STPs)\nto express invariants between list-like recursive data structures. A\ndistinguishing feature of STPs is that they can be efficiently inferred from\nonly a small number of positive samples; no negative samples are required. An\nSMT solver that supports the sequence theory can be used to check that an\ninferred STP is indeed an inductive invariant. After presenting basic\nproperties of STPs and an STP inference algorithm, we show how to incorporate\nthe STP inference into a CHC (Constrained Horn Clauses) solver supporting\nlist-like data structures, which serves as a uniform backend for automated\nprogram verification tools. A CHC solver incorporating the STP inference has\nwon the ADT-LIN category of CHC-COMP 2025 by a big margin.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u53ef\u89e3\u5143\u7ec4\u6a21\u5f0f(STP)\u7684\u6982\u5ff5\uff0c\u7528\u4e8e\u8868\u8fbe\u5217\u8868\u5f0f\u9012\u5f52\u6570\u636e\u7ed3\u6784\u7684\u7a0b\u5e8f\u4e0d\u53d8\u91cf\uff0c\u65e0\u9700\u8d1f\u6837\u672c\u5373\u53ef\u4ece\u5c11\u91cf\u6b63\u6837\u672c\u9ad8\u6548\u63a8\u65ad\uff0c\u5e76\u96c6\u6210\u5230CHC\u6c42\u89e3\u5668\u4e2d\u5b9e\u73b0\u81ea\u52a8\u5316\u7a0b\u5e8f\u9a8c\u8bc1", "motivation": "\u5c3d\u7ba1\u7a0b\u5e8f\u9a8c\u8bc1\u6280\u672f\u6709\u6240\u8fdb\u5c55\uff0c\u4f46\u5b8c\u5168\u81ea\u52a8\u5316\u9a8c\u8bc1\u64cd\u4f5c\u9012\u5f52\u6570\u636e\u7ed3\u6784\u7684\u7a0b\u5e8f\u4ecd\u7136\u662f\u4e00\u4e2a\u6311\u6218\uff0c\u7279\u522b\u662f\u9700\u8981\u9ad8\u6548\u63a8\u65ad\u7a0b\u5e8f\u4e0d\u53d8\u91cf", "method": "\u5f15\u5165\u53ef\u89e3\u5143\u7ec4\u6a21\u5f0f(STP)\u8868\u8fbe\u6570\u636e\u7ed3\u6784\u95f4\u7684\u4e0d\u53d8\u91cf\u5173\u7cfb\uff0c\u8bbe\u8ba1STP\u63a8\u65ad\u7b97\u6cd5\u4ec5\u9700\u6b63\u6837\u672c\uff0c\u5229\u7528\u652f\u6301\u5e8f\u5217\u7406\u8bba\u7684SMT\u6c42\u89e3\u5668\u9a8c\u8bc1\u63a8\u65ad\u7684STP\u662f\u5426\u4e3a\u5f52\u7eb3\u4e0d\u53d8\u91cf\uff0c\u5e76\u5c06STP\u63a8\u65ad\u96c6\u6210\u5230\u652f\u6301\u5217\u8868\u5f0f\u6570\u636e\u7ed3\u6784\u7684CHC\u6c42\u89e3\u5668\u4e2d", "result": "\u96c6\u6210STP\u63a8\u65ad\u7684CHC\u6c42\u89e3\u5668\u5728CHC-COMP 2025\u7684ADT-LIN\u7c7b\u522b\u4e2d\u4ee5\u663e\u8457\u4f18\u52bf\u83b7\u80dc", "conclusion": "STP\u65b9\u6cd5\u80fd\u591f\u6709\u6548\u89e3\u51b3\u9012\u5f52\u6570\u636e\u7ed3\u6784\u7684\u81ea\u52a8\u5316\u7a0b\u5e8f\u9a8c\u8bc1\u95ee\u9898\uff0c\u4ec5\u9700\u5c11\u91cf\u6b63\u6837\u672c\u5373\u53ef\u9ad8\u6548\u63a8\u65ad\u4e0d\u53d8\u91cf\uff0c\u4e3a\u81ea\u52a8\u5316\u7a0b\u5e8f\u9a8c\u8bc1\u5de5\u5177\u63d0\u4f9b\u4e86\u7edf\u4e00\u7684\u540e\u7aef\u89e3\u51b3\u65b9\u6848"}}
{"id": "2508.20922", "pdf": "https://arxiv.org/pdf/2508.20922", "abs": "https://arxiv.org/abs/2508.20922", "authors": ["Markus B\u00f6ck", "J\u00fcrgen Cito"], "title": "Static Factorisation of Probabilistic Programs With User-Labelled Sample Statements and While Loops", "categories": ["cs.PL"], "comment": null, "summary": "It is commonly known that any Bayesian network can be implemented as a\nprobabilistic program, but the reverse direction is not so clear. In this work,\nwe address the open question to what extent a probabilistic program with\nuser-labelled sample statements and while loops - features found in languages\nlike Gen, Turing, and Pyro - can be represented graphically. To this end, we\nextend existing operational semantics to support these language features. By\ntranslating a program to its control-flow graph, we define a sound static\nanalysis that approximates the dependency structure of the random variables in\nthe program. As a result, we obtain a static factorisation of the implicitly\ndefined program density, which is equivalent to the known Bayesian network\nfactorisation for programs without loops and constant labels, but constitutes a\nnovel graphical representation for programs that define an unbounded number of\nrandom variables via loops or dynamic labels. We further develop a sound\nprogram slicing technique to leverage this structure to statically enable three\nwell-known optimisations for the considered program class: we reduce the\nvariance of gradient estimates in variational inference and we speed up both\nsingle-site Metropolis Hastings and sequential Monte Carlo. These optimisations\nare proven correct and empirically shown to match or outperform existing\ntechniques.", "AI": {"tldr": "\u8be5\u7814\u7a76\u89e3\u51b3\u4e86\u6982\u7387\u7a0b\u5e8f\u4e0e\u8d1d\u53f6\u65af\u7f51\u7edc\u4e4b\u95f4\u7684\u53cc\u5411\u8868\u793a\u95ee\u9898\uff0c\u63d0\u51fa\u4e86\u652f\u6301\u5faa\u73af\u548c\u52a8\u6001\u6807\u7b7e\u7684\u6982\u7387\u7a0b\u5e8f\u7684\u56fe\u5f62\u5316\u8868\u793a\u65b9\u6cd5\uff0c\u5e76\u5f00\u53d1\u4e86\u57fa\u4e8e\u7a0b\u5e8f\u5207\u7247\u7684\u4e09\u7c7b\u4f18\u5316\u6280\u672f\u3002", "motivation": "\u867d\u7136\u8d1d\u53f6\u65af\u7f51\u7edc\u53ef\u4ee5\u8868\u793a\u4e3a\u6982\u7387\u7a0b\u5e8f\uff0c\u4f46\u5177\u6709\u5faa\u73af\u548c\u52a8\u6001\u6807\u7b7e\u7684\u6982\u7387\u7a0b\u5e8f\u5982\u4f55\u56fe\u5f62\u5316\u8868\u793a\u4ecd\u662f\u4e00\u4e2a\u5f00\u653e\u6027\u95ee\u9898\u3002\u73b0\u6709\u65b9\u6cd5\u65e0\u6cd5\u5904\u7406\u5305\u542bwhile\u5faa\u73af\u548c\u7528\u6237\u6807\u8bb0\u91c7\u6837\u8bed\u53e5\u7684\u7a0b\u5e8f\u3002", "method": "\u6269\u5c55\u64cd\u4f5c\u8bed\u4e49\u4ee5\u652f\u6301\u8bed\u8a00\u7279\u6027\uff0c\u901a\u8fc7\u63a7\u5236\u6d41\u56fe\u8f6c\u6362\u7a0b\u5e8f\uff0c\u5b9a\u4e49\u9759\u6001\u5206\u6790\u6765\u8fd1\u4f3c\u7a0b\u5e8f\u4e2d\u7684\u968f\u673a\u53d8\u91cf\u4f9d\u8d56\u7ed3\u6784\uff0c\u83b7\u5f97\u9759\u6001\u56e0\u5b50\u5206\u89e3\u8868\u793a\uff0c\u5e76\u5f00\u53d1\u7a0b\u5e8f\u5207\u7247\u6280\u672f\u3002", "result": "\u83b7\u5f97\u4e86\u65e0\u5faa\u73af\u548c\u5e38\u91cf\u6807\u7b7e\u7a0b\u5e8f\u7684\u8d1d\u53f6\u65af\u7f51\u7edc\u7b49\u4ef7\u56e0\u5b50\u5206\u89e3\uff0c\u4ee5\u53ca\u5b9a\u4e49\u65e0\u9650\u968f\u673a\u53d8\u91cf\u7a0b\u5e8f\u7684\u65b0\u56fe\u5f62\u8868\u793a\u3002\u4f18\u5316\u6280\u672f\u5728\u53d8\u5206\u63a8\u7406\u3001Metropolis Hastings\u548c\u987a\u5e8f\u8499\u7279\u5361\u6d1b\u4e2d\u8868\u73b0\u4f18\u5f02\u3002", "conclusion": "\u8be5\u5de5\u4f5c\u4e3a\u5177\u6709\u590d\u6742\u63a7\u5236\u6d41\u7684\u6982\u7387\u7a0b\u5e8f\u63d0\u4f9b\u4e86\u7cfb\u7edf\u7684\u56fe\u5f62\u5316\u8868\u793a\u6846\u67b6\uff0c\u5e76\u8bc1\u660e\u4e86\u57fa\u4e8e\u8be5\u6846\u67b6\u7684\u4f18\u5316\u6280\u672f\u5728\u7406\u8bba\u548c\u5b9e\u8bc1\u4e0a\u90fd\u4f18\u4e8e\u73b0\u6709\u65b9\u6cd5\u3002"}}
{"id": "2508.20340", "pdf": "https://arxiv.org/pdf/2508.20340", "abs": "https://arxiv.org/abs/2508.20340", "authors": ["Maolin Sun", "Yibiao Yang", "Yuming Zhou"], "title": "Boosting Skeleton-Driven SMT Solver Fuzzing by Leveraging LLM to Produce Formula Generators", "categories": ["cs.SE", "cs.AI", "cs.PL"], "comment": null, "summary": "Satisfiability Modulo Theory (SMT) solvers are foundational to modern systems\nand programming languages research, providing the foundation for tasks like\nsymbolic execution and automated verification. Because these solvers sit on the\ncritical path, their correctness is essential, and high-quality test formulas\nare key to uncovering bugs. However, while prior testing techniques performed\nwell on earlier solver versions, they struggle to keep pace with rapidly\nevolving features. Recent approaches based on Large Language Models (LLMs) show\npromise in exploring advanced solver capabilities, but two obstacles remain:\nnearly half of the generated formulas are syntactically invalid, and iterative\ninteractions with the LLMs introduce substantial computational overhead. In\nthis study, we present Chimera, a novel LLM-assisted fuzzing framework that\naddresses both issues by shifting from direct formula generation to the\nsynthesis of reusable term (i.e., logical expression) generators. Particularly,\nChimera uses LLMs to (1) automatically extract context-free grammars (CFGs) for\nSMT theories, including solver-specific extensions, from documentation, and (2)\nsynthesize composable Boolean term generators that adhere to these grammars.\nDuring fuzzing, Chimera populates structural skeletons derived from existing\nformulas with the terms iteratively produced by the LLM-synthesized generators.\nThis design ensures syntactic validity while promoting semantic diversity.\nNotably, Chimera requires only one-time LLM interaction investment,\ndramatically reducing runtime cost. We evaluated Chimera on two leading SMT\nsolvers: Z3 and cvc5. Our experiments show that Chimera has identified 43\nconfirmed bugs, 40 of which have already been fixed by developers.", "AI": {"tldr": "Chimera\u662f\u4e00\u4e2a\u57fa\u4e8eLLM\u7684SMT\u6c42\u89e3\u5668\u6a21\u7cca\u6d4b\u8bd5\u6846\u67b6\uff0c\u901a\u8fc7\u751f\u6210\u53ef\u91cd\u7528\u7684\u9879\u751f\u6210\u5668\u800c\u975e\u76f4\u63a5\u751f\u6210\u516c\u5f0f\uff0c\u89e3\u51b3\u4e86\u73b0\u6709\u65b9\u6cd5\u4e2d\u8bed\u6cd5\u65e0\u6548\u548c\u8ba1\u7b97\u5f00\u9500\u5927\u7684\u95ee\u9898\uff0c\u5728Z3\u548ccvc5\u4e2d\u53d1\u73b0\u4e8643\u4e2a\u5df2\u786e\u8ba4\u7684bug\u3002", "motivation": "SMT\u6c42\u89e3\u5668\u5728\u73b0\u4ee3\u7cfb\u7edf\u548c\u7f16\u7a0b\u8bed\u8a00\u7814\u7a76\u4e2d\u81f3\u5173\u91cd\u8981\uff0c\u4f46\u5176\u6b63\u786e\u6027\u6d4b\u8bd5\u9762\u4e34\u6311\u6218\u3002\u73b0\u6709\u6d4b\u8bd5\u6280\u672f\u96be\u4ee5\u8ddf\u4e0a\u6c42\u89e3\u5668\u5feb\u901f\u53d1\u5c55\u7684\u7279\u6027\uff0c\u800c\u57fa\u4e8eLLM\u7684\u65b9\u6cd5\u5b58\u5728\u8bed\u6cd5\u65e0\u6548\u548c\u8ba1\u7b97\u5f00\u9500\u5927\u7684\u95ee\u9898\u3002", "method": "Chimera\u6846\u67b6\u4f7f\u7528LLM\uff1a(1)\u4ece\u6587\u6863\u4e2d\u81ea\u52a8\u63d0\u53d6SMT\u7406\u8bba\u7684\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5\uff1b(2)\u5408\u6210\u7b26\u5408\u8fd9\u4e9b\u6587\u6cd5\u7684\u53ef\u7ec4\u5408\u5e03\u5c14\u9879\u751f\u6210\u5668\u3002\u5728\u6a21\u7cca\u6d4b\u8bd5\u65f6\uff0c\u7528LLM\u5408\u6210\u7684\u751f\u6210\u5668\u4ea7\u751f\u7684\u9879\u586b\u5145\u73b0\u6709\u516c\u5f0f\u7684\u7ed3\u6784\u9aa8\u67b6\u3002", "result": "\u5728Z3\u548ccvc5\u4e24\u4e2a\u4e3b\u6d41SMT\u6c42\u89e3\u5668\u4e0a\u8bc4\u4f30\uff0cChimera\u53d1\u73b0\u4e8643\u4e2a\u5df2\u786e\u8ba4\u7684bug\uff0c\u5176\u4e2d40\u4e2a\u5df2\u88ab\u5f00\u53d1\u8005\u4fee\u590d\u3002", "conclusion": "Chimera\u901a\u8fc7\u8f6c\u5411\u751f\u6210\u53ef\u91cd\u7528\u7684\u9879\u751f\u6210\u5668\u800c\u975e\u76f4\u63a5\u751f\u6210\u516c\u5f0f\uff0c\u786e\u4fdd\u4e86\u8bed\u6cd5\u6709\u6548\u6027\u5e76\u63d0\u9ad8\u4e86\u8bed\u4e49\u591a\u6837\u6027\uff0c\u540c\u65f6\u5927\u5e45\u964d\u4f4e\u4e86\u8fd0\u884c\u65f6\u6210\u672c\uff0c\u53ea\u9700\u4e00\u6b21LLM\u4ea4\u4e92\u6295\u8d44\u3002"}}
