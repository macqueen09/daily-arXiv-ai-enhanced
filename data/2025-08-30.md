<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]
- [cs.SE](#cs.SE) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Solvable Tuple Patterns and Their Applications to Program Verification](https://arxiv.org/abs/2508.20365)
*Naoki Kobayashi,Ryosuke Sato,Ayumi Shinohara,Ryo Yoshinaka*

Main category: cs.PL

TL;DR: 该论文提出了可解元组模式(STPs)的概念，用于表达列表式递归数据结构的程序不变量，无需负样本即可从小量正样本中高效推断，并整合到CHC求解器中实现自动化程序验证。


<details>
  <summary>Details</summary>
Motivation: 尽管程序验证技术有所进展，但完全自动化验证操作递归数据结构的程序仍具挑战性，需要新的方法来高效推断数据结构不变量。

Method: 引入可解元组模式(STPs)表达列表式递归数据结构的不变量关系，开发STP推断算法仅需少量正样本，利用支持序列理论的SMT求解器验证推断的STP是否为归纳不变量，并将STP推断整合到支持列表式数据结构的CHC求解器中。

Result: 整合STP推断的CHC求解器在CHC-COMP 2025的ADT-LIN类别中以显著优势获胜，证明了该方法的有效性。

Conclusion: STPs为递归数据结构的自动化程序验证提供了高效解决方案，仅需正样本即可推断不变量，显著提升了CHC求解器在相关领域的性能表现。

Abstract: Despite the recent progress of automated program verification techniques,
fully automated verification of programs manipulating recursive data structures
remains a challenge. We introduce the notion of solvable tuple patterns (STPs)
to express invariants between list-like recursive data structures. A
distinguishing feature of STPs is that they can be efficiently inferred from
only a small number of positive samples; no negative samples are required. An
SMT solver that supports the sequence theory can be used to check that an
inferred STP is indeed an inductive invariant. After presenting basic
properties of STPs and an STP inference algorithm, we show how to incorporate
the STP inference into a CHC (Constrained Horn Clauses) solver supporting
list-like data structures, which serves as a uniform backend for automated
program verification tools. A CHC solver incorporating the STP inference has
won the ADT-LIN category of CHC-COMP 2025 by a big margin.

</details>


### [2] [Static Factorisation of Probabilistic Programs With User-Labelled Sample Statements and While Loops](https://arxiv.org/abs/2508.20922)
*Markus Böck,Jürgen Cito*

Main category: cs.PL

TL;DR: 该研究解决了概率程序（包含样本语句和while循环）能否用图形化表示的问题，通过控制流图分析程序依赖结构，获得了静态因子分解表示，并开发了程序切片技术来优化变分推断、Metropolis Hastings和顺序蒙特卡洛算法。


<details>
  <summary>Details</summary>
Motivation: 虽然贝叶斯网络可以表示为概率程序，但反向转换（特别是包含样本语句和循环的程序）的图形化表示仍是一个开放问题，需要为现代概率编程语言提供理论基础和优化技术。

Method: 扩展操作语义支持语言特性，通过控制流图进行静态分析近似随机变量依赖结构，获得程序密度的静态因子分解，并开发程序切片技术。

Result: 获得了适用于无界随机变量程序的新图形表示，程序切片技术能正确减少变分推断梯度估计方差，加速Metropolis Hastings和顺序蒙特卡洛算法，实证表现优于现有技术。

Conclusion: 该工作为包含循环和动态标签的概率程序提供了首个图形化表示框架，开发的优化技术在理论和实证上都证明有效，为概率编程语言的理论基础和性能优化做出了贡献。

Abstract: It is commonly known that any Bayesian network can be implemented as a
probabilistic program, but the reverse direction is not so clear. In this work,
we address the open question to what extent a probabilistic program with
user-labelled sample statements and while loops - features found in languages
like Gen, Turing, and Pyro - can be represented graphically. To this end, we
extend existing operational semantics to support these language features. By
translating a program to its control-flow graph, we define a sound static
analysis that approximates the dependency structure of the random variables in
the program. As a result, we obtain a static factorisation of the implicitly
defined program density, which is equivalent to the known Bayesian network
factorisation for programs without loops and constant labels, but constitutes a
novel graphical representation for programs that define an unbounded number of
random variables via loops or dynamic labels. We further develop a sound
program slicing technique to leverage this structure to statically enable three
well-known optimisations for the considered program class: we reduce the
variance of gradient estimates in variational inference and we speed up both
single-site Metropolis Hastings and sequential Monte Carlo. These optimisations
are proven correct and empirically shown to match or outperform existing
techniques.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [3] [Boosting Skeleton-Driven SMT Solver Fuzzing by Leveraging LLM to Produce Formula Generators](https://arxiv.org/abs/2508.20340)
*Maolin Sun,Yibiao Yang,Yuming Zhou*

Main category: cs.SE

TL;DR: Chimera是一个基于LLM的SMT求解器模糊测试框架，通过生成可重用的项生成器而非直接生成公式，解决了现有方法中语法无效和计算开销大的问题，在Z3和cvc5中发现43个已确认bug。


<details>
  <summary>Details</summary>
Motivation: SMT求解器在现代系统和编程语言研究中至关重要，但其正确性测试面临挑战。现有测试技术难以跟上求解器的快速演进，而基于LLM的方法存在语法无效率高和计算开销大的问题。

Method: Chimera使用LLM从文档中自动提取SMT理论的上下文无关文法，并合成可组合的布尔项生成器。在模糊测试时，用LLM合成的生成器产生的项填充现有公式的结构骨架，确保语法有效性同时促进语义多样性。

Result: 在Z3和cvc5两个主流SMT求解器上评估，Chimera发现了43个已确认的bug，其中40个已被开发者修复。

Conclusion: Chimera通过一次性LLM交互投资显著降低了运行时成本，有效解决了SMT求解器测试中的语法有效性和计算效率问题，证明了其在发现实际bug方面的有效性。

Abstract: Satisfiability Modulo Theory (SMT) solvers are foundational to modern systems
and programming languages research, providing the foundation for tasks like
symbolic execution and automated verification. Because these solvers sit on the
critical path, their correctness is essential, and high-quality test formulas
are key to uncovering bugs. However, while prior testing techniques performed
well on earlier solver versions, they struggle to keep pace with rapidly
evolving features. Recent approaches based on Large Language Models (LLMs) show
promise in exploring advanced solver capabilities, but two obstacles remain:
nearly half of the generated formulas are syntactically invalid, and iterative
interactions with the LLMs introduce substantial computational overhead. In
this study, we present Chimera, a novel LLM-assisted fuzzing framework that
addresses both issues by shifting from direct formula generation to the
synthesis of reusable term (i.e., logical expression) generators. Particularly,
Chimera uses LLMs to (1) automatically extract context-free grammars (CFGs) for
SMT theories, including solver-specific extensions, from documentation, and (2)
synthesize composable Boolean term generators that adhere to these grammars.
During fuzzing, Chimera populates structural skeletons derived from existing
formulas with the terms iteratively produced by the LLM-synthesized generators.
This design ensures syntactic validity while promoting semantic diversity.
Notably, Chimera requires only one-time LLM interaction investment,
dramatically reducing runtime cost. We evaluated Chimera on two leading SMT
solvers: Z3 and cvc5. Our experiments show that Chimera has identified 43
confirmed bugs, 40 of which have already been fixed by developers.

</details>
