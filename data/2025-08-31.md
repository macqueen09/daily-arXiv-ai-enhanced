<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]
- [cs.SE](#cs.SE) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Solvable Tuple Patterns and Their Applications to Program Verification](https://arxiv.org/abs/2508.20365)
*Naoki Kobayashi,Ryosuke Sato,Ayumi Shinohara,Ryo Yoshinaka*

Main category: cs.PL

TL;DR: 该论文提出了可解元组模式(STPs)的概念，用于表达列表式递归数据结构的程序不变量，无需负样本即可从小样本中高效推断，并集成到CHC求解器中实现自动化程序验证。


<details>
  <summary>Details</summary>
Motivation: 尽管程序验证技术有所进展，但递归数据结构的全自动验证仍然具有挑战性，需要新的方法来高效推断程序不变量。

Method: 引入可解元组模式(STPs)表达数据结构间的不变量关系，开发STP推断算法，利用支持序列理论的SMT求解器验证不变量，并将STP推断集成到CHC求解器中。

Result: 集成STP推断的CHC求解器在CHC-COMP 2025的ADT-LIN类别中以显著优势获胜，证明了方法的有效性。

Conclusion: STPs为递归数据结构的自动化程序验证提供了有效的解决方案，能够从小样本中高效推断不变量，显著提升了CHC求解器的性能。

Abstract: Despite the recent progress of automated program verification techniques,
fully automated verification of programs manipulating recursive data structures
remains a challenge. We introduce the notion of solvable tuple patterns (STPs)
to express invariants between list-like recursive data structures. A
distinguishing feature of STPs is that they can be efficiently inferred from
only a small number of positive samples; no negative samples are required. An
SMT solver that supports the sequence theory can be used to check that an
inferred STP is indeed an inductive invariant. After presenting basic
properties of STPs and an STP inference algorithm, we show how to incorporate
the STP inference into a CHC (Constrained Horn Clauses) solver supporting
list-like data structures, which serves as a uniform backend for automated
program verification tools. A CHC solver incorporating the STP inference has
won the ADT-LIN category of CHC-COMP 2025 by a big margin.

</details>


### [2] [Static Factorisation of Probabilistic Programs With User-Labelled Sample Statements and While Loops](https://arxiv.org/abs/2508.20922)
*Markus Böck,Jürgen Cito*

Main category: cs.PL

TL;DR: 该研究解决了概率程序与贝叶斯网络之间的双向表示问题，提出了支持循环和动态标签的概率程序的图形化表示方法，并开发了基于程序切片的三项优化技术。


<details>
  <summary>Details</summary>
Motivation: 虽然任何贝叶斯网络都可以实现为概率程序，但反向表示（特别是包含用户标记采样语句和while循环的概率程序）的图形化表示仍是一个开放问题。这类特性在Gen、Turing和Pyro等现代概率编程语言中很常见。

Method: 扩展现有操作语义以支持语言特性，通过将程序转换为控制流图来定义静态分析，近似程序中的随机变量依赖结构，获得静态因子分解表示，并开发基于程序切片的优化技术。

Result: 获得了无循环和常量标签程序的贝叶斯网络因子分解等价表示，以及定义无限随机变量程序的新图形表示。提出的三项优化（变分推断梯度估计方差降低、单点Metropolis Hastings加速、序列蒙特卡洛加速）被证明正确且在实证中优于现有技术。

Conclusion: 该工作为包含循环和动态标签的概率程序提供了系统的图形化表示框架，并证明了基于该框架的优化技术在理论和实践上的有效性，填补了概率程序与贝叶斯网络双向表示的理论空白。

Abstract: It is commonly known that any Bayesian network can be implemented as a
probabilistic program, but the reverse direction is not so clear. In this work,
we address the open question to what extent a probabilistic program with
user-labelled sample statements and while loops - features found in languages
like Gen, Turing, and Pyro - can be represented graphically. To this end, we
extend existing operational semantics to support these language features. By
translating a program to its control-flow graph, we define a sound static
analysis that approximates the dependency structure of the random variables in
the program. As a result, we obtain a static factorisation of the implicitly
defined program density, which is equivalent to the known Bayesian network
factorisation for programs without loops and constant labels, but constitutes a
novel graphical representation for programs that define an unbounded number of
random variables via loops or dynamic labels. We further develop a sound
program slicing technique to leverage this structure to statically enable three
well-known optimisations for the considered program class: we reduce the
variance of gradient estimates in variational inference and we speed up both
single-site Metropolis Hastings and sequential Monte Carlo. These optimisations
are proven correct and empirically shown to match or outperform existing
techniques.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [3] [Boosting Skeleton-Driven SMT Solver Fuzzing by Leveraging LLM to Produce Formula Generators](https://arxiv.org/abs/2508.20340)
*Maolin Sun,Yibiao Yang,Yuming Zhou*

Main category: cs.SE

TL;DR: Chimera是一个基于LLM的SMT求解器模糊测试框架，通过生成可重用的术语生成器而非直接生成公式，解决了现有方法中语法无效和计算开销大的问题，在Z3和cvc5中发现了43个已确认的bug。


<details>
  <summary>Details</summary>
Motivation: SMT求解器在系统验证中至关重要，但现有测试方法难以跟上快速发展的功能。基于LLM的方法虽然显示出潜力，但存在生成的公式语法无效和计算开销大的问题。

Method: Chimera使用LLM从文档中自动提取SMT理论的上下文无关文法，并合成可组合的布尔术语生成器。在模糊测试时，用这些生成器产生的术语填充现有公式的结构骨架，确保语法有效性同时促进语义多样性。

Result: 在Z3和cvc5两个主流SMT求解器上评估，Chimera发现了43个已确认的bug，其中40个已被开发者修复。

Conclusion: Chimera通过一次性LLM交互投资显著降低了运行时成本，同时确保了生成公式的语法有效性，为SMT求解器的测试提供了高效可靠的解决方案。

Abstract: Satisfiability Modulo Theory (SMT) solvers are foundational to modern systems
and programming languages research, providing the foundation for tasks like
symbolic execution and automated verification. Because these solvers sit on the
critical path, their correctness is essential, and high-quality test formulas
are key to uncovering bugs. However, while prior testing techniques performed
well on earlier solver versions, they struggle to keep pace with rapidly
evolving features. Recent approaches based on Large Language Models (LLMs) show
promise in exploring advanced solver capabilities, but two obstacles remain:
nearly half of the generated formulas are syntactically invalid, and iterative
interactions with the LLMs introduce substantial computational overhead. In
this study, we present Chimera, a novel LLM-assisted fuzzing framework that
addresses both issues by shifting from direct formula generation to the
synthesis of reusable term (i.e., logical expression) generators. Particularly,
Chimera uses LLMs to (1) automatically extract context-free grammars (CFGs) for
SMT theories, including solver-specific extensions, from documentation, and (2)
synthesize composable Boolean term generators that adhere to these grammars.
During fuzzing, Chimera populates structural skeletons derived from existing
formulas with the terms iteratively produced by the LLM-synthesized generators.
This design ensures syntactic validity while promoting semantic diversity.
Notably, Chimera requires only one-time LLM interaction investment,
dramatically reducing runtime cost. We evaluated Chimera on two leading SMT
solvers: Z3 and cvc5. Our experiments show that Chimera has identified 43
confirmed bugs, 40 of which have already been fixed by developers.

</details>
