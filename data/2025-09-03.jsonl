{"id": "2509.00360", "pdf": "https://arxiv.org/pdf/2509.00360", "abs": "https://arxiv.org/abs/2509.00360", "authors": ["Shaan Nagy", "Timothy Zhou", "Nadia Polikarpova", "Loris D'Antoni"], "title": "ChopChop: a Programmable Framework for Semantically Constraining the Output of Language Models", "categories": ["cs.PL", "D.3.0"], "comment": null, "summary": "Language models (LMs) can generate code, but cannot guarantee its\ncorrectness--producing outputs that often violate type safety, program\ninvariants, or semantic equivalence. Constrained decoding offers a solution by\nrestricting generation to programs that satisfy desired properties. Yet,\nexisting methods are limited to shallow syntactic constraints or rely on\nbrittle, ad hoc encodings of semantics over token sequences.\n  We present ChopChop, the first programmable framework for semantic\nconstrained decoding, enabling LMs to generate code that provably satisfies\nrich semantic properties. ChopChop connects token-level generation with\nreasoning over abstract program structures using a coinduction-based formalism\nand reduces constraint enforcement to a realizability problem over regular\ncodata. We demonstrate ChopChop's generality through generation constrained by\ntype safety and program equivalence, showing how formal methods can be\nseamlessly integrated into LM-driven code generation. ChopChop transforms\nsemantic constrained decoding from a niche technique into a systematic,\nprincipled extension of LMs--improving success rates across models and tasks\nwhile maintaining practical decoding latency."}
{"id": "2509.00587", "pdf": "https://arxiv.org/pdf/2509.00587", "abs": "https://arxiv.org/abs/2509.00587", "authors": ["Vaibhav Mehta", "Justin Hsu"], "title": "A Hoare Logic for Symmetry Properties", "categories": ["cs.PL"], "comment": "Accepted to OOPSLA '25", "summary": "Many natural program correctness properties can be stated in terms of\n  symmetries, but existing formal methods have little support for reasoning\n  about such properties. We consider how to formally verify a broad class of\n  symmetry properties expressed in terms of group actions. To specify these\n  properties, we design a syntax for group actions, supporting standard\n  constructions and a natural notion of entailment. Then, we develop a\n  Hoare-style logic for verifying symmetry properties of imperative programs,\n  where group actions take the place of the typical pre- and post-condition\n  assertions. Finally, we develop a prototype tool $\\mathsf{SymVerif}$, and use\n  it to verify symmetry properties on a series of handcrafted benchmarks. Our\n  tool uncovered an error in a model of a dynamical system described by\n\\citet{McLachlan_Quispel_2002}."}
{"id": "2509.00699", "pdf": "https://arxiv.org/pdf/2509.00699", "abs": "https://arxiv.org/abs/2509.00699", "authors": ["Yumeng He", "Chandrakana Nandi", "Sreepathi Pai"], "title": "Formalizing Linear Motion G-code for Invariant Checking and Differential Testing of Fabrication Tools", "categories": ["cs.PL"], "comment": null, "summary": "The computational fabrication pipeline for 3D printing is much like a\ncompiler - users design models in Computer Aided Design (CAD) tools that are\nlowered to polygon meshes to be ultimately compiled to machine code by 3D\nslicers. For traditional compilers and programming languages, techniques for\nchecking program invariants are well-established. Similarly, methods like\ndifferential testing are often used to uncover bugs in compilers themselves,\nwhich makes them more reliable. The fabrication pipeline would benefit from\nsimilar techniques but traditional approaches do not directly apply to the\nrepresentations used in this domain. Unlike traditional programs, 3D models\nexist both as geometric objects as well as machine code that ultimately runs on\nthe hardware. The machine code, like in traditional compiling, is affected by\nmany factors like the model, the slicer being used, and numerous\nuser-configurable parameters that control the slicing process. In this work, we\npropose a new algorithm for lifting G-code (a common language used in\nfabrication pipelines) by denoting a G-code program to a set of cuboids, and\nthen defining an approximate point cloud representation for efficiently\noperating on these cuboids. Our algorithm opens up new opportunities: we show\nthree use cases that demonstrate how it enables error localization in CAD\nmodels through invariant checking, quantitative comparisons between slicers,\nand evaluating the efficacy of mesh repair tools. We present a prototype\nimplementation of our algorithm in a tool, GlitchFinder, and evaluate it on 58\nreal-world CAD models. Our results show that GlitchFinder is particularly\neffective in identifying slicing issues due to small features, can highlight\ndifferences in how popular slicers (Cura and PrusaSlicer) slice the same model,\nand can identify cases where mesh repair tools (MeshLab and Meshmixer)\nintroduce new errors during repair."}
{"id": "2509.00948", "pdf": "https://arxiv.org/pdf/2509.00948", "abs": "https://arxiv.org/abs/2509.00948", "authors": ["Denghang Hu", "Taolue Chen", "Philipp RÃ¼mmer", "Fu Song", "Zhilin Wu"], "title": "Decision Procedure for A Theory of String Sequences", "categories": ["cs.PL", "cs.FL"], "comment": "21 pages, 2 tables, APLAS 2025", "summary": "The theory of sequences, supported by many SMT solvers, can model program\ndata types including bounded arrays and lists. Sequences are parameterized by\nthe element data type and provide operations such as accessing elements,\nconcatenation, forming sub-sequences and updating elements. Strings and\nsequences are intimately related; many operations, e.g., matching a string\naccording to a regular expression, splitting strings, or joining strings in a\nsequence, are frequently used in string-manipulating programs. Nevertheless,\nthese operations are typically not directly supported by existing SMT solvers,\nwhich instead only consider the generic theory of sequences. In this paper, we\npropose a theory of string sequences and study its satisfiability. We show\nthat, while it is undecidable in general, the decidability can be recovered by\nrestricting to the straight-line fragment. This is shown by encoding each\nstring sequence as a string, and each string sequence operation as a\ncorresponding string operation. We provide pre-image computation for the\nresulting string operations with respect to automata, effectively casting it\ninto the generic OSTRICH string constraint solving framework. We implement the\nnew decision procedure as a tool $\\ostrichseq$, and carry out experiments on\nbenchmark constraints generated from real-world JavaScript programs,\nhand-crafted templates and unit tests. The experiments confirm the efficacy of\nour approach."}
{"id": "2509.01511", "pdf": "https://arxiv.org/pdf/2509.01511", "abs": "https://arxiv.org/abs/2509.01511", "authors": ["Zhe Zhou", "Benjamin Delaware", "Suresh Jagannathan"], "title": "Type-Based Incorrectness Reasoning", "categories": ["cs.PL"], "comment": null, "summary": "A coverage type generalizes refinement types found in many functional\nlanguages with support for must-style underapproximate reasoning.\nProperty-based testing frameworks are one particularly useful domain where such\ncapabilities are useful as they allow us to verify the completeness, as well as\nsafety, of test generators. There is a surprising connection between the kind\nof underapproximate reasoning coverage types offer and the style of reasoning\nenabled by recently proposed Incorrectness Logic frameworks. In our\npresentation, we propose to explore this connection more deeply, identifying\nmechanisms that more systematically integrate incorrectness reasoning within an\nexpressive refinement type system and the opportunities that such integration\noffers to functional programmers, program verifiers, and program analyzers and\nrelated tools."}
{"id": "2509.02428", "pdf": "https://arxiv.org/pdf/2509.02428", "abs": "https://arxiv.org/abs/2509.02428", "authors": ["Yongwei Yuan", "Zhe Zhou", "Julia Belyakova", "Benjamin Delaware", "Suresh Jagannathan"], "title": "From Traces to Program Incorrectness: A Type-Theoretic Approach", "categories": ["cs.PL"], "comment": null, "summary": "We present a type-theoretic framework for reasoning about incorrectness in\nfunctional programs that interact with effectful, opaque library APIs. Our\napproach centers on traces -- temporally-ordered sequences of library API\ninvocations -- which naturally characterize both the preconditions of\nindividual APIs and their composite behavior. We represent these traces using\nsymbolic regular expressions (SREs), enabling formal specification of incorrect\nabstract data type (ADT) behaviors across function boundaries. The core\ncontribution is a novel type inference algorithm that operates modulo specified\nincorrectness properties and leverages the symbolic finite automata (SFAs)\nrepresentations of regexes for compositional reasoning of traces. When the\nalgorithm succeeds, the inferred types witness that an ADT implementation can\nexhibit some subset of the specified incorrect behaviors. This represents the\nfirst systematic approach to underapproximate reasoning against trace-based\nincorrectness specifications, enabling a new form of trace-guided compositional\nanalysis."}
{"id": "2509.01082", "pdf": "https://arxiv.org/pdf/2509.01082", "abs": "https://arxiv.org/abs/2509.01082", "authors": ["Madhav Kanda", "Shubham Ugare", "Sasa Misailovic"], "title": "REFINESTAT: Efficient Exploration for Probabilistic Program Synthesis", "categories": ["cs.LG", "cs.PL"], "comment": "RefineStat constrains LM decoding with statistical validity checks\n  and uses diagnostic-guided resampling (priors/likelihoods) to transform small\n  LMs' drafts into correct, reliable probabilistic programs that can match or\n  surpass closed-source models", "summary": "Probabilistic programming offers a powerful framework for modeling\nuncertainty, yet statistical model discovery in this domain entails navigating\nan immense search space under strict domain-specific constraints. When small\nlanguage models are tasked with generating probabilistic programs, they\nfrequently produce outputs that suffer from both syntactic and semantic errors,\nsuch as flawed inference constructs. Motivated by probabilistic programmers'\ndomain expertise and debugging strategies, we introduce RefineStat, a language\nmodel--driven framework that enforces semantic constraints ensuring synthesized\nprograms contain valid distributions and well-formed parameters, and then\napplies diagnostic-aware refinement by resampling prior or likelihood\ncomponents whenever reliability checks fail. We evaluate RefineStat on multiple\nprobabilistic-programming code-generation tasks using smaller language models\n(SLMs) and find that it produces programs that are both syntactically sound and\nstatistically reliable, often matching or surpassing those from closed-source\nlarge language models (e.g., OpenAI o3)."}
{"id": "2509.01508", "pdf": "https://arxiv.org/pdf/2509.01508", "abs": "https://arxiv.org/abs/2509.01508", "authors": ["Anurudh Peduri", "Gilles Barthe", "Michael Walter"], "title": "Traq: Estimating the Quantum Cost of Classical Programs", "categories": ["quant-ph", "cs.LO", "cs.PL", "cs.SE"], "comment": "50 pages", "summary": "Predicting practical speedups offered by future quantum computers has become\na major focus of the quantum computing community. Typically, these predictions\nare supported by lengthy manual analyses and numerical simulations and are\ncarried out for one specific application at a time. In this paper, we present\nTraq, a principled approach towards estimating the quantum speedup of classical\nprograms fully automatically and with provable guarantees. It consists of a\nclassical language that includes high-level primitives amenable to quantum\nspeedups, a cost analysis, and a compilation to low-level quantum programs. Our\ncost analysis upper bounds the complexity of the resulting quantum program in a\nfine-grained way: it captures non-asymptotic information and is sensitive to\nthe input of the program (rather than providing worst-case costs). We also\nprovide a proof-of-concept implementation and a case study inspired by AND-OR\ntrees."}
{"id": "2509.02197", "pdf": "https://arxiv.org/pdf/2509.02197", "abs": "https://arxiv.org/abs/2509.02197", "authors": ["Afif Boudaoud", "Alexandru Calotoiu", "Marcin Copik", "Torsten Hoefler"], "title": "DaCe AD: Unifying High-Performance Automatic Differentiation for Machine Learning and Scientific Computing", "categories": ["cs.LG", "cs.PF", "cs.PL"], "comment": null, "summary": "Automatic differentiation (AD) is a set of techniques that systematically\napplies the chain rule to compute the gradients of functions without requiring\nhuman intervention. Although the fundamentals of this technology were\nestablished decades ago, it is experiencing a renaissance as it plays a key\nrole in efficiently computing gradients for backpropagation in machine learning\nalgorithms. AD is also crucial for many applications in scientific computing\ndomains, particularly emerging techniques that integrate machine learning\nmodels within scientific simulations and schemes. Existing AD frameworks have\nfour main limitations: limited support of programming languages, requiring code\nmodifications for AD compatibility, limited performance on scientific computing\ncodes, and a naive store-all solution for forward-pass data required for\ngradient calculations. These limitations force domain scientists to manually\ncompute the gradients for large problems. This work presents DaCe AD, a\ngeneral, efficient automatic differentiation engine that requires no code\nmodifications. DaCe AD uses a novel ILP-based algorithm to optimize the\ntrade-off between storing and recomputing to achieve maximum performance within\na given memory constraint. We showcase the generality of our method by applying\nit to NPBench, a suite of HPC benchmarks with diverse scientific computing\npatterns, where we outperform JAX, a Python framework with state-of-the-art\ngeneral AD capabilities, by more than 92 times on average without requiring any\ncode changes."}
{"id": "2509.02457", "pdf": "https://arxiv.org/pdf/2509.02457", "abs": "https://arxiv.org/abs/2509.02457", "authors": ["Ajay Singh"], "title": "Safe Memory Reclamation Techniques", "categories": ["cs.DC", "cs.DS", "cs.PF", "cs.PL"], "comment": "Ph.D. Thesis", "summary": "Safe memory reclamation is crucial to memory safety for optimistic and\nlock-free concurrent data structures in non garbage collected programming\nlanguages. However, several challenges arise in designing an ideal safe memory\nreclamation algorithm, including achieving high speed and scalability, easy of\nuse for programmers, applicability to wide class of data structures, managing\nthe large memory footprint caused by delayed freeing of memory for safety and\nperformance, and avoiding asymmetric overhead on data structure operations.\nSeveral approaches to designing safe memory reclamation algorithms are studied\nby blending ideas and tools from across the hardware-software stack. These\nsolutions cross traditional boundaries and exploit features exposed at\ndifferent layers."}
