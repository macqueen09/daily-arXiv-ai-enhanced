{"id": "2509.04253", "pdf": "https://arxiv.org/pdf/2509.04253", "abs": "https://arxiv.org/abs/2509.04253", "authors": ["Siyuan He", "Songlin Jia", "Yuyan Bao", "Tiark Rompf"], "title": "When Lifetimes Liberate: A Type System for Arenas with Higher-Order Reachability Tracking", "categories": ["cs.PL"], "comment": null, "summary": "Static resource management in higher-order functional languages remains\nelusive due to tensions between control, expressiveness, and flexibility.\nRegion-based systems [Grossman et al. 2002; Tofte et al. 2001] offer control\nover lifetimes and expressive in-region sharing, but restrict resources to\nlexical scopes. Rust, an instance of ownership types [Clarke et al. 2013],\noffers non-lexical lifetimes and robust safety guarantees, yet its global\ninvariants make common sharing patterns hard to express. Reachability types\n[Wei et al. 2024] enable reasoning about sharing and separation, but lack\npractical tools for controlling resource lifetimes.\n  In this work, we try to unify their strengths. Our solution enables grouping\nresources as arenas for arbitrary sharing and static guarantees of lexically\nscoped lifetimes. Crucially, arenas and lexical lifetimes are not the only\nchoice: users may also manage resources individually, with non-lexical\nlifetimes. Regardless of mode, resources share the same type, preserving the\nhigher-order parametric nature of the language.\n  Obtaining static safety guarantee in a higher-order language with flexible\nsharing is nontrivial. To this end, we propose two new extensions atop\nreachability types [Wei et al. 2024]. First, A<: features a novel\ntwo-dimensional store model to enable coarse-grained reachability tracking for\narbitrarily shared resources within arenas. Building on this, {A}<: establishes\nlexical lifetime control with static guarantees. As the first reachability\nformalism presented for lifetime control, {A}<: avoids the complication of\nflow-sensitive reasoning and retains expressive power and simplicity. Both\ncalculi are formalized and proven type safe in Rocq.", "AI": {"tldr": "\u8fd9\u7bc7\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u7edf\u4e00\u7684\u8d44\u6e90\u7ba1\u7406\u65b9\u6848\uff0c\u7ed3\u5408\u4e86\u533a\u57df\u7cfb\u7edf\u3001Rust\u6240\u6709\u6743\u7c7b\u578b\u548c\u53ef\u8fbe\u6027\u7c7b\u578b\u7684\u4f18\u70b9\uff0c\u652f\u6301\u968f\u610f\u5171\u4eab\u548c\u9759\u6001\u751f\u547d\u5468\u671f\u4fdd\u8bc1", "motivation": "\u89e3\u51b3\u9ad8\u9636\u51fd\u6570\u8bed\u8a00\u4e2d\u9759\u6001\u8d44\u6e90\u7ba1\u7406\u7684\u6311\u6218\uff0c\u7edf\u4e00\u533a\u57df\u7cfb\u7edf\u7684\u8bcd\u6cd5\u4f5c\u7528\u57df\u9650\u5236\u3001Rust\u7684\u5168\u5c40\u4e0d\u53d8\u91cf\u9650\u5236\u548c\u53ef\u8fbe\u6027\u7c7b\u578b\u7f3a\u4e4f\u751f\u547d\u5468\u671f\u63a7\u5236\u7684\u95ee\u9898", "method": "\u5728\u53ef\u8fbe\u6027\u7c7b\u578b\u57fa\u7840\u4e0a\u63d0\u51fa\u4e24\u4e2a\u65b0\u6269\u5c55\uff1aA<:\u91c7\u7528\u4e8c\u7ef4\u5b58\u50a8\u6a21\u578b\u652f\u6301\u968f\u610f\u5171\u4eab\u8d44\u6e90\u7684\u7c97\u7c92\u5ea6\u8ddf\u8e2a\uff0c{A}<:\u5b9e\u73b0\u8bcd\u6cd5\u751f\u547d\u5468\u671f\u63a7\u5236\u4e14\u907f\u514d\u6d41\u654f\u611f\u63a8\u7406\u7684\u590d\u6742\u6027", "result": "\u5f62\u5f0f\u5316\u4e86\u4e24\u4e2a\u65b0\u8ba1\u7b97\u6cd5\uff0c\u5e76\u5728Rocq\u4e2d\u8bc1\u660e\u4e86\u7c7b\u578b\u5b89\u5168\u6027\uff0c\u4fdd\u6301\u4e86\u8bed\u8a00\u7684\u9ad8\u9636\u53c2\u6570\u6027\u8d28", "conclusion": "\u8be5\u65b9\u6848\u6210\u529f\u7edf\u4e00\u4e86\u4e0d\u540c\u8d44\u6e90\u7ba1\u7406\u65b9\u6cd5\u7684\u4f18\u70b9\uff0c\u63d0\u4f9b\u4e86\u7075\u6d3b\u7684\u5171\u4eab\u6a21\u5f0f\u548c\u9759\u6001\u751f\u547d\u5468\u671f\u63a7\u5236\uff0c\u4e3a\u9ad8\u9636\u51fd\u6570\u8bed\u8a00\u8d44\u6e90\u7ba1\u7406\u63d0\u4f9b\u4e86\u65b0\u7684\u89e3\u51b3\u65b9\u6848"}}
