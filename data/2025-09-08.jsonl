{"id": "2509.04936", "pdf": "https://arxiv.org/pdf/2509.04936", "abs": "https://arxiv.org/abs/2509.04936", "authors": ["Andrea Gilot", "Tobias Wrigstad", "Eva Darulova"], "title": "A Large-Scale Study of Floating-Point Usage in Statically Typed Languages", "categories": ["cs.PL", "cs.SE"], "comment": null, "summary": "Reasoning about floating-point arithmetic is notoriously hard. While static\nand dynamic analysis techniques or program repair have made significant\nprogress, more work is still needed to make them relevant to real-world code.\nOn the critical path to that goal is understanding what real-world\nfloating-point code looks like. To close that knowledge gap, this paper\npresents the first large-scale empirical study of floating-point arithmetic\nusage in statically typed languages across public GitHub repositories. We\nfollow state-of the art mining practices including random sampling and\nfiltering based on only intrinsic properties to avoid bias, and identify\nfloating-point usage by searching for keywords in the source code, and\nprogramming language constructs (e.g., loops) by parsing the code. Our\nevaluation supports the claim often made in papers that floating-point\narithmetic is widely used. Comparing statistics such as size and usage of\ncertain constructs and functions, we find that benchmarks used in literature to\nevaluate automated reasoning techniques for floating-point arithmetic are in\ncertain aspects representative of 'real-world' code, but not in all. We aim for\nour study and dataset to help future techniques for floating-point arithmetic\nto be designed and evaluated to match actual users' expectations."}
{"id": "2509.05160", "pdf": "https://arxiv.org/pdf/2509.05160", "abs": "https://arxiv.org/abs/2509.05160", "authors": ["Steven Smyth", "Daniel Busch", "Moez Ben Haj Hmida", "Edward A. Lee", "Bernhard Steffen"], "title": "AI-Assisted Modeling: DSL-Driven AI Interactions", "categories": ["cs.PL", "cs.SE"], "comment": "7 pages, 4 figures", "summary": "AI-assisted programming greatly increases software development performance.\nWe enhance this potential by integrating transparency through domain-specific\nmodeling techniques and providing instantaneous, graphical visualizations that\naccurately represent the semantics of AI-generated code. This approach\nfacilitates visual inspection and formal verification, such as model checking.\n  Formal models can be developed using programming, natural language prompts,\nvoice commands, and stage-wise refinement, with immediate feedback after each\ntransformation step. This support can be tailored to specific domains or\nintended purposes, improving both code generation and subsequent validation\nprocesses.\n  To demonstrate the effectiveness of this approach, we have developed a\nprototype as a Visual Studio Code extension for the Lingua Franca language.\nThis prototype showcases the potential for novel domain-specific modeling\npractices, offering an advancement in how models are created, visualized, and\nverified."}
{"id": "2509.05293", "pdf": "https://arxiv.org/pdf/2509.05293", "abs": "https://arxiv.org/abs/2509.05293", "authors": ["Julien Vanegue", "Jules Villard", "Peter O'Hearn", "Azalea Raad"], "title": "Non-Termination Proving: 100 Million LoC and Beyond", "categories": ["cs.PL", "cs.CL", "cs.SE", "D.3; F.3"], "comment": "14 pages, 4 figures", "summary": "We report on our tool, Pulse Infinite, that uses proof techniques to show\nnon-termination (divergence) in large programs. Pulse Infinite works\ncompositionally and under-approximately: the former supports scale, and the\nlatter ensures soundness for proving divergence. Prior work focused on small\nbenchmarks in the tens or hundreds of lines of code (LoC), and scale limits\ntheir practicality: a single company may have tens of millions, or even\nhundreds of millions of LoC or more. We report on applying Pulse Infinite to\nover a hundred million lines of open-source and proprietary software written in\nC, C++, and Hack, identifying over 30 previously unknown issues, establishing a\nnew state of the art for detecting divergence in real-world codebases."}
{"id": "2509.04777", "pdf": "https://arxiv.org/pdf/2509.04777", "abs": "https://arxiv.org/abs/2509.04777", "authors": ["Ramana Nagasamudram", "Anindya Banerjee", "David A. Naumann"], "title": "Forall-Exists Relational Verification by Filtering to Forall-Forall", "categories": ["cs.LO", "cs.PL", "F.3.1; F.3.2"], "comment": null, "summary": "Relational verification encompasses research directions such as reasoning\nabout data abstraction, reasoning about security and privacy, secure\ncompilation, and functional specificaton of tensor programs, among others.\nSeveral relational Hoare logics exist, with accompanying tool support for\ncompositional reasoning of $\\forall\\forall$ (2-safety) properties and,\ngenerally, k-safety properties of product programs. In contrast, few logics and\ntools exist for reasoning about $\\forall\\exists$ properties which are critical\nin the context of nondeterminism.\n  This paper's primary contribution is a methodology for verifying a\n$\\forall\\exists$ judgment by way of a novel filter-adequacy transformation.\nThis transformation adds assertions to a product program in such a way that the\ndesired $\\forall\\exists$ property (of a pair of underlying unary programs) is\nimplied by a $\\forall\\forall$ property of the transformed product. The paper\ndevelops a program logic for the basic $\\forall\\exists$ judgement extended with\nassertion failures; develops bicoms, a form of product programs that represents\npairs of executions and that caters for direct translation of $\\forall\\forall$\nproperties to unary correctness; proves (using the logic) a soundness theorem\nthat says successful $\\forall\\forall$ verification of a transformed bicom\nimplies the $\\forall\\exists$ spec for its underlying unary commands; and\nimplements a proof of principle prototype for auto-active relational\nverification which has been used to verify all examples in the paper. The\nmethodology thereby enables a user to work with ordinary assertions and\nassumptions, and a standard assertion language, so that existing tools\nincluding auto-active verifiers can be used."}
