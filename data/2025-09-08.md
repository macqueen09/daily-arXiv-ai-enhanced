<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]
- [cs.LO](#cs.LO) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [A Large-Scale Study of Floating-Point Usage in Statically Typed Languages](https://arxiv.org/abs/2509.04936)
*Andrea Gilot,Tobias Wrigstad,Eva Darulova*

Main category: cs.PL

TL;DR: 首次大规模研究公开GitHub库中静态类型语言的浮点数算法使用情况，发现浮点数算法广泛使用但现有测试基准在某些方面与实际代码存在差异


<details>
  <summary>Details</summary>
Motivation: 理解实际世界中浮点数算法代码的真实面貌，以推动浮点数算法自动化理论技术的发展和应用

Method: 采用最佳开发实践进行大规模挖掘，包括随机采样和基于内在属性的过滤，通过搜索源代码关键词和解析代码来识别浮点数使用情况

Result: 证实了浮点数算法被广泛使用的论断，发现现有文献中用于评估浮点数自动化理论技术的测试基准在某些方面与实际代码相似，但并非在所有方面都代表实际情况

Conclusion: 研究结果和数据集将有助于设计和评估更符合实际用户需求的浮点数算法自动化技术

Abstract: Reasoning about floating-point arithmetic is notoriously hard. While static
and dynamic analysis techniques or program repair have made significant
progress, more work is still needed to make them relevant to real-world code.
On the critical path to that goal is understanding what real-world
floating-point code looks like. To close that knowledge gap, this paper
presents the first large-scale empirical study of floating-point arithmetic
usage in statically typed languages across public GitHub repositories. We
follow state-of the art mining practices including random sampling and
filtering based on only intrinsic properties to avoid bias, and identify
floating-point usage by searching for keywords in the source code, and
programming language constructs (e.g., loops) by parsing the code. Our
evaluation supports the claim often made in papers that floating-point
arithmetic is widely used. Comparing statistics such as size and usage of
certain constructs and functions, we find that benchmarks used in literature to
evaluate automated reasoning techniques for floating-point arithmetic are in
certain aspects representative of 'real-world' code, but not in all. We aim for
our study and dataset to help future techniques for floating-point arithmetic
to be designed and evaluated to match actual users' expectations.

</details>


### [2] [AI-Assisted Modeling: DSL-Driven AI Interactions](https://arxiv.org/abs/2509.05160)
*Steven Smyth,Daniel Busch,Moez Ben Haj Hmida,Edward A. Lee,Bernhard Steffen*

Main category: cs.PL

TL;DR: 通过领域特定建模技术和即时图形可视化增强AI辅助编程的透明度，支持视觉检查和形式化验证，提高代码生成和验证效率


<details>
  <summary>Details</summary>
Motivation: 提升AI辅助编程的透明度和可信度，使开发者能够更好地理解和验证AI生成的代码

Method: 集成领域特定建模技术，提供即时图形可视化，支持编程、自然语言提示、语音命令和分阶段精化等多种形式化模型开发方式

Result: 开发了Visual Studio Code扩展原型，展示了新颖的领域特定建模实践潜力

Conclusion: 该方法为模型创建、可视化和验证提供了新的进展，能够显著改善AI生成代码的检查和验证过程

Abstract: AI-assisted programming greatly increases software development performance.
We enhance this potential by integrating transparency through domain-specific
modeling techniques and providing instantaneous, graphical visualizations that
accurately represent the semantics of AI-generated code. This approach
facilitates visual inspection and formal verification, such as model checking.
  Formal models can be developed using programming, natural language prompts,
voice commands, and stage-wise refinement, with immediate feedback after each
transformation step. This support can be tailored to specific domains or
intended purposes, improving both code generation and subsequent validation
processes.
  To demonstrate the effectiveness of this approach, we have developed a
prototype as a Visual Studio Code extension for the Lingua Franca language.
This prototype showcases the potential for novel domain-specific modeling
practices, offering an advancement in how models are created, visualized, and
verified.

</details>


### [3] [Non-Termination Proving: 100 Million LoC and Beyond](https://arxiv.org/abs/2509.05293)
*Julien Vanegue,Jules Villard,Peter O'Hearn,Azalea Raad*

Main category: cs.PL

TL;DR: Pulse Infinite是一个使用证明技术检测大型程序中非终止性（发散）的工具，通过组合性和欠近似方法支持大规模代码分析，在超过1亿行代码中发现了30多个未知问题


<details>
  <summary>Details</summary>
Motivation: 现有工作主要针对几十到几百行代码的小型基准测试，但实际公司代码库可能达到数千万甚至数亿行代码，规模限制限制了这些工具的实用性

Method: 采用组合性和欠近似方法：组合性支持大规模分析，欠近似确保证明发散的可靠性

Result: 在C、C++和Hack编写的超过1亿行开源和专有软件中应用，识别出30多个先前未知的问题

Conclusion: Pulse Infinite为检测现实世界代码库中的发散问题建立了新的技术标准，证明了在大规模代码分析中的有效性

Abstract: We report on our tool, Pulse Infinite, that uses proof techniques to show
non-termination (divergence) in large programs. Pulse Infinite works
compositionally and under-approximately: the former supports scale, and the
latter ensures soundness for proving divergence. Prior work focused on small
benchmarks in the tens or hundreds of lines of code (LoC), and scale limits
their practicality: a single company may have tens of millions, or even
hundreds of millions of LoC or more. We report on applying Pulse Infinite to
over a hundred million lines of open-source and proprietary software written in
C, C++, and Hack, identifying over 30 previously unknown issues, establishing a
new state of the art for detecting divergence in real-world codebases.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [4] [Forall-Exists Relational Verification by Filtering to Forall-Forall](https://arxiv.org/abs/2509.04777)
*Ramana Nagasamudram,Anindya Banerjee,David A. Naumann*

Main category: cs.LO

TL;DR: 这篇论文提出了一种验证全称存在性质(∀∃)属性的方法论，通过筛适度变换将关系验证转换为产品程序的全称全称性质(∀∀)验证问题。


<details>
  <summary>Details</summary>
Motivation: 目前存在多种关系Hoare逻辑和工具用于验证全称全称性质(∀∀)，但缺少能够处理全称存在性质(∀∃)的方法和工具，而这类性质在非确定性语义下很重要。

Method: 设计了筛适度变换技术，在产品程序中添加断言，使得∀∃属性可以通过∀∀属性的验证来推导。发展了支持断言失败的逻辑系统，定义了bicoms产品程序形式，并实现了原型系统。

Result: 证明了韩韩性定理：成功验证转换后的bicom的∀∀属性可以推导出原始单一程序对的∀∃规格。实现的原型系统成功验证了论文中的所有例子。

Conclusion: 该方法论允许用户使用标准断言语言和现有的自动化验证工具来处理∀∃性质的关系验证问题，填补了相关领域的技术空白。

Abstract: Relational verification encompasses research directions such as reasoning
about data abstraction, reasoning about security and privacy, secure
compilation, and functional specificaton of tensor programs, among others.
Several relational Hoare logics exist, with accompanying tool support for
compositional reasoning of $\forall\forall$ (2-safety) properties and,
generally, k-safety properties of product programs. In contrast, few logics and
tools exist for reasoning about $\forall\exists$ properties which are critical
in the context of nondeterminism.
  This paper's primary contribution is a methodology for verifying a
$\forall\exists$ judgment by way of a novel filter-adequacy transformation.
This transformation adds assertions to a product program in such a way that the
desired $\forall\exists$ property (of a pair of underlying unary programs) is
implied by a $\forall\forall$ property of the transformed product. The paper
develops a program logic for the basic $\forall\exists$ judgement extended with
assertion failures; develops bicoms, a form of product programs that represents
pairs of executions and that caters for direct translation of $\forall\forall$
properties to unary correctness; proves (using the logic) a soundness theorem
that says successful $\forall\forall$ verification of a transformed bicom
implies the $\forall\exists$ spec for its underlying unary commands; and
implements a proof of principle prototype for auto-active relational
verification which has been used to verify all examples in the paper. The
methodology thereby enables a user to work with ordinary assertions and
assumptions, and a standard assertion language, so that existing tools
including auto-active verifiers can be used.

</details>
