<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 7]
- [math.CT](#math.CT) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Comparing Methods for the Cross-Level Verification of SystemC Peripherals with Symbolic Execution](https://arxiv.org/abs/2509.05504)
*Karl Aaron Rudkowski,Sallar Ahmadi-Pour,Rolf Drechsler*

Main category: cs.PL

TL;DR: 提出了CrosSym和SEFOS两种虚拟原型符号执行方法，分别通过修改SystemC内核和符号执行引擎来实现外设的跨层级验证


<details>
  <summary>Details</summary>
Motivation: 现代硬件开发中虚拟原型(VP)在SystemC中实现，但现有符号执行方法需要修改SystemC内核或忽略跨层级验证机会，无法专注于外设等特定子系统的特殊挑战

Method: CrosSym修改SystemC内核，SEFOS修改现代符号执行引擎，两种方法都支持外设的多抽象层级符号执行

Result: 在多种外设和不同抽象层级上进行了广泛评估，展示了两种工具的功能：(1)不同验证场景；(2)识别300+变异体。SEFOS保持未修改的SystemC内核和外设，CrosSym在运行时和内存使用上稍好

Conclusion: 与仅限于事务级建模(TLM)的最先进技术相比，我们的工具提供了相当的运行时性能，同时实现了符号执行的跨层级验证

Abstract: Virtual Prototypes (VPs) are important tools in modern hardware development.
At high abstractions, they are often implemented in SystemC and offer early
analysis of increasingly complex designs. These complex designs often combine
one or more processors, interconnects, and peripherals to perform tasks in
hardware or interact with the environment. Verifying these subsystems is a
well-suited task for VPs, as they allow reasoning across different abstraction
levels. While modern verification techniques like symbolic execution can be
seamlessly integrated into VP-based workflows, they require modifications in
the SystemC kernel. Hence, existing approaches therefore modify and replace the
SystemC kernel, or ignore the opportunity of cross-level scenarios completely,
and would not allow focusing on special challenges of particular subsystems
like peripherals. We propose CrosSym and SEFOS, two opposing approaches for a
versatile symbolic execution of peripherals. CrosSym modifies the SystemC
kernel, while SEFOS instead modifies a modern symbolic execution engine. Our
extensive evaluation applies our tools to various peripherals on different
levels of abstractions. Both tools extensive sets of features are demonstrated
for (1) different verification scenarios, and (2) identifying 300+ mutants. In
comparison with each other, SEFOS convinces with the unmodified SystemC kernel
and peripheral, while CrosSym offers slightly better runtime and memory usage.
In comparison to the state-of-the-art, that is limited to Transaction Level
Modelling (TLM), our tools offered comparable runtime, while enabling
cross-level verification with symbolic execution.

</details>


### [2] [Fixed Parameter Tractable Linearizability Monitoring for Stack, Queue and Anagram Agnostic Data Types](https://arxiv.org/abs/2509.05586)
*Lee Zheng Han,Umang Mathur*

Main category: cs.PL

TL;DR: 提出了针对并发数据结构的线性化验证的固定参数可处理算法，针对栈、队列和字谜无关数据类型，参数化为最大并发度


<details>
  <summary>Details</summary>
Motivation: 并发数据结构的线性化验证是NP难问题，即使对于简单类型也是如此，需要开发高效的验证方法

Method: 利用前沿图和分区状态来限制搜索空间，对于字谜无关数据类型使用线性化等价性，对于栈使用基于文法的方法和矩阵乘法约简，对于队列使用分割序列转移系统和动态规划

Result: 在有限并发度下实现了对数线性时间到次立方时间的监控复杂度

Conclusion: 这些结果统一了在有界并发下对顺序敏感和字谜无关数据类型的可处理性保证

Abstract: Verifying linearizability of concurrent data structures is NP-hard, even for
simple types. We present fixed-parameter tractable algorithms for monitoring
stacks, queues, and anagram-agnostic data types (AADTs), parameterized by the
maximum concurrency. Our approach leverages frontier graphs and partition
states to bound the search space. For AADTs, equivalence of linearizations
enables monitoring in log-linear time. For stacks, we introduce a grammar-based
method with a sub-cubic reduction to matrix multiplication, and for queues, a
split-sequence transition system supporting efficient dynamic programming.
These results unify tractability guarantees for both order-sensitive and
anagram-agnostic data types under bounded concurrency.

</details>


### [3] [Pacing Types: Safe Monitoring of Asynchronous Streams](https://arxiv.org/abs/2509.06724)
*Florian Kohn,Arthur Correnson,Jan Baumeister,Bernd Finkbeiner*

Main category: cs.PL

TL;DR: 这篇论文提出了一种新的类型系统"pacing types"，用于确保异步数据流监控器的运行时安全性，充分利用RTLola框架的同步化策略规范功能。


<details>
  <summary>Details</summary>
Motivation: 流式监控是复杂系统的实时安全保障机制，监控器本身安全性至关重要。异步数据流的同步问题是设计可靠监控器的核心挑战，虽然RTLola框架提供了强大的同步化规范能力，但也引入了细微的运行时错误风险。

Method: 论文提出了pacing types类型系统，实现在RTLola框架中。对RTLola的核心段落进行了形式化定义，并使用新的逻辑关系完成了类型系统的完备性证明。

Result: 开发了能够确保异步数据流监控器运行时行为良好的类型系统，通过形式化验证和完备性证明确保了方法的可靠性。

Conclusion: pacing types类型系统有效解决了异步数据流监控器的运行时安全性问题，为构建可靠的实时安全保障机制提供了重要技术支撑。

Abstract: Stream-based monitoring is a real-time safety assurance mechanism for complex
cyber-physical systems such as unmanned aerial vehicles. In this context, a
monitor aggregates streams of input data from sensors and other sources to give
real-time statistics and assessments of the system's health. Since monitors are
safety-critical components, it is crucial to ensure that they are free of
potential runtime errors. One of the central challenges in designing reliable
stream-based monitors is to deal with the asynchronous nature of data streams:
in concrete applications, the different sensors being monitored produce values
at different speeds, and it is the monitor's responsibility to correctly react
to the asynchronous arrival of different streams of values. To ease this
process, modern frameworks for stream-based monitoring such as RTLola feature
an expressive specification language that allows to finely specify data
synchronization policies. While this feature dramatically simplifies the design
of monitors, it can also lead to subtle runtime errors. To mitigate this issue,
this paper presents pacing types, a novel type system implemented in RTLola to
ensure that monitors for asynchronous streams are well-behaved at runtime. We
formalize the essence of pacing types for a core fragment of RTLola, and
present a soundness proof of the pacing type system using a new logical
relation.

</details>


### [4] [Termination Analysis of Linear-Constraint Programs](https://arxiv.org/abs/2509.06752)
*Amir M. Ben-Amram,Samir Genaim,Joël Ouaknine,James Worrell*

Main category: cs.PL

TL;DR: 这篇调查性论文系统评估了带数值变量和线性约束过渡系统的程序终止性分析技术，包括基础可决定性理论、排序函数和分离良基过渡不变量等方法，同时也讨论了非终止性证据。


<details>
  <summary>Details</summary>
Motivation: 程序终止性分析存在本质上的不可决定性问题，需要系统性地探索可以减轻这种困难的方法。

Method: 调查采用了多种技术进行系统分析：基础可决定性理论研究、排序函数方法、分离良基过渡不变量等，同时也考察了非终止性证据的构建。

Result: 研究展示了不同方法在表达能力与计算复杂性之间的承赞关系，提供了算法和复杂性方面的深入分析。

Conclusion: 这份调查为线性约束程序的终止性分析提供了系统性的技术概览，但并未涉及实际编程语言或更复杂的非线性、概率性模型。

Abstract: This Survey provides an overview of techniques in termination analysis for
programs with numerical variables and transitions defined by linear
constraints. This subarea of program analysis is challenging due to the
existence of undecidable problems, and this Survey systematically explores
approaches that mitigate this inherent difficulty. These include foundational
decidability results, the use of ranking functions, and disjunctive
well-founded transition invariants. The Survey also discusses non-termination
witnesses, used to prove that a program will not halt. We examine the
algorithmic and complexity aspects of these methods, showing how different
approaches offer a trade-off between expressive power and computational
complexity. The Survey does not discuss how termination analysis is performed
on real-world programming languages, nor does it consider more expressive
abstract models that include non-linear arithmetic, probabilistic choice, or
term rewriting systems.

</details>


### [5] [Dato: A Task-Based Programming Model for Dataflow Accelerators](https://arxiv.org/abs/2509.06794)
*Shihan Fang,Hongzheng Chen,Niansong Zhang,Jiajie Li,Han Meng,Adrian Liu,Zhiru Zhang*

Main category: cs.PL

TL;DR: Dato是一个Python嵌入式任务编程模型，通过将数据通信和分片作为一等类型构造，简化数据流加速器编程，在NPU和FPGA上实现高性能和高硬件利用率


<details>
  <summary>Details</summary>
Motivation: 现代深度学习工作负载对计算需求日益增长，但现有编程模型难以有效利用数据流加速器的片上流处理能力，低层接口开发成本高，高层语言又限制了优化空间

Method: 提出任务图编程模型，通过显式流类型连接任务，使用布局类型指定分片输入，先在空间结构上进行虚拟映射，然后编译器生成符合硬件约束的物理映射

Result: 在AMD Ryzen AI NPU上实现84%的GEMM硬件利用率，注意力核函数相比最先进商业框架提速2.81倍；在FPGA上生成定制脉动阵列时达到理论峰值性能的98%

Conclusion: Dato编程模型能够显著降低编写优化代码的负担，同时在数据流加速器上实现高性能计算

Abstract: Recent deep learning workloads increasingly push computational demand beyond
what current memory systems can sustain, with many kernels stalling on data
movement rather than computation. While modern dataflow accelerators
incorporate on-chip streaming to mitigate off-chip bandwidth limitations,
existing programming models struggle to harness these capabilities effectively.
Low-level interfaces provide fine-grained control but impose significant
development overhead, whereas high-level tile-based languages abstract away
communication details, restricting optimization and forcing compilers to
reconstruct the intended dataflow. We present Dato, a Python-embedded,
task-based programming model for dataflow accelerators that elevates data
communication and sharding to first-class type constructs. Developers write
programs as a graph of tasks connected via explicit stream types, with sharded
inputs specified using layout types. These tasks are first mapped virtually
onto the accelerator's spatial fabric, and the compiler then generates a
physical mapping that respects hardware constraints. Experimental results on
both AMD Ryzen AI NPU and Alveo FPGA devices demonstrate that Dato achieves
high performance while significantly reducing the burden of writing optimized
code. On the NPU, Dato attains up to 84% hardware utilization for GEMM and
delivers a 2.81x speedup on attention kernels compared to a state-of-the-art
commercial framework. On the FPGA, Dato surpasses leading frameworks in
performance when generating custom systolic arrays, achieving 98% of the
theoretical peak performance.

</details>


### [6] [MIO: Multiverse Debugging in the Face of Input/Output -- Extended Version with Additional Appendices](https://arxiv.org/abs/2509.06845)
*Tom Lauwaerts,Maarten Steevens,Christophe Scholliers*

Main category: cs.PL

TL;DR: 这篇论文提出了一种新的多宇宙调试方法MIO，解决了微控制器上非确定性程序调试中输入/输出操作导致无法访问程序状态的问题。


<details>
  <summary>Details</summary>
Motivation: 现有多宇宙调试器在处理输入/输出操作时会导致程序员探索到无法达到的程序状态，这会质量调试过程并可能导致误判程序错误。

Method: 论文提出了一种新的多宇宙调试方法，能够支持广泛的输入/输出操作。研究人员提供了该方法的语义定义，并证明了调试器的正确性。开发了原型系统MIO，基于WARDuino WebAssembly虚拟机实现。

Result: MIO调试器确保只会探索在正常执行中可达到的程序状态，避免了无法访问状态的问题。通过一个Lego Mindstorms颜色调节器案例验证了该方法在STM32微控制器上的可行性和效率。

Conclusion: 该研究提供了一种能够有效处理输入/输出操作的多宇宙调试方法，解决了微控制器上非确定性程序调试的关键挑战，为微控制器程序调试提供了更加可靠的工具支持。

Abstract: Debugging non-deterministic programs on microcontrollers is notoriously
challenging, especially when bugs manifest in unpredictable, input-dependent
execution paths. A recent approach, called multiverse debugging, makes it
easier to debug non-deterministic programs by allowing programmers to explore
all potential execution paths. Current multiverse debuggers enable both forward
and backward traversal of program paths, and some facilitate jumping to any
previously visited states, potentially branching into alternative execution
paths within the state space.
  Unfortunately, debugging programs that involve input/output operations using
existing multiverse debuggers can reveal inaccessible program states, i.e.
states which are not encountered during regular execution. This can
significantly hinder the debugging process, as the programmer may spend
substantial time exploring and examining inaccessible program states, or worse,
may mistakenly assume a bug is present in the code, when in fact, the issue is
caused by the debugger.
  This paper presents a novel approach to multiverse debugging, which can
accommodate a broad spectrum of input/output operations. We provide the
semantics of our approach and prove the correctness of our debugger, ensuring
that despite having support for a wide range of input/output operations the
debugger will only explore those program states which can be reached during
regular execution.
  We have developed a prototype, called MIO, leveraging the WARDuino
WebAssembly virtual machine to demonstrate the feasibility and efficiency of
our techniques. As a demonstration of the approach we highlight a color dial
built with a Lego Mindstorms motor, and color sensor, providing a tangible
example of how our approach enables multiverse debugging for programs running
on an STM32 microcontroller.

</details>


### [7] [Mechanized Metatheory of Forward Reasoning for End-to-End Linearizability Proofs](https://arxiv.org/abs/2509.06872)
*Zachary Kent,Ugur Y. Yavuz,Siddhartha Jayanti,Stephanie Balzer,Guy Blelloch*

Main category: cs.PL

TL;DR: 本文形式化并机械化了Jayanti等人提出的前向推理线性化证明技术，在Rocq中验证其安全性和完备性，并通过并发寄存器案例进行验证。


<details>
  <summary>Details</summary>
Motivation: 虽然Jayanti等人提出了第一个声音完整的前向推理线性化证明技术，但其重要的形式化理论结果仍未得到机械化验证，导致无法生成验证的端到端线性化证明。

Method: 在Rocq中形式化前向推理技术，机械化其安全性和完备性证明，并使用该方法为简单并发寄存器生成验证的端到端线性化证明。

Result: 实现了前向推理技术的形式化和机械化验证，减少了可信计算基础的规模，并成功为并发寄存器生成了端到端的验证线性化证明。

Conclusion: 该工作填补了前向推理线性化证明技术形式化验证的空白，为生成验证的并发数据结构线性化证明提供了可靠基础。

Abstract: In the past decade, many techniques have been developed to prove
linearizability, the gold standard of correctness for concurrent data
structures. Intuitively, linearizability requires that every operation on a
concurrent data structure appears to take place instantaneously, even when
interleaved with other operations. Most recently, Jayanti et al. presented the
first sound and complete "forward reasoning" technique for proving
linearizability that relates the behavior of a concurrent data structure to a
reference atomic data structure as time moves forward. This technique can be
used to produce machine-checked proofs of linearizability in TLA+. However,
while Jayanti et al.'s approach is shown to be sound and complete, a
mechanization of this important metatheoretic result is still outstanding. As a
result, it is not possible to produce verified end-to-end proofs of
linearizability. To reduce the size of this trusted computing base, we
formalize this forward reasoning technique and mechanize proofs of its
soundness and completeness in Rocq. As a case study, we use the approach to
produce a verified end-to-end proof of linearizability for a simple concurrent
register.

</details>


<div id='math.CT'></div>

# math.CT [[Back]](#toc)

### [8] [The compact double category $\mathbf{Int}(\mathbf{Poly}_*)$ models control flow and data transformations](https://arxiv.org/abs/2509.05462)
*Grigory Kondyrev,David I. Spivak*

Main category: math.CT

TL;DR: Error


<details>
  <summary>Details</summary>
Motivation: Error

Method: Error

Result: Error

Conclusion: Error

Abstract: Hasegawa showed that control flow in programming languages -- while loops and
if-then-else statements -- can be modeled using traced cocartesian categories,
such as the category $\mathbf{Set}_*$ of pointed sets. In this paper we define
an operad $\mathscr{W}$ of wiring diagrams that provides syntax for categories
whose control flow moreover includes data transformations, including deleting,
duplicating, permuting, and applying pre-specified functions to variables. In
the most basic version, the operad underlies $\mathbf{Int}(\mathbf{Poly}_*)$,
where $\mathbf{Int}(\mathscr{T})$ denotes the free compact category on a traced
category $\mathscr{T}$, as defined by Joyal, Street, and Verity; to do so, we
show that $\mathbf{Poly}_*$, as well as any multivariate version of it, is
traced. We show moreover that whenever $\mathscr{T}$ is uniform -- a condition
also defined by Hasegawa and satisfied by $\mathbf{Int}(\mathscr{T})$ -- the
resulting $\mathbf{Int}$-construction extends to a double category
$\mathbb{I}\mathbf{nt}(\mathscr{T})$, which is compact in the sense of
Patterson. Finally, we define a universal property of the double category
$\mathbb{I}\mathbf{nt}(\mathbf{Poly}_*)$ and
$\mathbb{I}\mathbf{nt}(\mathbf{Set}_*)$ by which one can track trajectories as
they move through the control flow associated to a wiring diagram.

</details>
