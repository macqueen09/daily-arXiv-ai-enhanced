<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.CR](#cs.CR) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [XML Prompting as Grammar-Constrained Interaction: Fixed-Point Semantics, Convergence Guarantees, and Human-AI Protocols](https://arxiv.org/abs/2509.08182)
*Faruk Alpay,Taylan Alpay*

Main category: cs.PL

TL;DR: 本文提出了一个基于XML标签的结构化提示逻辑框架，统一了语法约束解码、分层提示的固定点语义以及人机交互循环，并提供了数学证明和实际应用模式。


<details>
  <summary>Details</summary>
Motivation: 结构化提示在引导大语言模型生成可解析、符合模式要求的输出方面效果显著，但缺乏统一的理论框架来整合语法约束解码、固定点语义和收敛性的人机交互循环。

Method: 开发了基于XML提示的逻辑优先处理方法，定义了XML树的完整格结构，证明了单调提示算子的最小固定点存在性，并实例化了上下文无关文法的XML模式约束解码。

Result: 建立了完整的数学理论框架，证明了在精化序下的收敛性，展示了多层人机交互模式（如规划→验证→修订流程）和工具使用的实际部署方案。

Conclusion: 该框架为结构化提示提供了坚实的理论基础，将语法对齐解码、验证链和程序化提示等最新进展统一起来，确保了输出的良好格式和任务性能。

Abstract: Structured prompting with XML tags has emerged as an effective way to steer
large language models (LLMs) toward parseable, schema-adherent outputs in
real-world systems. We develop a logic-first treatment of XML prompting that
unifies (i) grammar-constrained decoding, (ii) fixed-point semantics over
lattices of hierarchical prompts, and (iii) convergent human-AI interaction
loops. We formalize a complete lattice of XML trees under a refinement order
and prove that monotone prompt-to-prompt operators admit least fixed points
(Knaster-Tarski) that characterize steady-state protocols; under a task-aware
contraction metric on trees, we further prove Banach-style convergence of
iterative guidance. We instantiate these results with context-free grammars
(CFGs) for XML schemas and show how constrained decoding guarantees
well-formedness while preserving task performance. A set of multi-layer
human-AI interaction recipes demonstrates practical deployment patterns,
including multi-pass "plan $\to$ verify $\to$ revise" routines and agentic tool
use. We provide mathematically complete proofs and tie our framework to recent
advances in grammar-aligned decoding, chain-of-verification, and programmatic
prompting.

</details>


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [2] [Securing Cryptographic Software via Typed Assembly Language (Extended Version)](https://arxiv.org/abs/2509.08727)
*Shixin Song,Tingzhen Dong,Kosi Nwabueze,Julian Zanders,Andres Erbsen,Adam Chlipala,Mengjia Yan*

Main category: cs.CR

TL;DR: SecSep是一个汇编级转换框架，通过栈数据分区和Octal类型化汇编语言来防御Spectre类推测执行攻击，平均开销仅1.2%


<details>
  <summary>Details</summary>
Motivation: 现有源代码标注方法无法正确跟踪栈上的秘密数据，存在性能开销问题，需要更有效的防御Spectre推测执行攻击的方案

Method: 开发SecSep转换框架，使用新型Octal类型化汇编语言进行编译时推断，重写汇编程序实现栈上秘密与公开数据分区

Result: 成功应用于密码程序，实现安全推测执行，平均性能开销仅为1.2%

Conclusion: 汇编级重写方法比源代码标注更有效，Octal类型化汇编语言解决了编译过程中语义信息丢失的挑战，能以低开销实现安全推测

Abstract: Authors of cryptographic software are well aware that their code should not
leak secrets through its timing behavior, and, until 2018, they believed that
following industry-standard constant-time coding guidelines was sufficient.
However, the revelation of the Spectre family of speculative execution attacks
injected new complexities.
  To block speculative attacks, prior work has proposed annotating the
program's source code to mark secret data, with hardware using this information
to decide when to speculate (i.e., when only public values are involved) or not
(when secrets are in play). While these solutions are able to track secret
information stored on the heap, they suffer from limitations that prevent them
from correctly tracking secrets on the stack, at a cost in performance.
  This paper introduces SecSep, a transformation framework that rewrites
assembly programs so that they partition secret and public data on the stack.
By moving from the source-code level to assembly rewriting, SecSep is able to
address limitations of prior work. The key challenge in performing this
assembly rewriting stems from the loss of semantic information through the
lengthy compilation process. The key innovation of our methodology is a new
variant of typed assembly language (TAL), Octal, which allows us to address
this challenge. Assembly rewriting is driven by compile-time inference within
Octal. We apply our technique to cryptographic programs and demonstrate that it
enables secure speculation efficiently, incurring a low average overhead of
$1.2\%$.

</details>


### [3] [Approximate Algorithms for Verifying Differential Privacy with Gaussian Distributions](https://arxiv.org/abs/2509.08804)
*Bishnu Bhusal,Rohit Chadha,A. Prasad Sistla,Mahesh Viswanathan*

Main category: cs.CR

TL;DR: 本文提出了一种验证使用高斯分布的差分隐私算法的新方法，通过近似概率分布来解决验证问题，并证明对于这类程序，验证(ε,δ)-差分隐私几乎是可判定的。


<details>
  <summary>Details</summary>
Motivation: 高斯分布差分隐私算法的验证问题缺乏深入理解，现有方法难以有效验证这类程序的隐私保证。

Method: 引入近似概率分布的新方法，结合积分近似和尾部概率边界计算概率，使用FLINT库进行高精度积分计算，并实现优化以提高可扩展性。

Result: 开发了DipApprox工具，在基础隐私保护算法（如高斯稀疏向量技术和噪声最大值变体）上验证了方法的有效性，既能确认隐私保证也能检测违规。

Conclusion: 该方法为验证高斯分布差分隐私程序提供了有效的解决方案，证明了(ε,δ)-差分隐私验证问题几乎是可判定的。

Abstract: The verification of differential privacy algorithms that employ Gaussian
distributions is little understood. This paper tackles the challenge of
verifying such programs by introducing a novel approach to approximating
probability distributions of loop-free programs that sample from both discrete
and continuous distributions with computable probability density functions,
including Gaussian and Laplace. We establish that verifying
$(\epsilon,\delta)$-differential privacy for these programs is \emph{almost
decidable}, meaning the problem is decidable for all values of $\delta$ except
those in a finite set. Our verification algorithm is based on computing
probabilities to any desired precision by combining integral approximations,
and tail probability bounds. The proposed methods are implemented in the tool,
DipApprox, using the FLINT library for high-precision integral computations,
and incorporate optimizations to enhance scalability. We validate {\ourtool} on
fundamental privacy-preserving algorithms, such as Gaussian variants of the
Sparse Vector Technique and Noisy Max, demonstrating its effectiveness in both
confirming privacy guarantees and detecting violations.

</details>
