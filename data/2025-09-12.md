<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Towards Verified Compilation of Floating-point Optimization in Scientific Computing Programs](https://arxiv.org/abs/2509.09019)
*Mohit Tekriwal,John Sarracino*

Main category: cs.PL

TL;DR: 通过验证LLVM框架证明浮点数优化的正确性，首先实现了FMA优化的验证，并提出扩展更多程序特征和优化方法的方案


<details>
  <summary>Details</summary>
Motivation: 科学计算程序需要高性能编译优化，但必须确保浮点数优化的正确性，特别是fast math优化

Method: 利用Rocq定理证明器中的Verified LLVM框架，证明基本块中算术表达式 $a * b + c$ 的FMA融合乘加优化的正确性

Result: 成功实现了FMA优化的形式化验证，为更复杂的浮点数优化提供了基础

Conclusion: 该初步工作为验证LLVM浮点数优化的正确性开启了新方向，未来可扩展到更多程序特征和优化方法

Abstract: Scientific computing programs often undergo aggressive compiler optimization
to achieve high performance and efficient resource utilization. While
performance is critical, we also need to ensure that these optimizations are
correct. In this paper, we focus on a specific class of optimizations,
floating-point optimizations, notably due to fast math, at the LLVM IR level.
We present a preliminary work, which leverages the Verified LLVM framework in
the Rocq theorem prover, to prove the correctness of Fused-Multiply-Add (FMA)
optimization for a basic block implementing the arithmetic expression $a * b +
c$ . We then propose ways to extend this preliminary results by adding more
program features and fast math floating-point optimizations.

</details>


### [2] [Dependent-Type-Preserving Memory Allocation](https://arxiv.org/abs/2509.09059)
*Paulette Koronkevich,William J. Bowman*

Main category: cs.PL

TL;DR: 本文针对依赖类型语言编译后类型规范被擦除的问题，提出了类型保持编译方法，开发了支持依赖内存分配的中间语言和编译器传递，以确保链接时类型检查能防止外部程序违反原程序规范。


<details>
  <summary>Details</summary>
Motivation: 依赖类型语言（如Coq、Agda等）在编译后会擦除类型规范，导致外部链接程序可能违反原程序的规范，即使使用验证编译器也无法避免。例如，Coq程序链接C程序时，C程序可能提供未初始化指针，违反内存安全规范。

Method: 开发支持依赖内存分配的类型化中间语言，以及保持依赖类型的内存分配编译器传递，通过类型保持编译确保链接时能进行类型检查，防止与类型不正确的程序链接。

Result: 本文是进行中的工作，提出了类型保持编译的框架和方法，具体包括依赖内存分配的中间语言设计和编译器传递开发。

Conclusion: 通过类型保持编译方法，可以在链接阶段进行类型检查，有效防止外部程序违反依赖类型程序的规范，提升编译后程序的安全性。

Abstract: Dependently typed programming languages such as Coq, Agda, Idris, and F*,
allow programmers to write detailed specifications of their programs and prove
their programs meet these specifications. However, these specifications can be
violated during compilation since they are erased after type checking. External
programs linked with the compiled program can violate the specifications of the
original program and change the behavior of the compiled program -- even when
compiled with a verified compiler. For example, since Coq does not allow
explicitly allocating memory, a programmer might link their Coq program with a
C program that can allocate memory. Even if the Coq program is compiled with a
verified compiler, the external C program can still violate the memory-safe
specification of the Coq program by providing an uninitialized pointer to
memory. This error could be ruled out by type checking in a language expressive
enough to indicate whether memory is initialized versus uninitialized. Linking
with a program with an uninitialized pointer could be considered ill-typed, and
our linking process could prevent linking with ill-typed programs. To
facilitate type checking during linking, we can use type-preserving
compilation, which preserves the types through the compilation process. In this
ongoing work, we develop a typed intermediate language that supports dependent
memory allocation, as well as a dependent-type-preserving compiler pass for
memory allocation.

</details>
