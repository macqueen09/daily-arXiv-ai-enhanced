<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Towards Verified Compilation of Floating-point Optimization in Scientific Computing Programs](https://arxiv.org/abs/2509.09019)
*Mohit Tekriwal,John Sarracino*

Main category: cs.PL

TL;DR: 利用Rocq定理证明器中的Verified LLVM框架，证明LLVM IR层次浮点数优化（特别是FMA优化）的正确性，并提出扩展方案


<details>
  <summary>Details</summary>
Motivation: 科学计算程序需要高性能编译优化，但必须确保浮点数优化的正确性，特别是fast math优化

Method: 基于Rocq定理证明器中的Verified LLVM框架，对基本块实现算术表达式a a*b+c 进行FMA优化正确性证明

Result: 完成了FMA优化正确性的初步证明工作

Conclusion: 这是一个初步研究，为了扩展更多程序特性和浮点数优化的正确性验证基础

Abstract: Scientific computing programs often undergo aggressive compiler optimization
to achieve high performance and efficient resource utilization. While
performance is critical, we also need to ensure that these optimizations are
correct. In this paper, we focus on a specific class of optimizations,
floating-point optimizations, notably due to fast math, at the LLVM IR level.
We present a preliminary work, which leverages the Verified LLVM framework in
the Rocq theorem prover, to prove the correctness of Fused-Multiply-Add (FMA)
optimization for a basic block implementing the arithmetic expression $a * b +
c$ . We then propose ways to extend this preliminary results by adding more
program features and fast math floating-point optimizations.

</details>


### [2] [Dependent-Type-Preserving Memory Allocation](https://arxiv.org/abs/2509.09059)
*Paulette Koronkevich,William J. Bowman*

Main category: cs.PL

TL;DR: 本文探讨依赖类型语言在编译后规范被擦除导致的安全问题，提出通过类型保持编译和依赖内存分配的中间语言来解决外部程序链接时的类型违规问题。


<details>
  <summary>Details</summary>
Motivation: 依赖类型语言如Coq、Agda等允许程序员编写详细规范并证明程序符合规范，但这些规范在编译后被擦除，导致外部链接程序可能违反原始程序的规范，即使使用验证编译器也无法避免。

Method: 开发支持依赖内存分配的类型化中间语言，以及依赖类型保持的编译器传递来处理内存分配，通过类型检查链接过程来防止与类型不正确的程序链接。

Result: 这是一个进行中的工作，提出了类型保持编译的解决方案框架，但具体实现结果尚未公布。

Conclusion: 通过类型保持编译和依赖类型中间语言，可以在链接阶段进行类型检查，确保外部程序不会违反原始程序的依赖类型规范，提高编译后程序的安全性。

Abstract: Dependently typed programming languages such as Coq, Agda, Idris, and F*,
allow programmers to write detailed specifications of their programs and prove
their programs meet these specifications. However, these specifications can be
violated during compilation since they are erased after type checking. External
programs linked with the compiled program can violate the specifications of the
original program and change the behavior of the compiled program -- even when
compiled with a verified compiler. For example, since Coq does not allow
explicitly allocating memory, a programmer might link their Coq program with a
C program that can allocate memory. Even if the Coq program is compiled with a
verified compiler, the external C program can still violate the memory-safe
specification of the Coq program by providing an uninitialized pointer to
memory. This error could be ruled out by type checking in a language expressive
enough to indicate whether memory is initialized versus uninitialized. Linking
with a program with an uninitialized pointer could be considered ill-typed, and
our linking process could prevent linking with ill-typed programs. To
facilitate type checking during linking, we can use type-preserving
compilation, which preserves the types through the compilation process. In this
ongoing work, we develop a typed intermediate language that supports dependent
memory allocation, as well as a dependent-type-preserving compiler pass for
memory allocation.

</details>
