<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Towards Verified Compilation of Floating-point Optimization in Scientific Computing Programs](https://arxiv.org/abs/2509.09019)
*Mohit Tekriwal,John Sarracino*

Main category: cs.PL

TL;DR: 通过验证LLVM框架在Rocq定理证明器中证明浮点数FMA优化的正确性，并提出扩展更多程序特性和快速数学优化的方向


<details>
  <summary>Details</summary>
Motivation: 科学计算程序需要终端的编译器优化来获得高性能，但同时必须确保这些优化的正确性，特别是浮点数优化

Method: 利用Rocq定理证明器中的Verified LLVM框架，证明FMA优化在基本块实现算术表达式$a * b + c$时的正确性

Result: 完成了FMA优化正确性的初步验证工作

Conclusion: 该研究为验证浮点数优化正确性提供了基础，并提出了扩展更多程序特性和快速数学优化的方向

Abstract: Scientific computing programs often undergo aggressive compiler optimization
to achieve high performance and efficient resource utilization. While
performance is critical, we also need to ensure that these optimizations are
correct. In this paper, we focus on a specific class of optimizations,
floating-point optimizations, notably due to fast math, at the LLVM IR level.
We present a preliminary work, which leverages the Verified LLVM framework in
the Rocq theorem prover, to prove the correctness of Fused-Multiply-Add (FMA)
optimization for a basic block implementing the arithmetic expression $a * b +
c$ . We then propose ways to extend this preliminary results by adding more
program features and fast math floating-point optimizations.

</details>


### [2] [Dependent-Type-Preserving Memory Allocation](https://arxiv.org/abs/2509.09059)
*Paulette Koronkevich,William J. Bowman*

Main category: cs.PL

TL;DR: 本文提出了一种类型保持编译方法，通过在链接阶段进行类型检查来防止依赖类型语言编译后与外部程序链接时违反规范的问题。


<details>
  <summary>Details</summary>
Motivation: 依赖类型语言（如Coq、Agda等）的程序在编译后与外部程序链接时，原始程序的规范可能被违反，即使使用验证编译器也无法避免。例如，Coq程序与C程序链接时，C程序可能提供未初始化的内存指针，违反内存安全规范。

Method: 开发支持依赖内存分配的中间语言，并实现依赖类型保持的编译器传递来处理内存分配，通过在链接过程中进行类型检查来防止与类型不正确的程序链接。

Result: 这是一个进行中的工作，提出了类型保持编译的框架来解决链接时的类型安全问题。

Conclusion: 类型保持编译可以确保依赖类型程序的规范在编译和链接过程中得到保持，防止外部程序违反原始程序的类型规范。

Abstract: Dependently typed programming languages such as Coq, Agda, Idris, and F*,
allow programmers to write detailed specifications of their programs and prove
their programs meet these specifications. However, these specifications can be
violated during compilation since they are erased after type checking. External
programs linked with the compiled program can violate the specifications of the
original program and change the behavior of the compiled program -- even when
compiled with a verified compiler. For example, since Coq does not allow
explicitly allocating memory, a programmer might link their Coq program with a
C program that can allocate memory. Even if the Coq program is compiled with a
verified compiler, the external C program can still violate the memory-safe
specification of the Coq program by providing an uninitialized pointer to
memory. This error could be ruled out by type checking in a language expressive
enough to indicate whether memory is initialized versus uninitialized. Linking
with a program with an uninitialized pointer could be considered ill-typed, and
our linking process could prevent linking with ill-typed programs. To
facilitate type checking during linking, we can use type-preserving
compilation, which preserves the types through the compilation process. In this
ongoing work, we develop a typed intermediate language that supports dependent
memory allocation, as well as a dependent-type-preserving compiler pass for
memory allocation.

</details>
