{"id": "2509.09019", "pdf": "https://arxiv.org/pdf/2509.09019", "abs": "https://arxiv.org/abs/2509.09019", "authors": ["Mohit Tekriwal", "John Sarracino"], "title": "Towards Verified Compilation of Floating-point Optimization in Scientific Computing Programs", "categories": ["cs.PL"], "comment": null, "summary": "Scientific computing programs often undergo aggressive compiler optimization\nto achieve high performance and efficient resource utilization. While\nperformance is critical, we also need to ensure that these optimizations are\ncorrect. In this paper, we focus on a specific class of optimizations,\nfloating-point optimizations, notably due to fast math, at the LLVM IR level.\nWe present a preliminary work, which leverages the Verified LLVM framework in\nthe Rocq theorem prover, to prove the correctness of Fused-Multiply-Add (FMA)\noptimization for a basic block implementing the arithmetic expression $a * b +\nc$ . We then propose ways to extend this preliminary results by adding more\nprogram features and fast math floating-point optimizations.", "AI": {"tldr": "\u901a\u8fc7\u9a8c\u8bc1LLVM\u6846\u67b6\u5728Rocq\u5b9a\u7406\u8bc1\u660e\u5668\u4e2d\u8bc1\u660e\u6d6e\u70b9\u6570FMA\u4f18\u5316\u7684\u6b63\u786e\u6027\uff0c\u5e76\u63d0\u51fa\u6269\u5c55\u66f4\u591a\u7a0b\u5e8f\u7279\u6027\u548c\u5feb\u901f\u6570\u5b66\u4f18\u5316\u7684\u65b9\u5411", "motivation": "\u79d1\u5b66\u8ba1\u7b97\u7a0b\u5e8f\u9700\u8981\u7ec8\u7aef\u7684\u7f16\u8bd1\u5668\u4f18\u5316\u6765\u83b7\u5f97\u9ad8\u6027\u80fd\uff0c\u4f46\u540c\u65f6\u5fc5\u987b\u786e\u4fdd\u8fd9\u4e9b\u4f18\u5316\u7684\u6b63\u786e\u6027\uff0c\u7279\u522b\u662f\u6d6e\u70b9\u6570\u4f18\u5316", "method": "\u5229\u7528Rocq\u5b9a\u7406\u8bc1\u660e\u5668\u4e2d\u7684Verified LLVM\u6846\u67b6\uff0c\u8bc1\u660eFMA\u4f18\u5316\u5728\u57fa\u672c\u5757\u5b9e\u73b0\u7b97\u672f\u8868\u8fbe\u5f0f$a * b + c$\u65f6\u7684\u6b63\u786e\u6027", "result": "\u5b8c\u6210\u4e86FMA\u4f18\u5316\u6b63\u786e\u6027\u7684\u521d\u6b65\u9a8c\u8bc1\u5de5\u4f5c", "conclusion": "\u8be5\u7814\u7a76\u4e3a\u9a8c\u8bc1\u6d6e\u70b9\u6570\u4f18\u5316\u6b63\u786e\u6027\u63d0\u4f9b\u4e86\u57fa\u7840\uff0c\u5e76\u63d0\u51fa\u4e86\u6269\u5c55\u66f4\u591a\u7a0b\u5e8f\u7279\u6027\u548c\u5feb\u901f\u6570\u5b66\u4f18\u5316\u7684\u65b9\u5411"}}
{"id": "2509.09059", "pdf": "https://arxiv.org/pdf/2509.09059", "abs": "https://arxiv.org/abs/2509.09059", "authors": ["Paulette Koronkevich", "William J. Bowman"], "title": "Dependent-Type-Preserving Memory Allocation", "categories": ["cs.PL"], "comment": "Submitted and received second place at the Student Research\n  Competition at Principles of Programming Languages 2022", "summary": "Dependently typed programming languages such as Coq, Agda, Idris, and F*,\nallow programmers to write detailed specifications of their programs and prove\ntheir programs meet these specifications. However, these specifications can be\nviolated during compilation since they are erased after type checking. External\nprograms linked with the compiled program can violate the specifications of the\noriginal program and change the behavior of the compiled program -- even when\ncompiled with a verified compiler. For example, since Coq does not allow\nexplicitly allocating memory, a programmer might link their Coq program with a\nC program that can allocate memory. Even if the Coq program is compiled with a\nverified compiler, the external C program can still violate the memory-safe\nspecification of the Coq program by providing an uninitialized pointer to\nmemory. This error could be ruled out by type checking in a language expressive\nenough to indicate whether memory is initialized versus uninitialized. Linking\nwith a program with an uninitialized pointer could be considered ill-typed, and\nour linking process could prevent linking with ill-typed programs. To\nfacilitate type checking during linking, we can use type-preserving\ncompilation, which preserves the types through the compilation process. In this\nongoing work, we develop a typed intermediate language that supports dependent\nmemory allocation, as well as a dependent-type-preserving compiler pass for\nmemory allocation.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u7c7b\u578b\u4fdd\u6301\u7f16\u8bd1\u65b9\u6cd5\uff0c\u901a\u8fc7\u5728\u94fe\u63a5\u9636\u6bb5\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u6765\u9632\u6b62\u4f9d\u8d56\u7c7b\u578b\u8bed\u8a00\u7f16\u8bd1\u540e\u4e0e\u5916\u90e8\u7a0b\u5e8f\u94fe\u63a5\u65f6\u8fdd\u53cd\u89c4\u8303\u7684\u95ee\u9898\u3002", "motivation": "\u4f9d\u8d56\u7c7b\u578b\u8bed\u8a00\uff08\u5982Coq\u3001Agda\u7b49\uff09\u7684\u7a0b\u5e8f\u5728\u7f16\u8bd1\u540e\u4e0e\u5916\u90e8\u7a0b\u5e8f\u94fe\u63a5\u65f6\uff0c\u539f\u59cb\u7a0b\u5e8f\u7684\u89c4\u8303\u53ef\u80fd\u88ab\u8fdd\u53cd\uff0c\u5373\u4f7f\u4f7f\u7528\u9a8c\u8bc1\u7f16\u8bd1\u5668\u4e5f\u65e0\u6cd5\u907f\u514d\u3002\u4f8b\u5982\uff0cCoq\u7a0b\u5e8f\u4e0eC\u7a0b\u5e8f\u94fe\u63a5\u65f6\uff0cC\u7a0b\u5e8f\u53ef\u80fd\u63d0\u4f9b\u672a\u521d\u59cb\u5316\u7684\u5185\u5b58\u6307\u9488\uff0c\u8fdd\u53cd\u5185\u5b58\u5b89\u5168\u89c4\u8303\u3002", "method": "\u5f00\u53d1\u652f\u6301\u4f9d\u8d56\u5185\u5b58\u5206\u914d\u7684\u4e2d\u95f4\u8bed\u8a00\uff0c\u5e76\u5b9e\u73b0\u4f9d\u8d56\u7c7b\u578b\u4fdd\u6301\u7684\u7f16\u8bd1\u5668\u4f20\u9012\u6765\u5904\u7406\u5185\u5b58\u5206\u914d\uff0c\u901a\u8fc7\u5728\u94fe\u63a5\u8fc7\u7a0b\u4e2d\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u6765\u9632\u6b62\u4e0e\u7c7b\u578b\u4e0d\u6b63\u786e\u7684\u7a0b\u5e8f\u94fe\u63a5\u3002", "result": "\u8fd9\u662f\u4e00\u4e2a\u8fdb\u884c\u4e2d\u7684\u5de5\u4f5c\uff0c\u63d0\u51fa\u4e86\u7c7b\u578b\u4fdd\u6301\u7f16\u8bd1\u7684\u6846\u67b6\u6765\u89e3\u51b3\u94fe\u63a5\u65f6\u7684\u7c7b\u578b\u5b89\u5168\u95ee\u9898\u3002", "conclusion": "\u7c7b\u578b\u4fdd\u6301\u7f16\u8bd1\u53ef\u4ee5\u786e\u4fdd\u4f9d\u8d56\u7c7b\u578b\u7a0b\u5e8f\u7684\u89c4\u8303\u5728\u7f16\u8bd1\u548c\u94fe\u63a5\u8fc7\u7a0b\u4e2d\u5f97\u5230\u4fdd\u6301\uff0c\u9632\u6b62\u5916\u90e8\u7a0b\u5e8f\u8fdd\u53cd\u539f\u59cb\u7a0b\u5e8f\u7684\u7c7b\u578b\u89c4\u8303\u3002"}}
