{"id": "2509.11418", "pdf": "https://arxiv.org/pdf/2509.11418", "abs": "https://arxiv.org/abs/2509.11418", "authors": ["Runming Li", "Yue Yao", "Robert Harper"], "title": "Mechanizing Synthetic Tait Computability in Istari", "categories": ["cs.PL"], "comment": null, "summary": "Categorical gluing is a powerful technique for proving meta-theorems of type\ntheories such as canonicity and normalization. Synthetic Tait Computability\n(STC) provides an abstract treatment of the complex gluing models by\ninternalizing the gluing category into a modal dependent type theory with a\nphase distinction. This work presents a mechanization of STC in the Istari\nproof assistant. Istari is a Martin-L\\\"{o}f-style extensional type theory with\nequality reflection. Equality reflection eliminates the nuisance of transport\nreasoning typically found in intensional proof assistants. This work develops a\nreusable library for synthetic phase distinction, including modalities,\nextension types, and strict glue types, and applies it to two case studies: (1)\na canonicity model for dependent type theory with dependent products and\nbooleans with large elimination, and (2) a Kripke canonicity model for the\ncost-aware logical framework. Our results demonstrate that the core STC\nconstructions can be formalized essentially verbatim in Istari, preserving the\nelegance of the on-paper arguments while ensuring machine-checked correctness."}
{"id": "2509.11901", "pdf": "https://arxiv.org/pdf/2509.11901", "abs": "https://arxiv.org/abs/2509.11901", "authors": ["Kentaro Kobayashi", "Yukiyoshi Kameyama"], "title": "Expressive Power of One-Shot Control Operators and Coroutines", "categories": ["cs.PL", "cs.LO"], "comment": "Full version of the paper accepted at APLAS 2025. Includes appendices\n  with proofs. 59 pages", "summary": "Control operators, such as exceptions and effect handlers, provide a means of\nrepresenting computational effects in programs abstractly and modularly. While\nmost theoretical studies have focused on multi-shot control operators, one-shot\ncontrol operators -- which restrict the use of captured continuations to at\nmost once -- are gaining attention for their balance between expressiveness and\nefficiency. This study aims to fill the gap. We present a mathematically\nrigorous comparison of the expressive power among one-shot control operators,\nincluding effect handlers, delimited continuations, and even asymmetric\ncoroutines. Following previous studies on multi-shot control operators, we\nadopt Felleisen's macro-expressiveness as our measure of expressiveness. We\nverify the folklore that one-shot effect handlers and one-shot\ndelimited-control operators can be macro-expressed by asymmetric coroutines,\nbut not vice versa. We explain why a previous informal argument fails, and how\nto revise it to make a valid macro-translation."}
{"id": "2201.06325", "pdf": "https://arxiv.org/pdf/2201.06325", "abs": "https://arxiv.org/abs/2201.06325", "authors": ["Umang Mathur", "Andreas Pavlogiannis", "Hünkar Can Tunç", "Mahesh Viswanathan"], "title": "A Tree Clock Data Structure for Causal Orderings in Concurrent Executions", "categories": ["cs.LO", "cs.DC", "cs.DS", "cs.PL", "cs.SE"], "comment": null, "summary": "Dynamic techniques are a scalable and effective way to analyze concurrent\nprograms. Instead of analyzing all behaviors of a program, these techniques\ndetect errors by focusing on a single program execution. Often a crucial step\nin these techniques is to define a causal ordering between events in the\nexecution, which is then computed using vector clocks, a simple data structure\nthat stores logical times of threads. The two basic operations of vector\nclocks, namely join and copy, require $\\Theta(k)$ time, where $k$ is the number\nof threads. Thus they are a computational bottleneck when $k$ is large.\n  In this work, we introduce tree clocks, a new data structure that replaces\nvector clocks for computing causal orderings in program executions. Joining and\ncopying tree clocks takes time that is roughly proportional to the number of\nentries being modified, and hence the two operations do not suffer the a-priori\n$\\Theta(k)$ cost per application. We show that when used to compute the classic\nhappens-before (HB) partial order, tree clocks are optimal, in the sense that\nno other data structure can lead to smaller asymptotic running time. Moreover,\nwe demonstrate that tree clocks can be used to compute other partial orders,\nsuch as schedulable-happens-before (SHB) and the standard Mazurkiewicz (MAZ)\npartial order, and thus are a versatile data structure. Our experiments show\nthat just by replacing vector clocks with tree clocks, the computation becomes\nfrom $2.02 \\times$ faster (MAZ) to $2.66 \\times$ (SHB) and $2.97 \\times$ (HB)\non average per benchmark. These results illustrate that tree clocks have the\npotential to become a standard data structure with wide applications in\nconcurrent analyses."}
{"id": "2509.10694", "pdf": "https://arxiv.org/pdf/2509.10694", "abs": "https://arxiv.org/abs/2509.10694", "authors": ["Kahfi S. Zulkifli", "Wenbo Qian", "Shaowei Zhu", "Yuan Zhou", "Zhen Zhang", "Chang Lou"], "title": "Verifying Computational Graphs in Production-Grade Distributed Machine Learning Frameworks", "categories": ["cs.LG", "cs.PL"], "comment": null, "summary": "Modern machine learning frameworks support very large models by incorporating\nparallelism and optimization techniques. Yet, these very techniques add new\nlayers of complexity, introducing silent errors that severely degrade model\nperformance. Existing solutions are either ad hoc or too costly for production.\n  We present Scalify, a lightweight framework that exposes silent errors by\nverifying semantic equivalence of computational graphs using equality\nsaturation and Datalog-style reasoning. To scale, Scalify partitions graphs\nwith parallel rewriting and layer memoization, reuses rewrite templates, and\naugments equality saturation with relational reasoning and symbolic bijection\ninference. It further localizes discrepancies to precise code sites, turning\nverification results into actionable debugging guidance. Scalify verifies\nmodels as large as Llama-3.1-405B within minutes on a commodity machine and\nexposed five unknown bugs in Amazon production machine learning frameworks."}
{"id": "2509.10819", "pdf": "https://arxiv.org/pdf/2509.10819", "abs": "https://arxiv.org/abs/2509.10819", "authors": ["Christoph Hochrainer", "Valentin Wüstholz", "Maria Christakis"], "title": "Arguzz: Testing zkVMs for Soundness and Completeness Bugs", "categories": ["cs.SE", "cs.CR", "cs.PL"], "comment": null, "summary": "Zero-knowledge virtual machines (zkVMs) are increasingly deployed in\ndecentralized applications and blockchain rollups since they enable verifiable\noff-chain computation. These VMs execute general-purpose programs, frequently\nwritten in Rust, and produce succinct cryptographic proofs. However, zkVMs are\ncomplex, and bugs in their constraint systems or execution logic can cause\ncritical soundness (accepting invalid executions) or completeness (rejecting\nvalid ones) issues.\n  We present Arguzz, the first automated tool for testing zkVMs for soundness\nand completeness bugs. To detect such bugs, Arguzz combines a novel variant of\nmetamorphic testing with fault injection. In particular, it generates\nsemantically equivalent program pairs, merges them into a single Rust program\nwith a known output, and runs it inside a zkVM. By injecting faults into the\nVM, Arguzz mimics malicious or buggy provers to uncover overly weak\nconstraints.\n  We used Arguzz to test six real-world zkVMs (RISC Zero, Nexus, Jolt, SP1,\nOpenVM, and Pico) and found eleven bugs in three of them. One RISC Zero bug\nresulted in a $50,000 bounty, despite prior audits, demonstrating the critical\nneed for systematic testing of zkVMs."}
{"id": "2509.11065", "pdf": "https://arxiv.org/pdf/2509.11065", "abs": "https://arxiv.org/abs/2509.11065", "authors": ["Yuan Si", "Daming Li", "Hanyuan Shi", "Jialu Zhang"], "title": "ViScratch: Using Large Language Models and Gameplay Videos for Automated Feedback in Scratch", "categories": ["cs.SE", "cs.PL"], "comment": null, "summary": "Block-based programming environments such as Scratch are increasingly popular\nin programming education, in particular for young learners. While the use of\nblocks helps prevent syntax errors, semantic bugs remain common and difficult\nto debug. Existing tools for Scratch debugging rely heavily on predefined rules\nor user manual inputs, and crucially, they ignore the platform's inherently\nvisual nature.\n  We introduce ViScratch, the first multimodal feedback generation system for\nScratch that leverages both the project's block code and its generated gameplay\nvideo to diagnose and repair bugs. ViScratch uses a two-stage pipeline: a\nvision-language model first aligns visual symptoms with code structure to\nidentify a single critical issue, then proposes minimal, abstract syntax tree\nlevel repairs that are verified via execution in the Scratch virtual machine.\n  We evaluate ViScratch on a set of real-world Scratch projects against\nstate-of-the-art LLM-based tools and human testers. Results show that gameplay\nvideo is a crucial debugging signal: ViScratch substantially outperforms prior\ntools in both bug identification and repair quality, even without access to\nproject descriptions or goals. This work demonstrates that video can serve as a\nfirst-class specification in visual programming environments, opening new\ndirections for LLM-based debugging beyond symbolic code alone."}
{"id": "2509.11559", "pdf": "https://arxiv.org/pdf/2509.11559", "abs": "https://arxiv.org/abs/2509.11559", "authors": ["Tarakaram Gollamudi", "Anitha Gollamudi", "Joshua Gancher"], "title": "ILA: Correctness via Type Checking for Fully Homomorphic Encryption", "categories": ["cs.CR", "cs.PL"], "comment": null, "summary": "RLWE-based Fully Homomorphic Encryption (FHE) schemes add some small\n\\emph{noise} to the message during encryption. The noise accumulates with each\nhomomorphic operation. When the noise exceeds a critical value, the FHE circuit\nproduces an incorrect output. This makes developing FHE applications quite\nsubtle, as one must closely track the noise to ensure correctness. However,\nexisting libraries and compilers offer limited support to statically track the\nnoise. Additionally, FHE circuits are also plagued by wraparound errors that\nare common in finite modulus arithmetic. These two limitations of existing\ncompilers and libraries make FHE applications too difficult to develop with\nconfidence.\n  In this work, we present a \\emph{correctness-oriented} IR, Intermediate\nLanguage for Arithmetic circuits, for type-checking circuits intended for\nhomomorphic evaluation. Our IR is backed by a type system that tracks low-level\nquantitative bounds (e.g., ciphertext noise) without using the secret key.\nUsing our type system, we identify and prove a strong \\emph{functional\ncorrectness} criterion for \\ila circuits. Additionally, we have designed \\ila\nto be maximally general: our core type system does not directly assume a\nparticular FHE scheme, but instead axiomatizes a \\emph{model} of FHE. We\ninstantiate this model with the exact FHE schemes (BGV, BFV and TFHE), and\nobtain functional correctness for free."}
{"id": "2509.11877", "pdf": "https://arxiv.org/pdf/2509.11877", "abs": "https://arxiv.org/abs/2509.11877", "authors": ["Andrei Arusoaie", "Horaţiu Cheval", "Radu Iosif"], "title": "Proceedings 9th edition of Working Formal Methods Symposium", "categories": ["cs.LO", "cs.PL", "cs.SE"], "comment": null, "summary": "This volume contains the proceedings of the 9th Working Formal Methods\nSymposium, which was held at the Alexandru Ioan Cuza University, Ia\\c{s}i,\nRomania on September 17-19, 2025."}
