<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]
- [cs.LO](#cs.LO) [Total: 2]
- [cs.LG](#cs.LG) [Total: 1]
- [cs.CR](#cs.CR) [Total: 1]
- [cs.SE](#cs.SE) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Mechanizing Synthetic Tait Computability in Istari](https://arxiv.org/abs/2509.11418)
*Runming Li,Yue Yao,Robert Harper*

Main category: cs.PL

TL;DR: 在Istari证明助手中实现了合成Tait可计算性(STC)的形式化，包括模态、扩展类型和严格胶合类型等可重用库，并应用于两个案例研究：带大消除的依赖类型理论的典范性模型和成本感知逻辑框架的Kripke典范性模型


<details>
  <summary>Details</summary>
Motivation: 范畴胶合是证明类型理论元定理（如典范性和正规化）的强大技术，STC通过将胶合范畴内化到具有相位区分的模态依赖类型理论中，提供了对复杂胶合模型的抽象处理

Method: 在Istari证明助手中开发可重用的合成相位区分库，包括模态、扩展类型和严格胶合类型，然后应用于两个具体案例研究

Result: 核心STC构造可以在Istari中几乎逐字形式化，保持了纸上论证的优雅性同时确保机器检查的正确性

Conclusion: Istari的等式反射消除了内涵证明助手中典型的传输推理麻烦，使得STC的形式化既优雅又可机器验证

Abstract: Categorical gluing is a powerful technique for proving meta-theorems of type
theories such as canonicity and normalization. Synthetic Tait Computability
(STC) provides an abstract treatment of the complex gluing models by
internalizing the gluing category into a modal dependent type theory with a
phase distinction. This work presents a mechanization of STC in the Istari
proof assistant. Istari is a Martin-L\"{o}f-style extensional type theory with
equality reflection. Equality reflection eliminates the nuisance of transport
reasoning typically found in intensional proof assistants. This work develops a
reusable library for synthetic phase distinction, including modalities,
extension types, and strict glue types, and applies it to two case studies: (1)
a canonicity model for dependent type theory with dependent products and
booleans with large elimination, and (2) a Kripke canonicity model for the
cost-aware logical framework. Our results demonstrate that the core STC
constructions can be formalized essentially verbatim in Istari, preserving the
elegance of the on-paper arguments while ensuring machine-checked correctness.

</details>


### [2] [Expressive Power of One-Shot Control Operators and Coroutines](https://arxiv.org/abs/2509.11901)
*Kentaro Kobayashi,Yukiyoshi Kameyama*

Main category: cs.PL

TL;DR: 这篇论文通过数学严谨的微观表达力分析，证实了一键控制操作符中不对称协程能够宏表达效果处理器和界定续体，但反之则不行的民间假说，并修正了之前的非正式证明。


<details>
  <summary>Details</summary>
Motivation: 虽然多键控制操作符得到广泛研究，但一键控制操作符在表达力和效率之间取得了更好的平衡，而现有研究在这方面存在空白。本研究旨在填补这一空白，通过严格的数学比较来分析各种一键控制操作符的表达力。

Method: 采用Felleisen的宏表达力作为表达力的衡量标准，对一键效果处理器、一键界定续体和不对称协程进行数学上严谨的微观表达力比较。

Result: 验证了民间假说：一键效果处理器和一键界定续体可以通过不对称协程宏表达，但反之则不行。同时证明了之前非正式论证的错误之处，并提出了有效的宏转换方案。

Conclusion: 一键控制操作符在表达力层次上存在明显的嵌套关系，不对称协程具有最高的表达力，而效果处理器和界定续体在表达力上相当。这一发现为程序语言设计中控制结构的选择提供了理论基础。

Abstract: Control operators, such as exceptions and effect handlers, provide a means of
representing computational effects in programs abstractly and modularly. While
most theoretical studies have focused on multi-shot control operators, one-shot
control operators -- which restrict the use of captured continuations to at
most once -- are gaining attention for their balance between expressiveness and
efficiency. This study aims to fill the gap. We present a mathematically
rigorous comparison of the expressive power among one-shot control operators,
including effect handlers, delimited continuations, and even asymmetric
coroutines. Following previous studies on multi-shot control operators, we
adopt Felleisen's macro-expressiveness as our measure of expressiveness. We
verify the folklore that one-shot effect handlers and one-shot
delimited-control operators can be macro-expressed by asymmetric coroutines,
but not vice versa. We explain why a previous informal argument fails, and how
to revise it to make a valid macro-translation.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [3] [A Tree Clock Data Structure for Causal Orderings in Concurrent Executions](https://arxiv.org/abs/2201.06325)
*Umang Mathur,Andreas Pavlogiannis,Hünkar Can Tunç,Mahesh Viswanathan*

Main category: cs.LO

TL;DR: 树钟是一种新的数据结构，用于替代向量钟来计算并发程序执行中的因果排序关系，具有更高的效率和更优的时间复杂度。


<details>
  <summary>Details</summary>
Motivation: 向量钟在处理大规模并发程序时，基本操作的时间复杂度为θ(k)（k为线程数），成为计算瓶颈。需要一种更高效的数据结构来提升并发分析的性能。

Method: 提出树钟数据结构，其合并和复制操作的时间复杂度与修改的项数成正比，避免了固有的θ(k)成本。证明在计算happens-before偏序关系时，树钟是最优的。

Result: 实验结果显示，使用树钟替代向量钟后，计算速度提升2.02倍(MAZ)到2.97倍(HB)，平均性能提升超过2倍。

Conclusion: 树钟是一种优化的数据结构，可以广泛应用于各种并发分析部分排序计算，有望成为并发分析领域的标准数据结构。

Abstract: Dynamic techniques are a scalable and effective way to analyze concurrent
programs. Instead of analyzing all behaviors of a program, these techniques
detect errors by focusing on a single program execution. Often a crucial step
in these techniques is to define a causal ordering between events in the
execution, which is then computed using vector clocks, a simple data structure
that stores logical times of threads. The two basic operations of vector
clocks, namely join and copy, require $\Theta(k)$ time, where $k$ is the number
of threads. Thus they are a computational bottleneck when $k$ is large.
  In this work, we introduce tree clocks, a new data structure that replaces
vector clocks for computing causal orderings in program executions. Joining and
copying tree clocks takes time that is roughly proportional to the number of
entries being modified, and hence the two operations do not suffer the a-priori
$\Theta(k)$ cost per application. We show that when used to compute the classic
happens-before (HB) partial order, tree clocks are optimal, in the sense that
no other data structure can lead to smaller asymptotic running time. Moreover,
we demonstrate that tree clocks can be used to compute other partial orders,
such as schedulable-happens-before (SHB) and the standard Mazurkiewicz (MAZ)
partial order, and thus are a versatile data structure. Our experiments show
that just by replacing vector clocks with tree clocks, the computation becomes
from $2.02 \times$ faster (MAZ) to $2.66 \times$ (SHB) and $2.97 \times$ (HB)
on average per benchmark. These results illustrate that tree clocks have the
potential to become a standard data structure with wide applications in
concurrent analyses.

</details>


### [4] [Proceedings 9th edition of Working Formal Methods Symposium](https://arxiv.org/abs/2509.11877)
*Andrei Arusoaie,Horaţiu Cheval,Radu Iosif*

Main category: cs.LO

TL;DR: 第九届形式化方法研讨会论文集，包含2025年9月17-19日在罗马尼亚雅西大学举行的会议论文


<details>
  <summary>Details</summary>
Motivation: 汇集形式化方法领域的最新研究成果，促进学术交流与合作

Method: 会议论文集形式，收录经过同行评审的学术论文

Result: 出版了包含多篇形式化方法研究论文的会议论文集

Conclusion: 该论文集记录了第九届形式化方法研讨会的重要学术成果，为该领域研究者提供了有价值的参考资料

Abstract: This volume contains the proceedings of the 9th Working Formal Methods
Symposium, which was held at the Alexandru Ioan Cuza University, Ia\c{s}i,
Romania on September 17-19, 2025.

</details>


<div id='cs.LG'></div>

# cs.LG [[Back]](#toc)

### [5] [Verifying Computational Graphs in Production-Grade Distributed Machine Learning Frameworks](https://arxiv.org/abs/2509.10694)
*Kahfi S. Zulkifli,Wenbo Qian,Shaowei Zhu,Yuan Zhou,Zhen Zhang,Chang Lou*

Main category: cs.LG

TL;DR: Scalify是一个轻量级框架，通过验证计算图的语义等价性来暴露机器学习框架中的静默错误，使用等式饱和和Datalog推理，能够快速验证大型模型并定位错误。


<details>
  <summary>Details</summary>
Motivation: 现代机器学习框架通过并行化和优化技术支持大型模型，但这些技术引入了新的复杂性，导致静默错误严重降低模型性能。现有解决方案要么是临时的，要么在生产环境中成本过高。

Method: 使用等式饱和和Datalog式推理验证计算图的语义等价性；通过并行重写和层记忆化对图进行分区；重用重写模板；在等式饱和中增加关系推理和符号双射推断；将差异定位到精确的代码位置。

Result: 在普通机器上几分钟内验证了Llama-3.1-405B等大型模型；在Amazon生产机器学习框架中发现了5个未知错误。

Conclusion: Scalify提供了一个高效、可扩展的解决方案，能够快速检测和定位机器学习框架中的静默错误，为生产环境提供了实用的调试指导。

Abstract: Modern machine learning frameworks support very large models by incorporating
parallelism and optimization techniques. Yet, these very techniques add new
layers of complexity, introducing silent errors that severely degrade model
performance. Existing solutions are either ad hoc or too costly for production.
  We present Scalify, a lightweight framework that exposes silent errors by
verifying semantic equivalence of computational graphs using equality
saturation and Datalog-style reasoning. To scale, Scalify partitions graphs
with parallel rewriting and layer memoization, reuses rewrite templates, and
augments equality saturation with relational reasoning and symbolic bijection
inference. It further localizes discrepancies to precise code sites, turning
verification results into actionable debugging guidance. Scalify verifies
models as large as Llama-3.1-405B within minutes on a commodity machine and
exposed five unknown bugs in Amazon production machine learning frameworks.

</details>


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [6] [ILA: Correctness via Type Checking for Fully Homomorphic Encryption](https://arxiv.org/abs/2509.11559)
*Tarakaram Gollamudi,Anitha Gollamudi,Joshua Gancher*

Main category: cs.CR

TL;DR: 提出了ILA中间表示语言，用于类型检查同态加密电路的噪声和算术溢出错误，确保功能正确性


<details>
  <summary>Details</summary>
Motivation: 现有FHE编译器缺乏静态噪声跟踪能力，且存在有限模运算的环绕错误，导致开发FHE应用困难

Method: 设计基于类型系统的IR语言，跟踪密码文本噪声等量化边界，不依赖密钥，可实例化到BGV、BFV和TFHE等具体方案

Result: 建立了强功能正确性准则，能够识别和证明ILA电路的正确性

Conclusion: ILA提供了通用的FHE模型抽象，可确保同态计算电路的正确性，降低开发难度

Abstract: RLWE-based Fully Homomorphic Encryption (FHE) schemes add some small
\emph{noise} to the message during encryption. The noise accumulates with each
homomorphic operation. When the noise exceeds a critical value, the FHE circuit
produces an incorrect output. This makes developing FHE applications quite
subtle, as one must closely track the noise to ensure correctness. However,
existing libraries and compilers offer limited support to statically track the
noise. Additionally, FHE circuits are also plagued by wraparound errors that
are common in finite modulus arithmetic. These two limitations of existing
compilers and libraries make FHE applications too difficult to develop with
confidence.
  In this work, we present a \emph{correctness-oriented} IR, Intermediate
Language for Arithmetic circuits, for type-checking circuits intended for
homomorphic evaluation. Our IR is backed by a type system that tracks low-level
quantitative bounds (e.g., ciphertext noise) without using the secret key.
Using our type system, we identify and prove a strong \emph{functional
correctness} criterion for \ila circuits. Additionally, we have designed \ila
to be maximally general: our core type system does not directly assume a
particular FHE scheme, but instead axiomatizes a \emph{model} of FHE. We
instantiate this model with the exact FHE schemes (BGV, BFV and TFHE), and
obtain functional correctness for free.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [7] [Arguzz: Testing zkVMs for Soundness and Completeness Bugs](https://arxiv.org/abs/2509.10819)
*Christoph Hochrainer,Valentin Wüstholz,Maria Christakis*

Main category: cs.SE

TL;DR: Arguzz是首个自动化测试zkVM的工具，通过变形测试和故障注入发现11个漏洞，包括RISC Zero的一个高额赏金漏洞


<details>
  <summary>Details</summary>
Motivation: zkVM在去中心化应用中广泛使用，但其约束系统和执行逻辑的漏洞可能导致严重的安全问题（接受无效执行或拒绝有效执行），现有审计方法不足

Method: 结合变形测试和故障注入，生成语义等效的程序对，合并为已知输出的Rust程序，在zkVM中运行并通过故障注入模拟恶意证明者

Result: 测试6个真实zkVM系统（RISC Zero、Nexus、Jolt等），发现11个漏洞，其中RISC Zero的一个漏洞获得5万美元赏金

Conclusion: 系统化测试zkVM至关重要，Arguzz证明了自动化测试工具在发现关键漏洞方面的有效性，尽管这些系统已经过审计

Abstract: Zero-knowledge virtual machines (zkVMs) are increasingly deployed in
decentralized applications and blockchain rollups since they enable verifiable
off-chain computation. These VMs execute general-purpose programs, frequently
written in Rust, and produce succinct cryptographic proofs. However, zkVMs are
complex, and bugs in their constraint systems or execution logic can cause
critical soundness (accepting invalid executions) or completeness (rejecting
valid ones) issues.
  We present Arguzz, the first automated tool for testing zkVMs for soundness
and completeness bugs. To detect such bugs, Arguzz combines a novel variant of
metamorphic testing with fault injection. In particular, it generates
semantically equivalent program pairs, merges them into a single Rust program
with a known output, and runs it inside a zkVM. By injecting faults into the
VM, Arguzz mimics malicious or buggy provers to uncover overly weak
constraints.
  We used Arguzz to test six real-world zkVMs (RISC Zero, Nexus, Jolt, SP1,
OpenVM, and Pico) and found eleven bugs in three of them. One RISC Zero bug
resulted in a $50,000 bounty, despite prior audits, demonstrating the critical
need for systematic testing of zkVMs.

</details>


### [8] [ViScratch: Using Large Language Models and Gameplay Videos for Automated Feedback in Scratch](https://arxiv.org/abs/2509.11065)
*Yuan Si,Daming Li,Hanyuan Shi,Jialu Zhang*

Main category: cs.SE

TL;DR: ViScratch是一个基于多模态的Scratch调试系统，通过结合代码块和游戏视频来诊断和修复bug，显著优于现有工具


<details>
  <summary>Details</summary>
Motivation: 现有的Scratch调试工具主要依赖预定义规则或手动输入，忽略了平台的视觉特性，无法有效处理语义bug

Method: 采用两阶段流水线：视觉语言模型将视觉症状与代码结构对齐识别关键问题，然后提出AST级别的修复方案并在Scratch虚拟机中验证

Result: ViScratch在bug识别和修复质量方面大幅优于现有LLM工具和人工测试者，证明游戏视频是关键的调试信号

Conclusion: 视频可以作为可视化编程环境中的一等规范，为基于LLM的调试开辟了超越纯符号代码的新方向

Abstract: Block-based programming environments such as Scratch are increasingly popular
in programming education, in particular for young learners. While the use of
blocks helps prevent syntax errors, semantic bugs remain common and difficult
to debug. Existing tools for Scratch debugging rely heavily on predefined rules
or user manual inputs, and crucially, they ignore the platform's inherently
visual nature.
  We introduce ViScratch, the first multimodal feedback generation system for
Scratch that leverages both the project's block code and its generated gameplay
video to diagnose and repair bugs. ViScratch uses a two-stage pipeline: a
vision-language model first aligns visual symptoms with code structure to
identify a single critical issue, then proposes minimal, abstract syntax tree
level repairs that are verified via execution in the Scratch virtual machine.
  We evaluate ViScratch on a set of real-world Scratch projects against
state-of-the-art LLM-based tools and human testers. Results show that gameplay
video is a crucial debugging signal: ViScratch substantially outperforms prior
tools in both bug identification and repair quality, even without access to
project descriptions or goals. This work demonstrates that video can serve as a
first-class specification in visual programming environments, opening new
directions for LLM-based debugging beyond symbolic code alone.

</details>
