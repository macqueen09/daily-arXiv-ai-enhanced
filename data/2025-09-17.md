<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 6]
- [math.FA](#math.FA) [Total: 1]
- [cs.LO](#cs.LO) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Converting IEC 61131-3 LD into SFC Using Large Language Model: Dataset and Testing](https://arxiv.org/abs/2509.12593)
*Yimin Zhang,Mario de Sousa*

Main category: cs.PL

TL;DR: 使用细调的大语言模型将棒图转换为顺序功能图，准确率达91%，解决了预先知识缺乏和状态爆炸问题


<details>
  <summary>Details</summary>
Motivation: 棒图(LD)转换为顺序功能图(SFC)面临预先知识缺乏和状态爆炸挑战，而大语言模型的发展为此提供了新方法

Method: 构建了符合IEC 61131-3标准的SFC和LD程序文本表示的对应数据集，然后使用细调的LLM模型进行自动转换

Result: 细调后的LLM模型在某些数据集上达到了91%的准确率，最低准确率为79%

Conclusion: 通过适当的训练和表示方式，LLM能够有效支持LD-SFC转换，该方法具有可行性和广阔的应用潜力

Abstract: In the domain of Programmable Logic Controller (PLC) programming, converting
a Ladder Diagram (LD) into a Sequential Function Chart (SFC) is an inherently
challenging problem, primarily due to the lack of domain-specific knowledge and
the issue of state explosion in existing algorithms. However, the rapid
development of Artificial Intelligence (AI) - especially Large Language Model
(LLM) - offers a promising new approach.
  Despite this potential, data-driven approaches in this field have been
hindered by a lack of suitable datasets. To address this gap, we constructed
several datasets consisting of paired textual representations of SFC and LD
programs that conform to the IEC 61131-3 standard.
  Based on these datasets, we explored the feasibility of automating the LD-SFC
conversion using LLM. Our preliminary experiments show that a fine-tuned LLM
model achieves up to 91% accuracy on certain dataset, with the lowest observed
accuracy being 79%, suggesting that with proper training and representation,
LLMs can effectively support LD-SFC conversion. These early results highlight
the viability and future potential of this approach.

</details>


### [2] [Efficient Compilation of Algorithms into Compact Linear Programs](https://arxiv.org/abs/2509.13006)
*Shermin Khosravi,David Bremner*

Main category: cs.PL

TL;DR: 通过分层线性流水线技术，将程序结构分解为同步区域，大幅减小线性规划问题的规模，实现了有效的缩减效果和求解性能提升。


<details>
  <summary>Details</summary>
Motivation: 解决线性规划编译器产生的大规模LP问题，虽然多项式规模但极其大的规模对现有求解器构成挑战，需要生成更小的紧凑LP表达式。

Method: 采用分层线性流水线技术，将嵌套程序结构分解为同步区域，通过编译时参数定义执行迁移，实现区域内的约束和变量局部化，从而大幅减小LP规模。

Result: 在makespan问题和加权最小生成树问题上，实现了至25倍的LP规模缩减，并在商业和非商业求解器上获得了显著的性能提升。

Conclusion: 该方法能够系统地生成紧凑整数规划表达式，为处理具有多项式时间分离神谕的指数规模IP问题提供了有效途径，且保证了所有输入规模的有效性。

Abstract: Linear Programming (LP) is widely applied in industry and is a key component
of various other mathematical problem-solving techniques. Recent work
introduced an LP compiler translating polynomial-time, polynomial-space
algorithms into polynomial-size LPs using intuitive high-level programming
languages, offering a promising alternative to manually specifying each set of
constraints through Algebraic Modeling Languages (AMLs). However, the resulting
LPs, while polynomial in size, are often extremely large, posing challenges for
existing LP solvers. In this paper, we propose a novel approach for generating
substantially smaller LPs from algorithms. Our goal is to establish
minimum-size compact LP formulations for problems in P having natural
formulations with exponential extension complexities. Our broader vision is to
enable the systematic generation of Compact Integer Programming (CIP)
formulations for problems with exponential-size IPs having polynomial-time
separation oracles. To this end, we introduce a hierarchical linear pipelining
technique that decomposes nested program structures into synchronized regions
with well-defined execution transitions -- functions of compile-time
parameters. This decomposition allows us to localize LP constraints and
variables within each region, significantly reducing LP size without the loss
of generality, ensuring the resulting LP remains valid for all inputs of size
$n$. We demonstrate the effectiveness of our method on two benchmark problems
-- the makespan problem, which has exponential extension complexity, and the
weighted minimum spanning tree problem -- both of which have exponential-size
natural LPs. Our results show up to a $25$-fold reduction in LP size and
substantial improvements in solver performance across both commercial and
non-commercial LP solvers.

</details>


### [3] [Pleasant Imperative Program Proofs with GallinaC](https://arxiv.org/abs/2509.13019)
*Frédéric Fort,David Nowak,Vlad Rusu*

Main category: cs.PL

TL;DR: GallinaC是一个在Rocq证明助手的Gallina函数式语言中浅层嵌入的图灵完备命令式语言，旨在为低级系统软件提供机器验证的正确性证明


<details>
  <summary>Details</summary>
Motivation: 当前命令式编程语言语义过于宽松，使得正确性证明变得繁琐且容易出错，需要一种支持命令式编程范式但具有良好语义的证明导向语言

Method: 在Gallina函数式语言中浅层嵌入图灵完备的命令式语言，支持无界while循环，利用函数式核心使得程序证明可以使用与纯函数式程序相同的策略

Result: 原型实现已证明GallinaC的可行性，成功完成了未知大小链表的反转程序的正确性证明，目前正专注于GallinaC中间表示与CompCert后端入口语言Cminor的前向模拟

Conclusion: GallinaC为低级系统软件提供了一种在证明助手中机器验证命令式程序正确性的有前景的方法

Abstract: Even with the increase of popularity of functional programming, imperative
programming remains a key programming paradigm, especially for programs
operating at lower levels of abstraction. When such software offers key
components of a Trusted Computing Base (TCB), e.g. an operating system kernel,
it becomes desirable to provide mathematical correctness proofs.
  However, current real-world imperative programming languages possess
"expressive", i.e. overly permissive, semantics. Thus, producing correctness
proofs of such programs becomes tedious and error-prone, requiring to take care
of numerous "administrative" details. Ideally, a proof-oriented imperative
language should feature well-behaved semantics while allowing imperative
idioms.
  To obtain a high-degree of confidence in the correctness of such a language,
its tools should be developed inside a proof-assistant such that program proofs
are machine checked.
  We present GallinaC, a shallow embedding of a Turing-complete imperative
language directly inside the functional programming language of the Rocq proof
assistant, Gallina. In particular, it features a truly generic and unbounded
while loop. Having a functional core means proofs about GallinaC programs may
use the same tactics as proofs about pure functional ones.
  Work on GallinaC is still under progress, but we present first promising
results. A prototype implementation has shown the viability of GallinaC with
the correctness proof of a list reversal procedure for linked-lists of unknown
size. We currently focus on the forward simulation between the GallinaC
intermediate representation (IR) and Cminor, the entry language of the CompCert
back-end.

</details>


### [4] [Navigating the Python Type Jungle](https://arxiv.org/abs/2509.13022)
*Andrei Nacu,Dorel Lucanu*

Main category: cs.PL

TL;DR: 对Python类型系统进行正式化的研究，通过类型理论概念美地描述Python的类型系统，为类型推断工具的发展奠定基础


<details>
  <summary>Details</summary>
Motivation: Python的类型系统实践性地发展为功能强大但理论分散的系统，规范散落，需要正式化来解决这种分散问题

Method: 使用类型理论概念构建正式基础，通过理论化方法美地描述Python的类型系统

Result: 提出了一个正式的基础框架，证明Python类型系统可以被雅致地形式化

Conclusion: 该工作是向类型推断工具未来发展的关键第一步，为Python类型系统的理论基础和工具支持奠定了基础

Abstract: Python's typing system has evolved pragmatically into a powerful but
theoretically fragmented system, with scattered specifications. This paper
proposes a formalization to address this fragmentation. The central
contribution is a formal foundation that uses concepts from type theory to
demonstrate that Python's type system can be elegantly described. This work
aims to serve as a crucial first step toward the future development of type
inference tools.

</details>


### [5] [Try-Mopsa: Relational Static Analysis in Your Pocket](https://arxiv.org/abs/2509.13128)
*Raphaël Monat*

Main category: cs.PL

TL;DR: Try-Mopsa是一个基于JavaScript的Mopsa静态分析平台简化版，可在浏览器中运行，无需安装，便于教学和入门使用


<details>
  <summary>Details</summary>
Motivation: 静态分析器安装复杂、依赖众多，阻碍了采用和学习。为了解决这个问题，开发了可在浏览器中运行的简化版本

Method: 将Mopsa静态分析平台的核心组件编译成JavaScript，创建纯客户端Web应用，支持桌面和移动设备，保留关系数值域等核心功能

Result: 成功开发了Try-Mopsa，提供了响应式界面，支持所有Mopsa核心组件，特别是关系数值域

Conclusion: Try-Mopsa为静态分析的学习和入门提供了便捷平台，降低了使用门槛

Abstract: Static analyzers are complex pieces of software with large dependencies. They
can be difficult to install, which hinders adoption and creates barriers for
students learning static analysis. This work introduces Try-Mopsa: a
scaled-down version of the Mopsa static analysis platform, compiled into
JavaScript to run purely as a client-side application in web browsers.
Try-Mopsa provides a responsive interface that works on both desktop and mobile
devices. Try-Mopsa features all the core components of Mopsa. In particular, it
supports relational numerical domains. We present the interface, changes and
adaptations required to have a pure JavaScript version of Mopsa. We envision
Try-Mopsa as a convenient platform for onboarding or teaching purposes.

</details>


### [6] [Rebound: Efficient, Expressive, and Well-Scoped Binding](https://arxiv.org/abs/2509.13261)
*Noé De Santo,Stephanie Weirich*

Main category: cs.PL

TL;DR: Rebound是一个Haskell库，通过静态跟踪作用域和一级环境来自动化处理绑定结构的替换、alpha等价等操作，确保de Bruijn索引的正确使用，并提供性能优化。


<details>
  <summary>Details</summary>
Motivation: 处理绑定结构时，维护de Bruijn索引的微妙不变量容易出错，需要自动化工具来确保正确性和提供性能优化。

Method: 使用一级环境映射变量到表达式，静态跟踪作用域，自动化定义替换、alpha等价等操作，并提供环境数据结构的显式访问。

Result: 库具有表达性，能够实现多种语言特性和复杂绑定用法，在pi-forall类型检查器等示例中验证了实用性，性能基准测试显示比竞争库更快。

Conclusion: Rebound库成功解决了绑定结构处理的正确性和性能问题，为Haskell开发者提供了可靠的工具支持。

Abstract: We introduce the Rebound library that supports well-scoped term
representations in Haskell and automates the definition of substitution,
alpha-equivalence, and other operations that work with binding structures. The
key idea of our design is the use of first-class environments that map
variables to expressions in some new scope. By statically tracking scopes,
users of this library gain confidence that they have correctly maintained the
subtle invariants that stem from using de Bruijn indices. Behind the scenes,
Rebound uses environments to optimize the application of substitutions, while
providing explicit access to these data structures when desired. We demonstrate
that this library is expressive by using it to implement a wide range of
language features with sophisticated uses of binding and several different
operations that use this abstract syntax. Our examples include pi-forall, a
tutorial implementation of a type checker for a dependently-typed programming
language. Finally, we benchmark Rebound to understand its performance
characteristics and find that it produces faster code than competing libraries.

</details>


<div id='math.FA'></div>

# math.FA [[Back]](#toc)

### [7] [On the Fixed Point Property in Reflexive Banach Spaces](https://arxiv.org/abs/2509.13121)
*Faruk Alpay,Hamdi Alakkad*

Main category: math.FA

TL;DR: 本文研究了自反Banach空间是否具有不动点性质的开放问题，提出了基于直径l1压力和加权选择泛函的定量框架，证明如果这些不变量一致为正，则空间必须包含l1副本，从而不能是自反的。


<details>
  <summary>Details</summary>
Motivation: 解决自反Banach空间是否具有不动点性质的长期开放问题，现有方法存在局限性，需要新的定量分析框架。

Method: 提出基于直径l1压力和加权选择泛函的定量框架，测量无不动点非扩张映射的轨道壳塌陷程度，开发有限维证书和x86-64计算程序。

Result: 证明如果直径l1压力或加权选择泛函一致为正，则Banach空间必须包含l1副本，因此不能是自反的。

Conclusion: 建立了新的定量分析框架来解决不动点性质问题，澄清了现有方法的失败原因，并提出了开放问题和伦理考量。

Abstract: Fixed point theory studies conditions under which nonexpansive maps on Banach
spaces have fixed points. This paper examines the open question of whether
every reflexive Banach space has the fixed point property. After surveying
classical results, we propose a quantitative framework based on diametral l1
pressure and weighted selection functionals, which measure how much an orbit
hull of a fixed point free nonexpansive map can collapse. We prove that if
either invariant is uniformly positive, then the space must contain a copy of
l1 and thus cannot be reflexive. We present finite dimensional certificates,
positive and negative examples, and an x86-64 routine that computes mutual
coherence and a lower bound for the pressure. The paper clarifies why existing
approaches fail and outlines open problems and ethical considerations.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [8] [The Hidden Strength of Costrong Functors](https://arxiv.org/abs/2509.13026)
*Adriana Balan,Silviu-George Pantelimon*

Main category: cs.LO

TL;DR: 本文探讨了costrong函子的概念，这是strong函子的对偶性质，旨在研究函子与幺半结构的交互方式及其在计算语义中的应用。


<details>
  <summary>Details</summary>
Motivation: strong函子和monad在计算机科学中无处不在，comonad在结构化上下文相关计算概念中也显示出其用途，但"being strong"性质的对偶化（即"being costrong"）至今未被充分研究。

Method: 这项工作正在进行中，旨在探索costrong函子及其自然性质，重点关注计算语义学。

Result: 目前是工作进展阶段，具体结果尚未公布。

Conclusion: costrong性质为理解函子如何与幺半结构交互提供了不同的视角，对计算语义学具有重要意义，值得进一步深入研究。

Abstract: Strong functors and monads are ubiquitous in Computer Science. More recently,
comonads have demonstrated their use in structuring context-dependent notions
of computation. However, the dualisation of ``being strong'' property passed
somehow unobserved so far. We argue that ``being costrong'' gives a different
understanding of how functors can interact with monoidal structures. This work
in progress aims to explore costrong functors and their natural properties,
with an eye towards the semantics of computations.

</details>
