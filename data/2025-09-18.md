<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 4]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Catalpa: GC for a Low-Variance Software Stack](https://arxiv.org/abs/2509.13429)
*Anthony Arnold,Mark Marron*

Main category: cs.PL

TL;DR: 提出了Catalpa垃圾收集器，为Bosque语言设计，旨在最小化延迟和变异性，同时保持高吞吐量和低内存开销


<details>
  <summary>Details</summary>
Motivation: 实际应用中性能是二元的（要么足够快用户无感知，要么慢到用户放弃），工业开发者更关注95/99百分位尾延迟而非平均响应时间

Method: 利用Bosque语言的不可变性和无引用循环特性，设计无界收集暂停、固定内存开销、无需屏障或同步的收集器

Result: 实现了具有有界收集暂停、固定常数内存开销、无需与应用代码同步的垃圾收集器

Conclusion: Catalpa收集器通过语言特性支持，能够满足工业应用对低延迟和高可用性的需求

Abstract: The performance of an application/runtime is usually conceptualized as a
continuous function where, the lower the amount of memory/time used on a given
workload, then the better the compiler/runtime is. However, in practice, good
performance of an application is viewed as more of a binary function - either
the application responds in under, say 100 ms, and is fast enough for a user to
barely notice, or it takes a noticeable amount of time, leaving the user
waiting and potentially abandoning the task. Thus, performance really means how
often the application is fast enough to be usable, leading industrial
developers to focus on the 95th and 99th percentile tail-latencies as heavily,
or moreso, than average response time. Our vision is to create a software stack
that actively supports these needs via programming language and runtime system
design. In this paper we present a novel garbage-collector design, the Catalpa
collector, for the Bosque programming language and runtime. This allocator is
designed to minimize latency and variability while maintaining high-throughput
and incurring small memory overheads. To achieve these goals we leverage
various features of the Bosque language, including immutability and
reference-cycle freedom, to construct a collector that has bounded collection
pauses, incurs fixed-constant memory overheads, and does not require any
barriers or synchronization with application code.

</details>


### [2] [Extended Abstract: Towards a Performance Comparison of Syntax and Type-Directed NbE](https://arxiv.org/abs/2509.13489)
*Chester J. F. Gould,William J. Bowman*

Main category: cs.PL

TL;DR: 这是一个工作进展报告，研究了依赖类型检查中语法指导和类型指导的类型相等性检查方法的性能对比。


<details>
  <summary>Details</summary>
Motivation: 当前依赖类型检查器中常见说法认为语法指导方法性能更好，而类型指导方法表达力更强，但缺乏直接对比的实验基础。

Method: 开发了一个实际的平台，能够进行直接的、公平的两种方法对比，量化类型指导方法的性能差异并分析改进方向。

Result: 这是一个进行中的工作，尚未提供具体的实验结果和数据。

Conclusion: 该研究为依赖类型检查器的类型相等性检查方法提供了一个可靠的对比平台，有助于实际评估两种方法的性能和表达力。

Abstract: A key part of any dependent type-checker is the method for checking whether
two types are equal. A common claim is that syntax-directed equality is more
performant, although type-directed equality is more expressive. However, this
claim is difficult to make precise, since implementations choose only one or
the other approach, making a direct comparison impossible. We present some
work-in-progress developing a realistic platform for direct, apples-to-apples,
comparison of the two approaches, quantifying how much slower type-directed
equality checking is, and analyzing why and how it can be improved.

</details>


### [3] [CLMTracing: Black-box User-level Watermarking for Code Language Model Tracing](https://arxiv.org/abs/2509.13982)
*Boyu Zhang,Ping He,Tianyu Du,Xuhong Zhang,Lei Yun,Kingsum Chow,Jianwei Yin*

Main category: cs.PL

TL;DR: CLMTracing是一个黑盒代码语言模型水印框架，通过规则水印和保持实用性的注入方法实现用户级追踪，具有强鲁棒性对抗去除攻击。


<details>
  <summary>Details</summary>
Motivation: 随着开源代码语言模型的广泛采用，知识产权保护变得日益重要。现有水印技术在面对黑盒设置下的用户级追踪需求时存在局限性。

Method: 采用基于规则的水印和保持实用性的注入方法，结合对鲁棒水印敏感的参数选择算法和对抗训练来增强鲁棒性。

Result: 在多个最先进代码语言模型上评估显示，相比现有基线有显著无害改进，对各种去除攻击表现出强鲁棒性。

Conclusion: CLMTracing是一个有效的黑盒代码语言模型水印框架，能够实现用户级模型追踪并抵抗去除攻击。

Abstract: With the widespread adoption of open-source code language models (code LMs),
intellectual property (IP) protection has become an increasingly critical
concern. While current watermarking techniques have the potential to identify
the code LM to protect its IP, they have limitations when facing the more
practical and complex demand, i.e., offering the individual user-level tracing
in the black-box setting. This work presents CLMTracing, a black-box code LM
watermarking framework employing the rule-based watermarks and
utility-preserving injection method for user-level model tracing. CLMTracing
further incorporates a parameter selection algorithm sensitive to the robust
watermark and adversarial training to enhance the robustness against watermark
removal attacks. Comprehensive evaluations demonstrate CLMTracing is effective
across multiple state-of-the-art (SOTA) code LMs, showing significant harmless
improvements compared to existing SOTA baselines and strong robustness against
various removal attacks.

</details>


### [4] [Parallelizable Feynman-Kac Models for Universal Probabilistic Programming](https://arxiv.org/abs/2509.14092)
*Michele Boreale,Luisa Collodi*

Main category: cs.PL

TL;DR: 该论文为概率程序开发了基于顺序蒙特卡洛(SMC)的可证明正确且高效的推理方法，提出了向量化粒子滤波算法VPF，在无限执行迹上建立了期望语义并证明了有限近似定理。


<details>
  <summary>Details</summary>
Motivation: 研究概率程序的正式操作语义下的可证明正确推理方法，解决具有任意测度采样和无界循环条件/重加权的通用概率程序的推理问题。

Method: 首先为概率程序图(PPGs)建立基于无限执行迹的期望语义，包含迹权重；然后证明有限近似定理，将语义框架置于Feynman-Kac模型中；最后提出针对PPGs的向量化粒子滤波算法VPF。

Result: 实验证明VPF相比现有最先进的概率程序推理工具表现出非常有前景的结果，验证了方法的有效性。

Conclusion: 该工作为概率程序提供了理论基础和实用算法，通过形式化语义和可证明正确的近似方法，实现了对复杂概率程序的高效推理。

Abstract: We study provably correct and efficient instantiations of Sequential Monte
Carlo (SMC) inference in the context of formal operational semantics of
Probabilistic Programs (PPs). We focus on universal PPs featuring sampling from
arbitrary measures and conditioning/reweighting in unbounded loops. We first
equip Probabilistic Program Graphs (PPGs), an automata-theoretic description
format of PPs, with an expectation-based semantics over infinite execution
traces, which also incorporates trace weights. We then prove a finite
approximation theorem that provides bounds to this semantics based on
expectations taken over finite, fixed-length traces. This enables us to frame
our semantics within a Feynman-Kac (FK) model, and ensures the consistency of
the Particle Filtering (PF) algorithm, an instance of SMC, with respect to our
semantics. Building on these results, we introduce VPF, a vectorized version of
the PF algorithm tailored to PPGs and our semantics. Experiments conducted with
a proof-of-concept implementation of VPF show very promising results compared
to state-of-the-art PP inference tools.

</details>
