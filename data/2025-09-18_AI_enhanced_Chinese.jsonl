{"id": "2509.13429", "pdf": "https://arxiv.org/pdf/2509.13429", "abs": "https://arxiv.org/abs/2509.13429", "authors": ["Anthony Arnold", "Mark Marron"], "title": "Catalpa: GC for a Low-Variance Software Stack", "categories": ["cs.PL", "cs.SE"], "comment": null, "summary": "The performance of an application/runtime is usually conceptualized as a\ncontinuous function where, the lower the amount of memory/time used on a given\nworkload, then the better the compiler/runtime is. However, in practice, good\nperformance of an application is viewed as more of a binary function - either\nthe application responds in under, say 100 ms, and is fast enough for a user to\nbarely notice, or it takes a noticeable amount of time, leaving the user\nwaiting and potentially abandoning the task. Thus, performance really means how\noften the application is fast enough to be usable, leading industrial\ndevelopers to focus on the 95th and 99th percentile tail-latencies as heavily,\nor moreso, than average response time. Our vision is to create a software stack\nthat actively supports these needs via programming language and runtime system\ndesign. In this paper we present a novel garbage-collector design, the Catalpa\ncollector, for the Bosque programming language and runtime. This allocator is\ndesigned to minimize latency and variability while maintaining high-throughput\nand incurring small memory overheads. To achieve these goals we leverage\nvarious features of the Bosque language, including immutability and\nreference-cycle freedom, to construct a collector that has bounded collection\npauses, incurs fixed-constant memory overheads, and does not require any\nbarriers or synchronization with application code.", "AI": {"tldr": "\u63d0\u51fa\u4e86Catalpa\u5783\u573e\u6536\u96c6\u5668\uff0c\u4e3aBosque\u8bed\u8a00\u8bbe\u8ba1\uff0c\u65e8\u5728\u6700\u5c0f\u5316\u5ef6\u8fdf\u548c\u53d8\u5f02\u6027\uff0c\u540c\u65f6\u4fdd\u6301\u9ad8\u541e\u5410\u91cf\u548c\u4f4e\u5185\u5b58\u5f00\u9500", "motivation": "\u5b9e\u9645\u5e94\u7528\u4e2d\u6027\u80fd\u662f\u4e8c\u5143\u7684\uff08\u8981\u4e48\u8db3\u591f\u5feb\u7528\u6237\u65e0\u611f\u77e5\uff0c\u8981\u4e48\u6162\u5230\u7528\u6237\u653e\u5f03\uff09\uff0c\u5de5\u4e1a\u5f00\u53d1\u8005\u66f4\u5173\u6ce895/99\u767e\u5206\u4f4d\u5c3e\u5ef6\u8fdf\u800c\u975e\u5e73\u5747\u54cd\u5e94\u65f6\u95f4", "method": "\u5229\u7528Bosque\u8bed\u8a00\u7684\u4e0d\u53ef\u53d8\u6027\u548c\u65e0\u5f15\u7528\u5faa\u73af\u7279\u6027\uff0c\u8bbe\u8ba1\u65e0\u754c\u6536\u96c6\u6682\u505c\u3001\u56fa\u5b9a\u5185\u5b58\u5f00\u9500\u3001\u65e0\u9700\u5c4f\u969c\u6216\u540c\u6b65\u7684\u6536\u96c6\u5668", "result": "\u5b9e\u73b0\u4e86\u5177\u6709\u6709\u754c\u6536\u96c6\u6682\u505c\u3001\u56fa\u5b9a\u5e38\u6570\u5185\u5b58\u5f00\u9500\u3001\u65e0\u9700\u4e0e\u5e94\u7528\u4ee3\u7801\u540c\u6b65\u7684\u5783\u573e\u6536\u96c6\u5668", "conclusion": "Catalpa\u6536\u96c6\u5668\u901a\u8fc7\u8bed\u8a00\u7279\u6027\u652f\u6301\uff0c\u80fd\u591f\u6ee1\u8db3\u5de5\u4e1a\u5e94\u7528\u5bf9\u4f4e\u5ef6\u8fdf\u548c\u9ad8\u53ef\u7528\u6027\u7684\u9700\u6c42"}}
{"id": "2509.13489", "pdf": "https://arxiv.org/pdf/2509.13489", "abs": "https://arxiv.org/abs/2509.13489", "authors": ["Chester J. F. Gould", "William J. Bowman"], "title": "Extended Abstract: Towards a Performance Comparison of Syntax and Type-Directed NbE", "categories": ["cs.PL"], "comment": "Submitted to TyDe 2025", "summary": "A key part of any dependent type-checker is the method for checking whether\ntwo types are equal. A common claim is that syntax-directed equality is more\nperformant, although type-directed equality is more expressive. However, this\nclaim is difficult to make precise, since implementations choose only one or\nthe other approach, making a direct comparison impossible. We present some\nwork-in-progress developing a realistic platform for direct, apples-to-apples,\ncomparison of the two approaches, quantifying how much slower type-directed\nequality checking is, and analyzing why and how it can be improved.", "AI": {"tldr": "\u8fd9\u662f\u4e00\u4e2a\u5de5\u4f5c\u8fdb\u5c55\u62a5\u544a\uff0c\u7814\u7a76\u4e86\u4f9d\u8d56\u7c7b\u578b\u68c0\u67e5\u4e2d\u8bed\u6cd5\u6307\u5bfc\u548c\u7c7b\u578b\u6307\u5bfc\u7684\u7c7b\u578b\u76f8\u7b49\u6027\u68c0\u67e5\u65b9\u6cd5\u7684\u6027\u80fd\u5bf9\u6bd4\u3002", "motivation": "\u5f53\u524d\u4f9d\u8d56\u7c7b\u578b\u68c0\u67e5\u5668\u4e2d\u5e38\u89c1\u8bf4\u6cd5\u8ba4\u4e3a\u8bed\u6cd5\u6307\u5bfc\u65b9\u6cd5\u6027\u80fd\u66f4\u597d\uff0c\u800c\u7c7b\u578b\u6307\u5bfc\u65b9\u6cd5\u8868\u8fbe\u529b\u66f4\u5f3a\uff0c\u4f46\u7f3a\u4e4f\u76f4\u63a5\u5bf9\u6bd4\u7684\u5b9e\u9a8c\u57fa\u7840\u3002", "method": "\u5f00\u53d1\u4e86\u4e00\u4e2a\u5b9e\u9645\u7684\u5e73\u53f0\uff0c\u80fd\u591f\u8fdb\u884c\u76f4\u63a5\u7684\u3001\u516c\u5e73\u7684\u4e24\u79cd\u65b9\u6cd5\u5bf9\u6bd4\uff0c\u91cf\u5316\u7c7b\u578b\u6307\u5bfc\u65b9\u6cd5\u7684\u6027\u80fd\u5dee\u5f02\u5e76\u5206\u6790\u6539\u8fdb\u65b9\u5411\u3002", "result": "\u8fd9\u662f\u4e00\u4e2a\u8fdb\u884c\u4e2d\u7684\u5de5\u4f5c\uff0c\u5c1a\u672a\u63d0\u4f9b\u5177\u4f53\u7684\u5b9e\u9a8c\u7ed3\u679c\u548c\u6570\u636e\u3002", "conclusion": "\u8be5\u7814\u7a76\u4e3a\u4f9d\u8d56\u7c7b\u578b\u68c0\u67e5\u5668\u7684\u7c7b\u578b\u76f8\u7b49\u6027\u68c0\u67e5\u65b9\u6cd5\u63d0\u4f9b\u4e86\u4e00\u4e2a\u53ef\u9760\u7684\u5bf9\u6bd4\u5e73\u53f0\uff0c\u6709\u52a9\u4e8e\u5b9e\u9645\u8bc4\u4f30\u4e24\u79cd\u65b9\u6cd5\u7684\u6027\u80fd\u548c\u8868\u8fbe\u529b\u3002"}}
{"id": "2509.13982", "pdf": "https://arxiv.org/pdf/2509.13982", "abs": "https://arxiv.org/abs/2509.13982", "authors": ["Boyu Zhang", "Ping He", "Tianyu Du", "Xuhong Zhang", "Lei Yun", "Kingsum Chow", "Jianwei Yin"], "title": "CLMTracing: Black-box User-level Watermarking for Code Language Model Tracing", "categories": ["cs.PL"], "comment": null, "summary": "With the widespread adoption of open-source code language models (code LMs),\nintellectual property (IP) protection has become an increasingly critical\nconcern. While current watermarking techniques have the potential to identify\nthe code LM to protect its IP, they have limitations when facing the more\npractical and complex demand, i.e., offering the individual user-level tracing\nin the black-box setting. This work presents CLMTracing, a black-box code LM\nwatermarking framework employing the rule-based watermarks and\nutility-preserving injection method for user-level model tracing. CLMTracing\nfurther incorporates a parameter selection algorithm sensitive to the robust\nwatermark and adversarial training to enhance the robustness against watermark\nremoval attacks. Comprehensive evaluations demonstrate CLMTracing is effective\nacross multiple state-of-the-art (SOTA) code LMs, showing significant harmless\nimprovements compared to existing SOTA baselines and strong robustness against\nvarious removal attacks.", "AI": {"tldr": "CLMTracing\u662f\u4e00\u4e2a\u9ed1\u76d2\u4ee3\u7801\u8bed\u8a00\u6a21\u578b\u6c34\u5370\u6846\u67b6\uff0c\u901a\u8fc7\u89c4\u5219\u6c34\u5370\u548c\u4fdd\u6301\u5b9e\u7528\u6027\u7684\u6ce8\u5165\u65b9\u6cd5\u5b9e\u73b0\u7528\u6237\u7ea7\u8ffd\u8e2a\uff0c\u5177\u6709\u5f3a\u9c81\u68d2\u6027\u5bf9\u6297\u53bb\u9664\u653b\u51fb\u3002", "motivation": "\u968f\u7740\u5f00\u6e90\u4ee3\u7801\u8bed\u8a00\u6a21\u578b\u7684\u5e7f\u6cdb\u91c7\u7528\uff0c\u77e5\u8bc6\u4ea7\u6743\u4fdd\u62a4\u53d8\u5f97\u65e5\u76ca\u91cd\u8981\u3002\u73b0\u6709\u6c34\u5370\u6280\u672f\u5728\u9762\u5bf9\u9ed1\u76d2\u8bbe\u7f6e\u4e0b\u7684\u7528\u6237\u7ea7\u8ffd\u8e2a\u9700\u6c42\u65f6\u5b58\u5728\u5c40\u9650\u6027\u3002", "method": "\u91c7\u7528\u57fa\u4e8e\u89c4\u5219\u7684\u6c34\u5370\u548c\u4fdd\u6301\u5b9e\u7528\u6027\u7684\u6ce8\u5165\u65b9\u6cd5\uff0c\u7ed3\u5408\u5bf9\u9c81\u68d2\u6c34\u5370\u654f\u611f\u7684\u53c2\u6570\u9009\u62e9\u7b97\u6cd5\u548c\u5bf9\u6297\u8bad\u7ec3\u6765\u589e\u5f3a\u9c81\u68d2\u6027\u3002", "result": "\u5728\u591a\u4e2a\u6700\u5148\u8fdb\u4ee3\u7801\u8bed\u8a00\u6a21\u578b\u4e0a\u8bc4\u4f30\u663e\u793a\uff0c\u76f8\u6bd4\u73b0\u6709\u57fa\u7ebf\u6709\u663e\u8457\u65e0\u5bb3\u6539\u8fdb\uff0c\u5bf9\u5404\u79cd\u53bb\u9664\u653b\u51fb\u8868\u73b0\u51fa\u5f3a\u9c81\u68d2\u6027\u3002", "conclusion": "CLMTracing\u662f\u4e00\u4e2a\u6709\u6548\u7684\u9ed1\u76d2\u4ee3\u7801\u8bed\u8a00\u6a21\u578b\u6c34\u5370\u6846\u67b6\uff0c\u80fd\u591f\u5b9e\u73b0\u7528\u6237\u7ea7\u6a21\u578b\u8ffd\u8e2a\u5e76\u62b5\u6297\u53bb\u9664\u653b\u51fb\u3002"}}
{"id": "2509.14092", "pdf": "https://arxiv.org/pdf/2509.14092", "abs": "https://arxiv.org/abs/2509.14092", "authors": ["Michele Boreale", "Luisa Collodi"], "title": "Parallelizable Feynman-Kac Models for Universal Probabilistic Programming", "categories": ["cs.PL"], "comment": "In Proceedings GandALF 2025, arXiv:2509.13258", "summary": "We study provably correct and efficient instantiations of Sequential Monte\nCarlo (SMC) inference in the context of formal operational semantics of\nProbabilistic Programs (PPs). We focus on universal PPs featuring sampling from\narbitrary measures and conditioning/reweighting in unbounded loops. We first\nequip Probabilistic Program Graphs (PPGs), an automata-theoretic description\nformat of PPs, with an expectation-based semantics over infinite execution\ntraces, which also incorporates trace weights. We then prove a finite\napproximation theorem that provides bounds to this semantics based on\nexpectations taken over finite, fixed-length traces. This enables us to frame\nour semantics within a Feynman-Kac (FK) model, and ensures the consistency of\nthe Particle Filtering (PF) algorithm, an instance of SMC, with respect to our\nsemantics. Building on these results, we introduce VPF, a vectorized version of\nthe PF algorithm tailored to PPGs and our semantics. Experiments conducted with\na proof-of-concept implementation of VPF show very promising results compared\nto state-of-the-art PP inference tools.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e3a\u6982\u7387\u7a0b\u5e8f\u5f00\u53d1\u4e86\u57fa\u4e8e\u987a\u5e8f\u8499\u7279\u5361\u6d1b(SMC)\u7684\u53ef\u8bc1\u660e\u6b63\u786e\u4e14\u9ad8\u6548\u7684\u63a8\u7406\u65b9\u6cd5\uff0c\u63d0\u51fa\u4e86\u5411\u91cf\u5316\u7c92\u5b50\u6ee4\u6ce2\u7b97\u6cd5VPF\uff0c\u5728\u65e0\u9650\u6267\u884c\u8ff9\u4e0a\u5efa\u7acb\u4e86\u671f\u671b\u8bed\u4e49\u5e76\u8bc1\u660e\u4e86\u6709\u9650\u8fd1\u4f3c\u5b9a\u7406\u3002", "motivation": "\u7814\u7a76\u6982\u7387\u7a0b\u5e8f\u7684\u6b63\u5f0f\u64cd\u4f5c\u8bed\u4e49\u4e0b\u7684\u53ef\u8bc1\u660e\u6b63\u786e\u63a8\u7406\u65b9\u6cd5\uff0c\u89e3\u51b3\u5177\u6709\u4efb\u610f\u6d4b\u5ea6\u91c7\u6837\u548c\u65e0\u754c\u5faa\u73af\u6761\u4ef6/\u91cd\u52a0\u6743\u7684\u901a\u7528\u6982\u7387\u7a0b\u5e8f\u7684\u63a8\u7406\u95ee\u9898\u3002", "method": "\u9996\u5148\u4e3a\u6982\u7387\u7a0b\u5e8f\u56fe(PPGs)\u5efa\u7acb\u57fa\u4e8e\u65e0\u9650\u6267\u884c\u8ff9\u7684\u671f\u671b\u8bed\u4e49\uff0c\u5305\u542b\u8ff9\u6743\u91cd\uff1b\u7136\u540e\u8bc1\u660e\u6709\u9650\u8fd1\u4f3c\u5b9a\u7406\uff0c\u5c06\u8bed\u4e49\u6846\u67b6\u7f6e\u4e8eFeynman-Kac\u6a21\u578b\u4e2d\uff1b\u6700\u540e\u63d0\u51fa\u9488\u5bf9PPGs\u7684\u5411\u91cf\u5316\u7c92\u5b50\u6ee4\u6ce2\u7b97\u6cd5VPF\u3002", "result": "\u5b9e\u9a8c\u8bc1\u660eVPF\u76f8\u6bd4\u73b0\u6709\u6700\u5148\u8fdb\u7684\u6982\u7387\u7a0b\u5e8f\u63a8\u7406\u5de5\u5177\u8868\u73b0\u51fa\u975e\u5e38\u6709\u524d\u666f\u7684\u7ed3\u679c\uff0c\u9a8c\u8bc1\u4e86\u65b9\u6cd5\u7684\u6709\u6548\u6027\u3002", "conclusion": "\u8be5\u5de5\u4f5c\u4e3a\u6982\u7387\u7a0b\u5e8f\u63d0\u4f9b\u4e86\u7406\u8bba\u57fa\u7840\u548c\u5b9e\u7528\u7b97\u6cd5\uff0c\u901a\u8fc7\u5f62\u5f0f\u5316\u8bed\u4e49\u548c\u53ef\u8bc1\u660e\u6b63\u786e\u7684\u8fd1\u4f3c\u65b9\u6cd5\uff0c\u5b9e\u73b0\u4e86\u5bf9\u590d\u6742\u6982\u7387\u7a0b\u5e8f\u7684\u9ad8\u6548\u63a8\u7406\u3002"}}
