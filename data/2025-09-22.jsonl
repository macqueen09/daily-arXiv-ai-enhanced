{"id": "2509.15834", "pdf": "https://arxiv.org/pdf/2509.15834", "abs": "https://arxiv.org/abs/2509.15834", "authors": ["Shardul Chiplunkar", "Cl√©ment Pit-Claudel"], "title": "Automatic layout of railroad diagrams", "categories": ["cs.PL"], "comment": "24 pages (+2 appendix, +3 references); 22 figures (+4 appendix); 3\n  tables", "summary": "Railroad diagrams (also called \"syntax diagrams\") are a common, intuitive\nvisualization of grammars, but limited tooling and a lack of formal attention\nto their layout mostly confines them to hand-drawn documentation. We present\nthe first formal treatment of railroad diagram layout along with a principled,\npractical implementation. We characterize the problem as compiling a *diagram\nlanguage* (specifying conceptual components and how they connect and compose)\nto a *layout language* (specifying basic graphical shapes and their sizes and\npositions). We then implement a compiler that performs *line wrapping* to meet\na target width, as well as vertical *alignment* and horizontal *justification*\nper user-specified policies. We frame line wrapping as an optimization problem,\nwhere we describe principled dimensions of optimality and implement\ncorresponding heuristics. For front-end evaluation, we show that our diagram\nlanguage is well-suited for common applications by describing how regular\nexpressions and Backus-Naur form can be compiled to it. For back-end\nevaluation, we argue that our compiler is practical by comparing its output to\ndiagrams laid out by hand and by other tools."}
{"id": "2509.15283", "pdf": "https://arxiv.org/pdf/2509.15283", "abs": "https://arxiv.org/abs/2509.15283", "authors": ["Kadin Matotek", "Heather Cassel", "Md Amiruzzaman", "Linh B. Ngo"], "title": "Evaluating the Limitations of Local LLMs in Solving Complex Programming Challenges", "categories": ["cs.SE", "cs.AI", "cs.LG", "cs.PL", "I.2.7; F.2.2; I.2.2"], "comment": "Comments: 16 pages, 3 figures, 8 tables, accepted to CCSC Eastern\n  2025", "summary": "This study examines the performance of today's open-source, locally hosted\nlarge-language models (LLMs) in handling complex competitive programming tasks\nwith extended problem descriptions and contexts. Building on the original\nFramework for AI-driven Code Generation Evaluation (FACE), the authors retrofit\nthe pipeline to work entirely offline through the Ollama runtime, collapsing\nFACE's sprawling per-problem directory tree into a handful of consolidated JSON\nfiles, and adding robust checkpointing so multi-day runs can resume after\nfailures. The enhanced framework generates, submits, and records solutions for\nthe full Kattis corpus of 3,589 problems across eight code-oriented models\nranging from 6.7-9 billion parameters. The submission results show that the\noverall pass@1 accuracy is modest for the local models, with the best models\nperforming at approximately half the acceptance rate of the proprietary models,\nGemini 1.5 and ChatGPT-4. These findings expose a persistent gap between\nprivate, cost-controlled LLM deployments and state-of-the-art proprietary\nservices, yet also highlight the rapid progress of open models and the\npractical benefits of an evaluation workflow that organizations can replicate\non in-house hardware."}
{"id": "2509.15754", "pdf": "https://arxiv.org/pdf/2509.15754", "abs": "https://arxiv.org/abs/2509.15754", "authors": ["Toby Sharp"], "title": "Hornet Node and the Hornet DSL: A Minimal, Executable Specification for Bitcoin Consensus", "categories": ["cs.CR", "cs.PL", "cs.SE"], "comment": null, "summary": "Bitcoin's consensus rules are encoded in the implementation of its reference\nclient: \"The code is the spec.\" Yet this code is unsuitable for formal\nverification due to side effects, mutable state, concurrency, and legacy\ndesign. A standalone formal specification would enable verification both across\nversions of the reference client and against new client implementations,\nstrengthening decentralization by reducing the risk of consensus-splitting\nbugs. Yet such a specification has long been considered intractable given the\ncomplexity of Bitcoin's consensus logic. We demonstrate a compact, executable,\ndeclarative C++ specification of Bitcoin consensus rules that syncs mainnet to\ntip in a few hours on a single thread. We also introduce the Hornet\nDomain-Specific Language (DSL) specifically designed to encode these rules\nunambiguously for execution, enabling formal reasoning, consensus code\ngeneration, and AI-driven adversarial testing. Our spec-driven client Hornet\nNode offers a modern and modular complement to the reference client. Its clear,\nidiomatic style makes it suitable for education, while its performance makes it\nideal for experimentation. We highlight architectural contributions such as its\nlayered design, efficient data structures, and strong separation of concerns,\nsupported by production-quality code examples. We argue that Hornet Node and\nHornet DSL together provide the first credible path toward a pure, formal,\nexecutable specification of Bitcoin consensus."}
