<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.SE](#cs.SE) [Total: 1]
- [cs.CR](#cs.CR) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Automatic layout of railroad diagrams](https://arxiv.org/abs/2509.15834)
*Shardul Chiplunkar,Clément Pit-Claudel*

Main category: cs.PL

TL;DR: 本文提出了铁路图布局的第一个形式化处理方法，包括一个原则性的实用实现，通过编译图表语言到布局语言，支持自动换行、对齐和调整等布局策略。


<details>
  <summary>Details</summary>
Motivation: 铁路图是一种常见的语法可视化方法，但由于工具支持有限且缺乏形式化布局关注，主要局限于手绘文档。

Method: 将问题描述为从图表语言（指定概念组件及其连接和组合方式）编译到布局语言（指定基本图形形状及其大小和位置），实现执行自动换行、垂直对齐和水平调整的编译器。

Result: 通过将正则表达式和巴科斯范式编译到图表语言展示前端适用性，并通过与手绘和其他工具输出的比较证明编译器的实用性。

Conclusion: 提出的形式化方法和实现为铁路图布局提供了原则性解决方案，提升了其自动生成和布局的质量与效率。

Abstract: Railroad diagrams (also called "syntax diagrams") are a common, intuitive
visualization of grammars, but limited tooling and a lack of formal attention
to their layout mostly confines them to hand-drawn documentation. We present
the first formal treatment of railroad diagram layout along with a principled,
practical implementation. We characterize the problem as compiling a *diagram
language* (specifying conceptual components and how they connect and compose)
to a *layout language* (specifying basic graphical shapes and their sizes and
positions). We then implement a compiler that performs *line wrapping* to meet
a target width, as well as vertical *alignment* and horizontal *justification*
per user-specified policies. We frame line wrapping as an optimization problem,
where we describe principled dimensions of optimality and implement
corresponding heuristics. For front-end evaluation, we show that our diagram
language is well-suited for common applications by describing how regular
expressions and Backus-Naur form can be compiled to it. For back-end
evaluation, we argue that our compiler is practical by comparing its output to
diagrams laid out by hand and by other tools.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [2] [Evaluating the Limitations of Local LLMs in Solving Complex Programming Challenges](https://arxiv.org/abs/2509.15283)
*Kadin Matotek,Heather Cassel,Md Amiruzzaman,Linh B. Ngo*

Main category: cs.SE

TL;DR: 本研究评估了开源本地大语言模型在处理复杂编程竞赛任务时的性能，发现其准确率约为专有模型的一半，揭示了开源模型与专有服务之间的差距，但也展示了开源模型的快速进步。


<details>
  <summary>Details</summary>
Motivation: 研究动机是评估当前开源本地大语言模型在处理具有扩展问题描述和上下文的复杂编程竞赛任务时的表现，比较开源模型与专有模型之间的性能差距。

Method: 基于原有的FACE框架进行改造，使用Ollama运行时实现完全离线运行，将复杂的目录结构整合为JSON文件，并添加检查点功能。对Kattis题库的3,589个问题在8个代码导向模型上进行测试。

Result: 结果显示本地模型的整体pass@1准确率较低，最佳模型的接受率约为专有模型（Gemini 1.5和ChatGPT-4）的一半。

Conclusion: 研究揭示了私有成本控制LLM部署与最先进专有服务之间的持续差距，但也凸显了开源模型的快速进步和在内部硬件上可复现评估工作流的实际价值。

Abstract: This study examines the performance of today's open-source, locally hosted
large-language models (LLMs) in handling complex competitive programming tasks
with extended problem descriptions and contexts. Building on the original
Framework for AI-driven Code Generation Evaluation (FACE), the authors retrofit
the pipeline to work entirely offline through the Ollama runtime, collapsing
FACE's sprawling per-problem directory tree into a handful of consolidated JSON
files, and adding robust checkpointing so multi-day runs can resume after
failures. The enhanced framework generates, submits, and records solutions for
the full Kattis corpus of 3,589 problems across eight code-oriented models
ranging from 6.7-9 billion parameters. The submission results show that the
overall pass@1 accuracy is modest for the local models, with the best models
performing at approximately half the acceptance rate of the proprietary models,
Gemini 1.5 and ChatGPT-4. These findings expose a persistent gap between
private, cost-controlled LLM deployments and state-of-the-art proprietary
services, yet also highlight the rapid progress of open models and the
practical benefits of an evaluation workflow that organizations can replicate
on in-house hardware.

</details>


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [3] [Hornet Node and the Hornet DSL: A Minimal, Executable Specification for Bitcoin Consensus](https://arxiv.org/abs/2509.15754)
*Toby Sharp*

Main category: cs.CR

TL;DR: 提出了一个紧凑、可执行的比特币共识规则C++规范，并开发了Hornet DSL语言和Hornet Node客户端，为比特币共识提供首个可信的正式可执行规范路径。


<details>
  <summary>Details</summary>
Motivation: 比特币的参考客户端代码不适合形式化验证，需要独立的正式规范来支持跨版本验证和新客户端实现，减少共识分裂风险。

Method: 开发了声明式C++规范和Hornet DSL语言，设计了分层架构、高效数据结构和关注点分离的Hornet Node客户端。

Result: 规范能在单线程上几小时内同步主网到最新区块，支持形式推理、共识代码生成和AI驱动的对抗测试。

Conclusion: Hornet Node和Hornet DSL共同为比特币共识提供了首个可信的纯正式可执行规范路径，适合教育和实验。

Abstract: Bitcoin's consensus rules are encoded in the implementation of its reference
client: "The code is the spec." Yet this code is unsuitable for formal
verification due to side effects, mutable state, concurrency, and legacy
design. A standalone formal specification would enable verification both across
versions of the reference client and against new client implementations,
strengthening decentralization by reducing the risk of consensus-splitting
bugs. Yet such a specification has long been considered intractable given the
complexity of Bitcoin's consensus logic. We demonstrate a compact, executable,
declarative C++ specification of Bitcoin consensus rules that syncs mainnet to
tip in a few hours on a single thread. We also introduce the Hornet
Domain-Specific Language (DSL) specifically designed to encode these rules
unambiguously for execution, enabling formal reasoning, consensus code
generation, and AI-driven adversarial testing. Our spec-driven client Hornet
Node offers a modern and modular complement to the reference client. Its clear,
idiomatic style makes it suitable for education, while its performance makes it
ideal for experimentation. We highlight architectural contributions such as its
layered design, efficient data structures, and strong separation of concerns,
supported by production-quality code examples. We argue that Hornet Node and
Hornet DSL together provide the first credible path toward a pure, formal,
executable specification of Bitcoin consensus.

</details>
