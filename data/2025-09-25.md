<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]
- [cs.SE](#cs.SE) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Macro-embedding Compiler Intermediate Languages in Racket](https://arxiv.org/abs/2509.19607)
*William J. Bowman*

Main category: cs.PL

TL;DR: 本文介绍了一种将编译器中间语言家族从类Scheme语言到x86-64嵌入到Racket中的宏嵌入设计和实现，用于编译器课程的测试框架。


<details>
  <summary>Details</summary>
Motivation: 展示面向语言的技术和抽象，用于实现(1)大型语言家族和(2)低层与高层语言之间的互操作性，强调代码重用和互操作性。

Method: 通过局部宏展开到单一宿主语言，实现模块化和组合性的开放语言特征集，而非预定义封闭特征集的语言实现。

Result: 实现了从宿主语言(Racket)和中间语言之间的重用，以及高层与低层特征之间的互操作性，简化了中间语言语义的开发。

Conclusion: 该方法促进了中间语言中单个语言特征的扩展或重定义，并暴露了嵌入语言的多个接口，提高了开发效率和灵活性。

Abstract: We present the design and implementation of a macro-embedding of a family of
compiler intermediate languages, from a Scheme-like language to x86-64, into
Racket. This embedding is used as part of a testing framework for a compilers
course to derive interpreters for all the intermediate languages. The embedding
implements features including safe, functional abstractions as well as unsafe
assembly features, and the interactions between the two at various intermediate
stages.
  This paper aims to demonstrate language-oriented techniques and abstractions
for implementing (1) a large family of languages and (2) interoperability
between low- and high-level languages. The primary strength of this approach is
the high degree of code reuse and interoperability compared to implementing
each interpreter separately. The design emphasizes modularity and
compositionality of an open set of language features by local macro expansion
into a single host language, rather than implementing a language pre-defined by
a closed set of features. This enables reuse from both the host language
(Racket) and between intermediate languages, and enables interoperability
between high- and low-level features, simplifying development of the
intermediate language semantics. It also facilitates extending or redefining
individual language features in intermediate languages, and exposing multiple
interfaces to the embedded languages.

</details>


### [2] [Compilation as Multi-Language Semantics](https://arxiv.org/abs/2509.19613)
*William J. Bowman*

Main category: cs.PL

TL;DR: 本文提出了一种统一的多语言语义方法，将编译器建模为开放项上的归约系统，而不是语法翻译，从而同时定义编译器和互操作性语义。


<details>
  <summary>Details</summary>
Motivation: 现有多语言语义方法需要为每个编译器通道定义两个变体：用于建模编译的开放项语法翻译和用于建模互操作性的闭项运行时翻译，存在重复工作。

Method: 采用基于开放项的多语言语义归约系统，通过跨语言redex的规范化实现AOT编译，通过多语言评估实现JIT编译。

Result: 该方法减少了重复定义，提供了语义洞察，多语言归约的汇合性隐含编译器正确性，主题归约隐含类型保持性。

Conclusion: 统一的多语言归约方法能够同时建模编译器和互操作性，简化证明过程，为安全编译验证提供新视角。

Abstract: Modeling interoperability between programs in different languages is a key
problem when modeling verified and secure compilation, which has been
successfully addressed using multi-language semantics. Unfortunately, existing
models of compilation using multi-language semantics define two variants of
each compiler pass: a syntactic translation on open terms to model compilation,
and a run-time translation of closed terms at multi-language boundaries to
model interoperability.
  In this talk, I discuss work-in-progress approach to uniformly model a
compiler entirely as a reduction system on open term in a multi-language
semantics, rather than as a syntactic translation. This simultaneously defines
the compiler and the interoperability semantics, reducing duplication. It also
provides interesting semantic insights. Normalization of the cross-language
redexes performs ahead-of-time (AOT) compilation. Evaluation in the
multi-language models just-in-time (JIT) compilation. Confluence of
multi-language reduction implies compiler correctness, and part of the secure
compilation proof (full abstraction), enabling focus on the difficult part of
the proof. Subject reduction of the multi-language reduction implies
type-preservation of the compiler.

</details>


### [3] [The Syntax and Semantics of einsum](https://arxiv.org/abs/2509.20020)
*Maurice Wenig,Paul G. Rump,Mark Blacher,Joachim Giesen*

Main category: cs.PL

TL;DR: 本文为einsum符号提供了理论基础，定义了einsum语言，并证明张量表达式的重要等价规则。


<details>
  <summary>Details</summary>
Motivation: einsum符号虽然在实际应用中很成功，但缺乏坚实的理论基础，且在不同框架中不统一，限制了形式化推理和系统优化的机会。

Method: 讨论张量表达式的术语，提供einsum语言的形式化定义，基于此定义形式化并证明张量表达式的重要等价规则。

Result: 建立了einsum符号的理论基础，证明了等价规则，并强调了这些规则在实际应用中的相关性。

Conclusion: 通过形式化定义和等价规则的证明，为einsum符号提供了坚实的理论基础，有助于形式化推理和系统优化。

Abstract: In 2011, einsum was introduced to NumPy as a practical and convenient
notation for tensor expressions in machine learning, quantum circuit
simulation, and other fields. It has since been implemented in additional
Python frameworks such as PyTorch and TensorFlow, as well as in other
programming languages such as Julia. Despite its practical success, the einsum
notation still lacks a solid theoretical basis, and is not unified across the
different frameworks, limiting opportunities for formal reasoning and
systematic optimization. In this work, we discuss the terminology of tensor
expressions and provide a formal definition of the einsum language. Based on
this definition, we formalize and prove important equivalence rules for tensor
expressions and highlight their relevance in practical applications.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [4] [Automated Insertion of Flushes and Fences for Persistency](https://arxiv.org/abs/2509.19459)
*Yutong Guo,Weiyu Luo,Brian Demsky*

Main category: cs.SE

TL;DR: PMRobust是一个编译器，能自动插入flush和fence操作，确保持久内存代码没有缺失flush和fence的bug，性能开销仅为0.26%。


<details>
  <summary>Details</summary>
Motivation: 持久内存和CXL共享内存需要在崩溃后保持数据，但手动管理flush和fence操作非常困难，现有工具无法确保没有缺失flush的bug。

Method: PMRobust采用新颖的静态分析和针对新分配对象的优化，自动插入必要的flush和fence操作。

Result: 在持久内存库和数据结构上评估，相对于手动放置flush和fence操作的基准测试，几何平均开销仅为0.26%。

Conclusion: PMRobust能有效确保持久内存代码的正确性，且性能开销极小。

Abstract: CXL shared memory and persistent memory allow the contents of memory to
persist beyond crashes. Stores to persistent or CXL memory are typically not
immediately made persistent; developers must manually flush the corresponding
cache lines to force the data to be written to the underlying storage.
Correctly using flush and fence operations is known to be challenging. While
state-of-the-art tools can find missing flush instructions, they often require
bug-revealing test cases. No existing tools can ensure the absence of missing
flush bugs.
  In this paper, we present PMRobust, a compiler that automatically inserts
flush and fence operations to ensure that code using persistent memory is free
from missing flush and fence bugs. PMRobust employs a novel static analysis
with optimizations that target newly allocated objects. We have evaluated
PMRobust on persistent memory libraries and several persistent memory data
structures and measured a geometric mean overhead of 0.26% relative to the
original benchmarks with hand-placed flush and fence operations.

</details>
