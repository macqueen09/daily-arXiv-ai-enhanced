<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]
- [cs.NI](#cs.NI) [Total: 1]
- [cs.CL](#cs.CL) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [InvBench: Can LLMs Accelerate Program Verification with Invariant Synthesis?](https://arxiv.org/abs/2509.21629)
*Anjiang Wei,Tarun Suresh,Tianran Sun,Haoze Wu,Ke Wang,Alex Aiken*

Main category: cs.PL

TL;DR: 提出了一个评估LLMs在循环不变量合成方面的框架，使用基于验证器的决策程序，评估正确性和验证速度提升。测试了7个最先进的LLMs和现有LLM验证器，发现它们尚未显著优于传统求解器UAutomizer，但监督微调和Best-of-N采样可以提升性能。


<details>
  <summary>Details</summary>
Motivation: 程序验证依赖循环不变量，但自动发现强不变量仍是长期挑战，需要建立原则性框架来评估LLMs在不变量合成方面的能力。

Method: 使用基于验证器的决策程序，具有形式化正确性保证，评估不变量正确性和验证速度提升。对7个最先进LLMs和现有LLM验证器进行基准测试，并与传统求解器UAutomizer比较。采用监督微调和Best-of-N采样来改进性能。

Result: LLM验证器虽前景可观，但尚未显著优于UAutomizer。模型能力至关重要，不同模型的速度提升差异显著。监督微调（3589个实例）将Qwen3-Coder-480B的速度提升案例比例从8%提高到29.2%，Best-of-N采样（N=16）将Claude-sonnet-4从8.8%提升到22.1%。

Conclusion: 当前LLMs在循环不变量合成方面仍面临挑战，但监督微调和采样技术可以显著提升性能，为未来LLM在程序验证中的应用提供了方向。

Abstract: Program verification relies on loop invariants, yet automatically discovering
strong invariants remains a long-standing challenge. We introduce a principled
framework for evaluating LLMs on invariant synthesis. Our approach uses a
verifier-based decision procedure with a formal soundness guarantee and
assesses not only correctness but also the speedup that invariants provide in
verification. We evaluate 7 state-of-the-art LLMs, and existing LLM-based
verifiers against the traditional solver UAutomizer. While LLM-based verifiers
represent a promising direction, they do not yet offer a significant advantage
over UAutomizer. Model capability also proves critical, as shown by sharp
differences in speedups across models, and our benchmark remains an open
challenge for current LLMs. Finally, we show that supervised fine-tuning and
Best-of-N sampling can improve performance: fine-tuning on 3589 instances
raises the percentage of speedup cases for Qwen3-Coder-480B from 8% to 29.2%,
and Best-of-N sampling with N=16 improves Claude-sonnet-4 from 8.8% to 22.1%.

</details>


### [2] [Compiling by Proving: Language-Agnostic Automatic Optimization from Formal Semantics](https://arxiv.org/abs/2509.21793)
*Jianhong Zhao,Everett Hildenbrandt,Juan Conejero,Yongwang Zhao*

Main category: cs.PL

TL;DR: 提出"通过证明编译"的新范式，将验证证明转化为优化的执行规则，通过构建全路径可达性证明并编译其图结构，在保持正确性的同时实现性能提升。


<details>
  <summary>Details</summary>
Motivation: 验证证明包含了完整的程序行为信息，但在检查正确性后就被丢弃，这些信息可以用于优化程序执行。

Method: 通过符号执行构建全路径可达性证明，编译其图结构，将多个语义重写合并为单一规则，在K框架中实现语言无关的扩展。

Result: 评估显示在不同编译范围内都取得性能提升：操作码级优化实现持续加速，全程序编译获得数量级性能增益。

Conclusion: 通过证明编译是可行的优化方法，能够利用验证证明中的信息显著提升程序执行性能。

Abstract: Verification proofs encode complete program behavior, yet we discard them
after checking correctness. We present compiling by proving, a paradigm that
transforms these proofs into optimized execution rules. By constructing
All-Path Reachability Proofs through symbolic execution and compiling their
graph structure, we consolidate many semantic rewrites into single rules while
preserving correctness by construction. We implement this as a
language-agnostic extension to the K framework. Evaluation demonstrates
performance improvements across different compilation scopes: opcode-level
optimizations show consistent speedups, while whole-program compilation
achieves orders of magnitude greater performance gains.

</details>


### [3] [Committing to the bit: Relational programming with semiring arrays and SAT solving](https://arxiv.org/abs/2509.22614)
*Dmitri Volkov,Yafei Yang,Chung-chieh Shan*

Main category: cs.PL

TL;DR: 提出semiringKanren关系编程语言，将关系表达式表示为半环数组，通过类型系统限制数组为有限大小，并编译为位串表示。对于布尔半环，可使用SAT求解器高效运行程序，在解决数独问题时比miniKanren更高效。


<details>
  <summary>Details</summary>
Motivation: 开发一种基于半环的关系编程语言，通过类型系统和编译技术实现高效执行，特别是利用SAT求解器来提升性能。

Method: 定义semiringKanren语言，关系表达式表示半环数组；建立类型系统限制数组大小；语义参数化半环；编译类型到位串表示；对布尔半环使用SAT求解器。

Result: 实验比较semiringKanren和miniKanren解决数独问题的性能，显示semiringKanren可以成为miniKanren的更高效变体。

Conclusion: semiringKanren通过半环数组表示和SAT求解器的使用，在关系编程中实现了比传统miniKanren更高的效率。

Abstract: We propose semiringKanren, a relational programming language where each
relation expression denotes a semiring array. We formalize a type system that
restricts the arrays to finite size. We then define a semantics that is
parameterized by the semiring that the arrays draw their elements from. We
compile semiringKanren types to bitstring representations. For the Boolean
semiring, this compilation enables us to use an SAT solver to run
semiringKanren programs efficiently. We compare the performance of
semiringKanren and faster miniKanren for solving Sudoku puzzles. Our experiment
shows that semiringKanren can be a more efficient variant of miniKanren.

</details>


<div id='cs.NI'></div>

# cs.NI [[Back]](#toc)

### [4] [A Target-Agnostic Protocol-Independent Interface for the Transport Layer](https://arxiv.org/abs/2509.21550)
*Pedro Mizuno,Kimiya Mohammadtaheri,Linfan Qian,Joshua Johnson,Danny Akbarzadeh,Chris Neely,Mario Baldi,Nacihket Kapre,Mina Tahmasbi Arashloo*

Main category: cs.NI

TL;DR: 提出TINF框架，通过高级、目标无关的编程抽象来规范传输协议，支持多种后端实现，简化传输协议开发并支持自动化分析。


<details>
  <summary>Details</summary>
Motivation: 传输协议在网络通信中至关重要，但协议和目标环境的多样性需要一种高级、目标无关的编程抽象来统一开发。

Method: 将传输协议指定为高级程序，使用受限的C类结构处理事件和流状态，生成目标无关的指令，支持数据重组、包生成和调度等操作。

Result: 开发了TINF框架和两个兼容后端（DPDK和Linux eXpress DataPath），成功部署了多个传输协议，验证了框架的有效性。

Conclusion: 目标无关的传输程序可以减少传输协议开发工作量，支持自动化分析和形式验证，并推动传输协议可编程目标的研究。

Abstract: Transport protocols are fundamental to network communications, continuously
evolving to meet the demands of new applications, workloads, and network
architectures while running in a wide range of execution environments (a.k.a
targets). We argue that this diversity across protocols and targets calls for a
high-level, target-agnostic programming abstraction for the transport layer.
Specifically, we propose to specify transport protocols as high-level programs
that take an event and flow state as input, and using constrained C-like
constructs, produce the updated state along with target-agnostic instructions
for key transport operations such as data reassembly, packet generation and
scheduling, and timer manipulations.
  We show the benefits of our high-level transport programs by developing
multiple transport protocols in our programming framework called TINF,
developing two TINF- compliant backends, one in DPDK and one in Linux eXpress
DataPath, and deploying TINF programs for multiple protocols across both
backends. Inspired by the benefits unlocked by L2/L3 packet-processing
languages like P4, we believe target-agnostic transport programs can reduce the
development effort for transport protocols, enable automated analysis and
formal verification of the transport layer, and further research in
programmable targets for transport protocols.

</details>


<div id='cs.CL'></div>

# cs.CL [[Back]](#toc)

### [5] [On Code-Induced Reasoning in LLMs](https://arxiv.org/abs/2509.21499)
*Abdul Waheed,Zhen Wu,Carolyn Rosé,Daphne Ippolito*

Main category: cs.CL

TL;DR: 本文通过系统实验发现，代码的结构特性比语义特性对LLM推理能力影响更大，适当的抽象（如伪代码）可以替代真实代码，而保持表面规律性的损坏代码仍具竞争力。


<details>
  <summary>Details</summary>
Motivation: 研究代码中哪些方面对提升大语言模型推理能力最关键，为设计训练数据提供指导。

Method: 构建10种编程语言的并行指令数据集，应用受控扰动选择性破坏代码的结构或语义属性，在5个模型家族和8个规模上进行了3,331次实验。

Result: LLM对结构扰动比语义扰动更敏感；伪代码和流程图等抽象与真实代码效果相当；保持表面规律性的损坏代码仍具竞争力；Python有利于自然语言推理，Java和Rust有利于数学推理。

Conclusion: 代码的结构特性是影响LLM推理能力的关键因素，适当的抽象可以替代真实代码，这为优化LLM训练数据设计提供了重要见解。

Abstract: Code data has been shown to enhance the reasoning capabilities of large
language models (LLMs), but it remains unclear which aspects of code are most
responsible. We investigate this question with a systematic, data-centric
framework. We construct parallel instruction datasets in ten programming
languages and apply controlled perturbations that selectively disrupt
structural or semantic properties of code. We then finetune LLMs from five
model families and eight scales on each variant and evaluate their performance
on natural language, math, and code tasks. Across 3,331 experiments, our
results show that LLMs are more vulnerable to structural perturbations than
semantic ones, particularly on math and code tasks. Appropriate abstractions
like pseudocode and flowcharts can be as effective as code, while encoding the
same information with fewer tokens without adhering to original syntax can
often retain or even improve performance. Remarkably, even corrupted code with
misleading signals remains competitive when surface-level regularities persist.
Finally, syntactic styles also shape task-specific gains with Python favoring
natural language reasoning and lower-level languages such as Java and Rust
favoring math. Through our systematic framework, we aim to provide insight into
how different properties of code influence reasoning and inform the design of
training data for enhancing LLM reasoning capabilities.

</details>
