{"id": "2509.21629", "pdf": "https://arxiv.org/pdf/2509.21629", "abs": "https://arxiv.org/abs/2509.21629", "authors": ["Anjiang Wei", "Tarun Suresh", "Tianran Sun", "Haoze Wu", "Ke Wang", "Alex Aiken"], "title": "InvBench: Can LLMs Accelerate Program Verification with Invariant Synthesis?", "categories": ["cs.PL", "cs.AI", "cs.CL", "cs.LG"], "comment": null, "summary": "Program verification relies on loop invariants, yet automatically discovering\nstrong invariants remains a long-standing challenge. We introduce a principled\nframework for evaluating LLMs on invariant synthesis. Our approach uses a\nverifier-based decision procedure with a formal soundness guarantee and\nassesses not only correctness but also the speedup that invariants provide in\nverification. We evaluate 7 state-of-the-art LLMs, and existing LLM-based\nverifiers against the traditional solver UAutomizer. While LLM-based verifiers\nrepresent a promising direction, they do not yet offer a significant advantage\nover UAutomizer. Model capability also proves critical, as shown by sharp\ndifferences in speedups across models, and our benchmark remains an open\nchallenge for current LLMs. Finally, we show that supervised fine-tuning and\nBest-of-N sampling can improve performance: fine-tuning on 3589 instances\nraises the percentage of speedup cases for Qwen3-Coder-480B from 8% to 29.2%,\nand Best-of-N sampling with N=16 improves Claude-sonnet-4 from 8.8% to 22.1%.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u4e2a\u8bc4\u4f30LLMs\u5728\u5faa\u73af\u4e0d\u53d8\u91cf\u5408\u6210\u65b9\u9762\u7684\u6846\u67b6\uff0c\u4f7f\u7528\u57fa\u4e8e\u9a8c\u8bc1\u5668\u7684\u51b3\u7b56\u7a0b\u5e8f\uff0c\u8bc4\u4f30\u6b63\u786e\u6027\u548c\u9a8c\u8bc1\u901f\u5ea6\u63d0\u5347\u3002\u6d4b\u8bd5\u4e867\u4e2a\u6700\u5148\u8fdb\u7684LLMs\u548c\u73b0\u6709LLM\u9a8c\u8bc1\u5668\uff0c\u53d1\u73b0\u5b83\u4eec\u5c1a\u672a\u663e\u8457\u4f18\u4e8e\u4f20\u7edf\u6c42\u89e3\u5668UAutomizer\uff0c\u4f46\u76d1\u7763\u5fae\u8c03\u548cBest-of-N\u91c7\u6837\u53ef\u4ee5\u63d0\u5347\u6027\u80fd\u3002", "motivation": "\u7a0b\u5e8f\u9a8c\u8bc1\u4f9d\u8d56\u5faa\u73af\u4e0d\u53d8\u91cf\uff0c\u4f46\u81ea\u52a8\u53d1\u73b0\u5f3a\u4e0d\u53d8\u91cf\u4ecd\u662f\u957f\u671f\u6311\u6218\uff0c\u9700\u8981\u5efa\u7acb\u539f\u5219\u6027\u6846\u67b6\u6765\u8bc4\u4f30LLMs\u5728\u4e0d\u53d8\u91cf\u5408\u6210\u65b9\u9762\u7684\u80fd\u529b\u3002", "method": "\u4f7f\u7528\u57fa\u4e8e\u9a8c\u8bc1\u5668\u7684\u51b3\u7b56\u7a0b\u5e8f\uff0c\u5177\u6709\u5f62\u5f0f\u5316\u6b63\u786e\u6027\u4fdd\u8bc1\uff0c\u8bc4\u4f30\u4e0d\u53d8\u91cf\u6b63\u786e\u6027\u548c\u9a8c\u8bc1\u901f\u5ea6\u63d0\u5347\u3002\u5bf97\u4e2a\u6700\u5148\u8fdbLLMs\u548c\u73b0\u6709LLM\u9a8c\u8bc1\u5668\u8fdb\u884c\u57fa\u51c6\u6d4b\u8bd5\uff0c\u5e76\u4e0e\u4f20\u7edf\u6c42\u89e3\u5668UAutomizer\u6bd4\u8f83\u3002\u91c7\u7528\u76d1\u7763\u5fae\u8c03\u548cBest-of-N\u91c7\u6837\u6765\u6539\u8fdb\u6027\u80fd\u3002", "result": "LLM\u9a8c\u8bc1\u5668\u867d\u524d\u666f\u53ef\u89c2\uff0c\u4f46\u5c1a\u672a\u663e\u8457\u4f18\u4e8eUAutomizer\u3002\u6a21\u578b\u80fd\u529b\u81f3\u5173\u91cd\u8981\uff0c\u4e0d\u540c\u6a21\u578b\u7684\u901f\u5ea6\u63d0\u5347\u5dee\u5f02\u663e\u8457\u3002\u76d1\u7763\u5fae\u8c03\uff083589\u4e2a\u5b9e\u4f8b\uff09\u5c06Qwen3-Coder-480B\u7684\u901f\u5ea6\u63d0\u5347\u6848\u4f8b\u6bd4\u4f8b\u4ece8%\u63d0\u9ad8\u523029.2%\uff0cBest-of-N\u91c7\u6837\uff08N=16\uff09\u5c06Claude-sonnet-4\u4ece8.8%\u63d0\u5347\u523022.1%\u3002", "conclusion": "\u5f53\u524dLLMs\u5728\u5faa\u73af\u4e0d\u53d8\u91cf\u5408\u6210\u65b9\u9762\u4ecd\u9762\u4e34\u6311\u6218\uff0c\u4f46\u76d1\u7763\u5fae\u8c03\u548c\u91c7\u6837\u6280\u672f\u53ef\u4ee5\u663e\u8457\u63d0\u5347\u6027\u80fd\uff0c\u4e3a\u672a\u6765LLM\u5728\u7a0b\u5e8f\u9a8c\u8bc1\u4e2d\u7684\u5e94\u7528\u63d0\u4f9b\u4e86\u65b9\u5411\u3002"}}
{"id": "2509.21793", "pdf": "https://arxiv.org/pdf/2509.21793", "abs": "https://arxiv.org/abs/2509.21793", "authors": ["Jianhong Zhao", "Everett Hildenbrandt", "Juan Conejero", "Yongwang Zhao"], "title": "Compiling by Proving: Language-Agnostic Automatic Optimization from Formal Semantics", "categories": ["cs.PL", "cs.CL"], "comment": null, "summary": "Verification proofs encode complete program behavior, yet we discard them\nafter checking correctness. We present compiling by proving, a paradigm that\ntransforms these proofs into optimized execution rules. By constructing\nAll-Path Reachability Proofs through symbolic execution and compiling their\ngraph structure, we consolidate many semantic rewrites into single rules while\npreserving correctness by construction. We implement this as a\nlanguage-agnostic extension to the K framework. Evaluation demonstrates\nperformance improvements across different compilation scopes: opcode-level\noptimizations show consistent speedups, while whole-program compilation\nachieves orders of magnitude greater performance gains.", "AI": {"tldr": "\u63d0\u51fa\"\u901a\u8fc7\u8bc1\u660e\u7f16\u8bd1\"\u7684\u65b0\u8303\u5f0f\uff0c\u5c06\u9a8c\u8bc1\u8bc1\u660e\u8f6c\u5316\u4e3a\u4f18\u5316\u7684\u6267\u884c\u89c4\u5219\uff0c\u901a\u8fc7\u6784\u5efa\u5168\u8def\u5f84\u53ef\u8fbe\u6027\u8bc1\u660e\u5e76\u7f16\u8bd1\u5176\u56fe\u7ed3\u6784\uff0c\u5728\u4fdd\u6301\u6b63\u786e\u6027\u7684\u540c\u65f6\u5b9e\u73b0\u6027\u80fd\u63d0\u5347\u3002", "motivation": "\u9a8c\u8bc1\u8bc1\u660e\u5305\u542b\u4e86\u5b8c\u6574\u7684\u7a0b\u5e8f\u884c\u4e3a\u4fe1\u606f\uff0c\u4f46\u5728\u68c0\u67e5\u6b63\u786e\u6027\u540e\u5c31\u88ab\u4e22\u5f03\uff0c\u8fd9\u4e9b\u4fe1\u606f\u53ef\u4ee5\u7528\u4e8e\u4f18\u5316\u7a0b\u5e8f\u6267\u884c\u3002", "method": "\u901a\u8fc7\u7b26\u53f7\u6267\u884c\u6784\u5efa\u5168\u8def\u5f84\u53ef\u8fbe\u6027\u8bc1\u660e\uff0c\u7f16\u8bd1\u5176\u56fe\u7ed3\u6784\uff0c\u5c06\u591a\u4e2a\u8bed\u4e49\u91cd\u5199\u5408\u5e76\u4e3a\u5355\u4e00\u89c4\u5219\uff0c\u5728K\u6846\u67b6\u4e2d\u5b9e\u73b0\u8bed\u8a00\u65e0\u5173\u7684\u6269\u5c55\u3002", "result": "\u8bc4\u4f30\u663e\u793a\u5728\u4e0d\u540c\u7f16\u8bd1\u8303\u56f4\u5185\u90fd\u53d6\u5f97\u6027\u80fd\u63d0\u5347\uff1a\u64cd\u4f5c\u7801\u7ea7\u4f18\u5316\u5b9e\u73b0\u6301\u7eed\u52a0\u901f\uff0c\u5168\u7a0b\u5e8f\u7f16\u8bd1\u83b7\u5f97\u6570\u91cf\u7ea7\u6027\u80fd\u589e\u76ca\u3002", "conclusion": "\u901a\u8fc7\u8bc1\u660e\u7f16\u8bd1\u662f\u53ef\u884c\u7684\u4f18\u5316\u65b9\u6cd5\uff0c\u80fd\u591f\u5229\u7528\u9a8c\u8bc1\u8bc1\u660e\u4e2d\u7684\u4fe1\u606f\u663e\u8457\u63d0\u5347\u7a0b\u5e8f\u6267\u884c\u6027\u80fd\u3002"}}
{"id": "2509.22614", "pdf": "https://arxiv.org/pdf/2509.22614", "abs": "https://arxiv.org/abs/2509.22614", "authors": ["Dmitri Volkov", "Yafei Yang", "Chung-chieh Shan"], "title": "Committing to the bit: Relational programming with semiring arrays and SAT solving", "categories": ["cs.PL", "D.3.1; F.3.2; D.3.2; D.3.3"], "comment": "12 pages, for associated repo see\n  https://github.com/sporkl/semiringkanren", "summary": "We propose semiringKanren, a relational programming language where each\nrelation expression denotes a semiring array. We formalize a type system that\nrestricts the arrays to finite size. We then define a semantics that is\nparameterized by the semiring that the arrays draw their elements from. We\ncompile semiringKanren types to bitstring representations. For the Boolean\nsemiring, this compilation enables us to use an SAT solver to run\nsemiringKanren programs efficiently. We compare the performance of\nsemiringKanren and faster miniKanren for solving Sudoku puzzles. Our experiment\nshows that semiringKanren can be a more efficient variant of miniKanren.", "AI": {"tldr": "\u63d0\u51fasemiringKanren\u5173\u7cfb\u7f16\u7a0b\u8bed\u8a00\uff0c\u5c06\u5173\u7cfb\u8868\u8fbe\u5f0f\u8868\u793a\u4e3a\u534a\u73af\u6570\u7ec4\uff0c\u901a\u8fc7\u7c7b\u578b\u7cfb\u7edf\u9650\u5236\u6570\u7ec4\u4e3a\u6709\u9650\u5927\u5c0f\uff0c\u5e76\u7f16\u8bd1\u4e3a\u4f4d\u4e32\u8868\u793a\u3002\u5bf9\u4e8e\u5e03\u5c14\u534a\u73af\uff0c\u53ef\u4f7f\u7528SAT\u6c42\u89e3\u5668\u9ad8\u6548\u8fd0\u884c\u7a0b\u5e8f\uff0c\u5728\u89e3\u51b3\u6570\u72ec\u95ee\u9898\u65f6\u6bd4miniKanren\u66f4\u9ad8\u6548\u3002", "motivation": "\u5f00\u53d1\u4e00\u79cd\u57fa\u4e8e\u534a\u73af\u7684\u5173\u7cfb\u7f16\u7a0b\u8bed\u8a00\uff0c\u901a\u8fc7\u7c7b\u578b\u7cfb\u7edf\u548c\u7f16\u8bd1\u6280\u672f\u5b9e\u73b0\u9ad8\u6548\u6267\u884c\uff0c\u7279\u522b\u662f\u5229\u7528SAT\u6c42\u89e3\u5668\u6765\u63d0\u5347\u6027\u80fd\u3002", "method": "\u5b9a\u4e49semiringKanren\u8bed\u8a00\uff0c\u5173\u7cfb\u8868\u8fbe\u5f0f\u8868\u793a\u534a\u73af\u6570\u7ec4\uff1b\u5efa\u7acb\u7c7b\u578b\u7cfb\u7edf\u9650\u5236\u6570\u7ec4\u5927\u5c0f\uff1b\u8bed\u4e49\u53c2\u6570\u5316\u534a\u73af\uff1b\u7f16\u8bd1\u7c7b\u578b\u5230\u4f4d\u4e32\u8868\u793a\uff1b\u5bf9\u5e03\u5c14\u534a\u73af\u4f7f\u7528SAT\u6c42\u89e3\u5668\u3002", "result": "\u5b9e\u9a8c\u6bd4\u8f83semiringKanren\u548cminiKanren\u89e3\u51b3\u6570\u72ec\u95ee\u9898\u7684\u6027\u80fd\uff0c\u663e\u793asemiringKanren\u53ef\u4ee5\u6210\u4e3aminiKanren\u7684\u66f4\u9ad8\u6548\u53d8\u4f53\u3002", "conclusion": "semiringKanren\u901a\u8fc7\u534a\u73af\u6570\u7ec4\u8868\u793a\u548cSAT\u6c42\u89e3\u5668\u7684\u4f7f\u7528\uff0c\u5728\u5173\u7cfb\u7f16\u7a0b\u4e2d\u5b9e\u73b0\u4e86\u6bd4\u4f20\u7edfminiKanren\u66f4\u9ad8\u7684\u6548\u7387\u3002"}}
{"id": "2509.21499", "pdf": "https://arxiv.org/pdf/2509.21499", "abs": "https://arxiv.org/abs/2509.21499", "authors": ["Abdul Waheed", "Zhen Wu", "Carolyn Ros\u00e9", "Daphne Ippolito"], "title": "On Code-Induced Reasoning in LLMs", "categories": ["cs.CL", "cs.PL"], "comment": null, "summary": "Code data has been shown to enhance the reasoning capabilities of large\nlanguage models (LLMs), but it remains unclear which aspects of code are most\nresponsible. We investigate this question with a systematic, data-centric\nframework. We construct parallel instruction datasets in ten programming\nlanguages and apply controlled perturbations that selectively disrupt\nstructural or semantic properties of code. We then finetune LLMs from five\nmodel families and eight scales on each variant and evaluate their performance\non natural language, math, and code tasks. Across 3,331 experiments, our\nresults show that LLMs are more vulnerable to structural perturbations than\nsemantic ones, particularly on math and code tasks. Appropriate abstractions\nlike pseudocode and flowcharts can be as effective as code, while encoding the\nsame information with fewer tokens without adhering to original syntax can\noften retain or even improve performance. Remarkably, even corrupted code with\nmisleading signals remains competitive when surface-level regularities persist.\nFinally, syntactic styles also shape task-specific gains with Python favoring\nnatural language reasoning and lower-level languages such as Java and Rust\nfavoring math. Through our systematic framework, we aim to provide insight into\nhow different properties of code influence reasoning and inform the design of\ntraining data for enhancing LLM reasoning capabilities.", "AI": {"tldr": "\u672c\u6587\u901a\u8fc7\u7cfb\u7edf\u5b9e\u9a8c\u53d1\u73b0\uff0c\u4ee3\u7801\u7684\u7ed3\u6784\u7279\u6027\u6bd4\u8bed\u4e49\u7279\u6027\u5bf9LLM\u63a8\u7406\u80fd\u529b\u5f71\u54cd\u66f4\u5927\uff0c\u9002\u5f53\u7684\u62bd\u8c61\uff08\u5982\u4f2a\u4ee3\u7801\uff09\u53ef\u4ee5\u66ff\u4ee3\u771f\u5b9e\u4ee3\u7801\uff0c\u800c\u4fdd\u6301\u8868\u9762\u89c4\u5f8b\u6027\u7684\u635f\u574f\u4ee3\u7801\u4ecd\u5177\u7ade\u4e89\u529b\u3002", "motivation": "\u7814\u7a76\u4ee3\u7801\u4e2d\u54ea\u4e9b\u65b9\u9762\u5bf9\u63d0\u5347\u5927\u8bed\u8a00\u6a21\u578b\u63a8\u7406\u80fd\u529b\u6700\u5173\u952e\uff0c\u4e3a\u8bbe\u8ba1\u8bad\u7ec3\u6570\u636e\u63d0\u4f9b\u6307\u5bfc\u3002", "method": "\u6784\u5efa10\u79cd\u7f16\u7a0b\u8bed\u8a00\u7684\u5e76\u884c\u6307\u4ee4\u6570\u636e\u96c6\uff0c\u5e94\u7528\u53d7\u63a7\u6270\u52a8\u9009\u62e9\u6027\u7834\u574f\u4ee3\u7801\u7684\u7ed3\u6784\u6216\u8bed\u4e49\u5c5e\u6027\uff0c\u57285\u4e2a\u6a21\u578b\u5bb6\u65cf\u548c8\u4e2a\u89c4\u6a21\u4e0a\u8fdb\u884c\u4e863,331\u6b21\u5b9e\u9a8c\u3002", "result": "LLM\u5bf9\u7ed3\u6784\u6270\u52a8\u6bd4\u8bed\u4e49\u6270\u52a8\u66f4\u654f\u611f\uff1b\u4f2a\u4ee3\u7801\u548c\u6d41\u7a0b\u56fe\u7b49\u62bd\u8c61\u4e0e\u771f\u5b9e\u4ee3\u7801\u6548\u679c\u76f8\u5f53\uff1b\u4fdd\u6301\u8868\u9762\u89c4\u5f8b\u6027\u7684\u635f\u574f\u4ee3\u7801\u4ecd\u5177\u7ade\u4e89\u529b\uff1bPython\u6709\u5229\u4e8e\u81ea\u7136\u8bed\u8a00\u63a8\u7406\uff0cJava\u548cRust\u6709\u5229\u4e8e\u6570\u5b66\u63a8\u7406\u3002", "conclusion": "\u4ee3\u7801\u7684\u7ed3\u6784\u7279\u6027\u662f\u5f71\u54cdLLM\u63a8\u7406\u80fd\u529b\u7684\u5173\u952e\u56e0\u7d20\uff0c\u9002\u5f53\u7684\u62bd\u8c61\u53ef\u4ee5\u66ff\u4ee3\u771f\u5b9e\u4ee3\u7801\uff0c\u8fd9\u4e3a\u4f18\u5316LLM\u8bad\u7ec3\u6570\u636e\u8bbe\u8ba1\u63d0\u4f9b\u4e86\u91cd\u8981\u89c1\u89e3\u3002"}}
{"id": "2509.21550", "pdf": "https://arxiv.org/pdf/2509.21550", "abs": "https://arxiv.org/abs/2509.21550", "authors": ["Pedro Mizuno", "Kimiya Mohammadtaheri", "Linfan Qian", "Joshua Johnson", "Danny Akbarzadeh", "Chris Neely", "Mario Baldi", "Nacihket Kapre", "Mina Tahmasbi Arashloo"], "title": "A Target-Agnostic Protocol-Independent Interface for the Transport Layer", "categories": ["cs.NI", "cs.OS", "cs.PL", "C.2.2; C.2.3; D.3.3"], "comment": null, "summary": "Transport protocols are fundamental to network communications, continuously\nevolving to meet the demands of new applications, workloads, and network\narchitectures while running in a wide range of execution environments (a.k.a\ntargets). We argue that this diversity across protocols and targets calls for a\nhigh-level, target-agnostic programming abstraction for the transport layer.\nSpecifically, we propose to specify transport protocols as high-level programs\nthat take an event and flow state as input, and using constrained C-like\nconstructs, produce the updated state along with target-agnostic instructions\nfor key transport operations such as data reassembly, packet generation and\nscheduling, and timer manipulations.\n  We show the benefits of our high-level transport programs by developing\nmultiple transport protocols in our programming framework called TINF,\ndeveloping two TINF- compliant backends, one in DPDK and one in Linux eXpress\nDataPath, and deploying TINF programs for multiple protocols across both\nbackends. Inspired by the benefits unlocked by L2/L3 packet-processing\nlanguages like P4, we believe target-agnostic transport programs can reduce the\ndevelopment effort for transport protocols, enable automated analysis and\nformal verification of the transport layer, and further research in\nprogrammable targets for transport protocols.", "AI": {"tldr": "\u63d0\u51faTINF\u6846\u67b6\uff0c\u901a\u8fc7\u9ad8\u7ea7\u3001\u76ee\u6807\u65e0\u5173\u7684\u7f16\u7a0b\u62bd\u8c61\u6765\u89c4\u8303\u4f20\u8f93\u534f\u8bae\uff0c\u652f\u6301\u591a\u79cd\u540e\u7aef\u5b9e\u73b0\uff0c\u7b80\u5316\u4f20\u8f93\u534f\u8bae\u5f00\u53d1\u5e76\u652f\u6301\u81ea\u52a8\u5316\u5206\u6790\u3002", "motivation": "\u4f20\u8f93\u534f\u8bae\u5728\u7f51\u7edc\u901a\u4fe1\u4e2d\u81f3\u5173\u91cd\u8981\uff0c\u4f46\u534f\u8bae\u548c\u76ee\u6807\u73af\u5883\u7684\u591a\u6837\u6027\u9700\u8981\u4e00\u79cd\u9ad8\u7ea7\u3001\u76ee\u6807\u65e0\u5173\u7684\u7f16\u7a0b\u62bd\u8c61\u6765\u7edf\u4e00\u5f00\u53d1\u3002", "method": "\u5c06\u4f20\u8f93\u534f\u8bae\u6307\u5b9a\u4e3a\u9ad8\u7ea7\u7a0b\u5e8f\uff0c\u4f7f\u7528\u53d7\u9650\u7684C\u7c7b\u7ed3\u6784\u5904\u7406\u4e8b\u4ef6\u548c\u6d41\u72b6\u6001\uff0c\u751f\u6210\u76ee\u6807\u65e0\u5173\u7684\u6307\u4ee4\uff0c\u652f\u6301\u6570\u636e\u91cd\u7ec4\u3001\u5305\u751f\u6210\u548c\u8c03\u5ea6\u7b49\u64cd\u4f5c\u3002", "result": "\u5f00\u53d1\u4e86TINF\u6846\u67b6\u548c\u4e24\u4e2a\u517c\u5bb9\u540e\u7aef\uff08DPDK\u548cLinux eXpress DataPath\uff09\uff0c\u6210\u529f\u90e8\u7f72\u4e86\u591a\u4e2a\u4f20\u8f93\u534f\u8bae\uff0c\u9a8c\u8bc1\u4e86\u6846\u67b6\u7684\u6709\u6548\u6027\u3002", "conclusion": "\u76ee\u6807\u65e0\u5173\u7684\u4f20\u8f93\u7a0b\u5e8f\u53ef\u4ee5\u51cf\u5c11\u4f20\u8f93\u534f\u8bae\u5f00\u53d1\u5de5\u4f5c\u91cf\uff0c\u652f\u6301\u81ea\u52a8\u5316\u5206\u6790\u548c\u5f62\u5f0f\u9a8c\u8bc1\uff0c\u5e76\u63a8\u52a8\u4f20\u8f93\u534f\u8bae\u53ef\u7f16\u7a0b\u76ee\u6807\u7684\u7814\u7a76\u3002"}}
