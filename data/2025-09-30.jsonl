{"id": "2509.22982", "pdf": "https://arxiv.org/pdf/2509.22982", "abs": "https://arxiv.org/abs/2509.22982", "authors": ["David M Kahn", "Jan Hoffmann", "Thomas Reps", "Jessie Grosen"], "title": "Efficient Cost Bounds with Linear Maps", "categories": ["cs.PL"], "comment": null, "summary": "The Automatic Amortized Resource Analysis (AARA) derives program-execution\ncost bounds using types. To do so, AARA often makes use of cost-free types,\nwhich are critical for the composition of types and cost bounds. However,\ninferring cost-free types using the current state-of-the-art algorithm is\nexpensive due to recursive dependence on additional cost-free types.\nFurthermore, that algorithm uses a heuristic only applicable to polynomial cost\nbounds, and not, e.g., exponential bounds. This paper presents a new approach\nto these problems by representing the cost-free types of a function in a new\nway: with a linear map, which can stand for infinitely many cost-free types.\nSuch maps enable an algebraic flavor of reasoning about cost bounds (including\nnon-polynomial bounds) via matrix inequalities. These inequalities can be\nsolved with off-the-shelf linear-programming tools for many programs, so that\ntypes can always be efficiently checked and often be efficiently inferred. An\nexperimental evaluation with a prototype implementation shows that-when it is\napplicable-the inference of linear maps is exponentially more efficient than\nthe state-of-the-art algorithm."}
{"id": "2509.23061", "pdf": "https://arxiv.org/pdf/2509.23061", "abs": "https://arxiv.org/abs/2509.23061", "authors": ["Xu Xu", "Xin Li", "Xingwei Qu", "Jie Fu", "Binhang Yuan"], "title": "Local Success Does Not Compose: Benchmarking Large Language Models for Compositional Formal Verification", "categories": ["cs.PL", "cs.AI"], "comment": null, "summary": "We introduce DafnyCOMP, a benchmark for evaluating large language models\n(LLMs) on compositional specification generation in Dafny. Unlike prior\nbenchmarks that focus on single-function tasks, DafnyCOMP targets programs\ncomposed of multiple interacting functions with data dependencies, requiring\nreasoning across component boundaries. The benchmark consists of 300\nautomatically synthesized multi-function programs. We evaluate several\nstate-of-the-art LLM families and find that, while they perform well on\nsingle-function verification, their performance drops sharply on compositional\ntasks. Analysis reveals systematic failures in cross-functional reasoning,\nincluding fragile specifications, misalignment between implementations and\nproofs, and unstable reasoning. DafnyCOMP thus provides a diagnostic tool for\nmeasuring progress toward reliable, verifiable, and compositional code\ngeneration with LLMs."}
{"id": "2509.23229", "pdf": "https://arxiv.org/pdf/2509.23229", "abs": "https://arxiv.org/abs/2509.23229", "authors": ["Yawen Guan", "Clément Pit-Claudel"], "title": "Fine-Grained Reasoning About Container-Internal Pointers with Logical Pinning", "categories": ["cs.PL", "D.2.4; F.3.1"], "comment": null, "summary": "Most separation logics hide container-internal pointers for modularity. This\nmakes it difficult to specify container APIs that temporarily expose those\npointers to the outside, and to verify programs that use these APIs. We present\nlogical pinning, a lightweight borrowing model for sequential programs that\nallows users to selectively track container-internal pointers at the logical\nlevel. Our model generalizes the magic-wand operator, making it easy to write\nand prove precise specifications, including pointer-stability properties.\nBecause it only changes how representation predicates and specifications are\nwritten, our approach is compatible with most separation logic variants. We\ndemonstrate the practicality of logical pinning by verifying small but\nrepresentative pointer-manipulating programs, and deriving more precise\nversions of common container specifications. In doing so, we show that our\napproach subsumes some well-known proof patterns, simplifies some complex\nproofs, and enables reasoning about program patterns not supported by\ntraditional specifications. All of our results are mechanized in the Rocq proof\nassistant, using the CFML library."}
{"id": "2509.25114", "pdf": "https://arxiv.org/pdf/2509.25114", "abs": "https://arxiv.org/abs/2509.25114", "authors": ["Erdenebayar Bayarmagnai", "Fatemeh Mohammadi", "Rémi Prébet"], "title": "From Affine to Polynomial: Synthesizing Loops with Branches via Algebraic Geometry", "categories": ["cs.PL", "cs.SC", "math.AG"], "comment": null, "summary": "Ensuring software correctness remains a fundamental challenge in formal\nprogram verification. One promising approach relies on finding polynomial\ninvariants for loops. Polynomial invariants are properties of a program loop\nthat hold before and after each iteration. Generating such invariants is a\ncrucial task in loop analysis, but it is undecidable in the general case.\nRecently, an alternative approach to this problem has emerged, focusing on\nsynthesizing loops from invariants. However, existing methods only synthesize\naffine loops without guard conditions from polynomial invariants. In this\npaper, we address a more general problem, allowing loops to have polynomial\nupdate maps with a given structure, inequations in the guard condition, and\npolynomial invariants of arbitrary form.\n  We use algebraic geometry tools to design and implement an algorithm that\ncomputes a finite set of polynomial equations whose solutions correspond to all\nnondeterministic branching loops satisfying the given invariants. Furthermore,\nwe introduce a new class of invariants for which we present a significantly\nmore efficient algorithm. In other words, we reduce the problem of synthesizing\nloops to find solutions of multivariate polynomial systems with rational\nentries. This final step is handled in our software using an SMT solver."}
{"id": "2509.22908", "pdf": "https://arxiv.org/pdf/2509.22908", "abs": "https://arxiv.org/abs/2509.22908", "authors": ["Sergiu Bursuc", "Theodore Ehrenborg", "Shaowei Lin", "Lacramioara Astefanoaei", "Ionel Emilian Chiosa", "Jure Kukovec", "Alok Singh", "Oliver Butterley", "Adem Bizid", "Quinn Dougherty", "Miranda Zhao", "Max Tan", "Max Tegmark"], "title": "A benchmark for vericoding: formally verified program synthesis", "categories": ["cs.SE", "cs.LG", "cs.PL"], "comment": "25 pages, 1 figure; data available at\n  https://github.com/Beneficial-AI-Foundation/vericoding-benchmark", "summary": "We present and test the largest benchmark for vericoding, LLM-generation of\nformally verified code from formal specifications - in contrast to vibe coding,\nwhich generates potentially buggy code from a natural language description. Our\nbenchmark contains 12,504 formal specifications, with 3,029 in Dafny, 2,334 in\nVerus/Rust and 7,141 in Lean. Of these, 6,174 are new unseen problems. We find\nvericoding success rates of 27% in Lean, 44% in Verus/Rust and 82% in Dafny\nusing off-the-shelf LLMs. Adding natural-language descriptions does not\nsignificantly improve performance. We also find that LLM progress has improved\nprogress on pure Dafny verification from 68% to 96% over the past year. The\nbenchmark and vericoding results are shared at\nhttps://github.com/Beneficial-AI-Foundation/vericoding-benchmark"}
{"id": "2509.23686", "pdf": "https://arxiv.org/pdf/2509.23686", "abs": "https://arxiv.org/abs/2509.23686", "authors": ["Yifeng He", "Luning Yang", "Christopher Castro Gaw Gonzalo", "Hao Chen"], "title": "TF-Bench: Evaluating Program Semantics Reasoning with Type Inference in System F", "categories": ["cs.CL", "cs.PL", "cs.SE"], "comment": "NeurIPS '25, package released at:\n  https://github.com/SecurityLab-UCD/TF-Bench", "summary": "Large Language Models (LLMs) are increasingly integrated into the software\nengineering ecosystem. Their test-time compute (TTC) reasoning capabilities\nshow significant potential for understanding program logic and semantics beyond\nmere token recognition. However, current benchmarks for code reasoning lack a\nformal, program-centric deductive framework to ensure sound evaluation, and are\nincapable of assessing whether models genuinely reason about program semantics\nor merely exploit superficial associations between natural language and code\ntokens. To bridge this gap, we introduce TF-Bench, a benchmark designed to\nevaluate LLM reasoning based on type inference in System F, a task we refer to\nas program semantics reasoning. By employing verified transformations to remove\nsemantically irrelevant natural language, we construct TF-Bench_pure, a purely\nsemantics-driven variant of TF-Bench. Our analysis reveals substantial\nlimitations in state-of-the-art LLMs, with the best-performing LLM\n(Claude-3.7-sonnet) achieving only 55.85% accuracy on TF-Bench_pure.\nAdditionally, we propose two novel metrics to assess robustness and the\neffectiveness of test-time reasoning, underscoring critical limitations in\ncurrent LLM capabilities and highlighting essential directions for future\nresearch."}
{"id": "2509.24515", "pdf": "https://arxiv.org/pdf/2509.24515", "abs": "https://arxiv.org/abs/2509.24515", "authors": ["Yu-Fu Fu", "Meng Xu", "Taesoo Kim"], "title": "Agentic Specification Generator for Move Programs", "categories": ["cs.SE", "cs.AI", "cs.CR", "cs.PL"], "comment": "18 pages; Extended version of ASE'25 paper with extra appendices", "summary": "While LLM-based specification generation is gaining traction, existing tools\nprimarily focus on mainstream programming languages like C, Java, and even\nSolidity, leaving emerging and yet verification-oriented languages like Move\nunderexplored. In this paper, we introduce MSG, an automated specification\ngeneration tool designed for Move smart contracts. MSG aims to highlight key\ninsights that uniquely present when applying LLM-based specification generation\nto a new ecosystem. Specifically, MSG demonstrates that LLMs exhibit robust\ncode comprehension and generation capabilities even for non-mainstream\nlanguages. MSG successfully generates verifiable specifications for 84% of\ntested Move functions and even identifies clauses previously overlooked by\nexperts. Additionally, MSG shows that explicitly leveraging specification\nlanguage features through an agentic, modular design improves specification\nquality substantially (generating 57% more verifiable clauses than conventional\ndesigns). Incorporating feedback from the verification toolchain further\nenhances the effectiveness of MSG, leading to a 30% increase in generated\nverifiable specifications."}
