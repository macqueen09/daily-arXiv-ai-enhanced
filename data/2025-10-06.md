<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Designing Walrus: Relational Programming with Rich Types, On-Demand Laziness, and Structured Traces](https://arxiv.org/abs/2510.02579)
*Santiago Cuéllar,Naomi Spargo,Jonathan Daugherty,David Darais*

Main category: cs.PL

TL;DR: Walrus是一个嵌入在Haskell中的函数式关系编程语言，扩展了miniKanren模型，具有类型多态统一、按需惰性和实用开发功能。


<details>
  <summary>Details</summary>
Motivation: 为实际开发提供更好的关系编程体验，解决双向编译器开发中遇到的可用性挑战。

Method: 在miniKanren基础上添加类型多态统一、按需惰性求值，利用Haskell泛型减少样板代码，提供结构化调试跟踪和产品类型支持。

Result: 成功实现了功能丰富的嵌入式关系编程语言，支持实际开发需求。

Conclusion: Walrus通过精心设计的功能集提升了关系编程的实用性，为复杂应用开发提供了有效工具。

Abstract: We present Walrus, a functional relational programming language embedded in
Haskell that extends the miniKanren model with type-polymorphic unification,
on-demand laziness, and a range of usability features aimed at practical
development. These include use of Haskell Generics for boilerplate reduction,
structured debugging traces, and ergonomic support for product types. We
describe the design and implementation of Walrus through the lens of our
experience developing bidirectional compilers, and reflect on key design
decisions and recurring usability challenges encountered in practice.

</details>


### [2] [Beyond Cons: Purely Relational Data Structures](https://arxiv.org/abs/2510.03170)
*Rafaello Sanna,William E. Byrd,Nada Amin*

Main category: cs.PL

TL;DR: Kanren是miniKanren的扩展，增加了集合和关联列表的约束推理功能，支持声明式描述集合操作，改善了解释器等抽象数据操作程序的表达能力。


<details>
  <summary>Details</summary>
Motivation: 为了解决在miniKanren中描述集合和关联列表时需要依赖结构编码和急切搜索的问题，提供更自然的集合操作支持。

Method: 扩展miniKanren系统，引入一等集合对象、完整的集合论约束家族（包括成员关系、并集、不相交性）以及支持遮蔽和作用域查找的关联列表新约束。

Result: 实现了基于内容的集合相等性，支持有限失败，提高了操作抽象数据（特别是解释器）的表达能力和运行行为。

Conclusion: Kanren通过引入集合和关联列表约束，显著提升了声明式编程在处理抽象数据时的表达力和操作效率。

Abstract: We present {Kanren} (read: set-Kanren), an extension to miniKanren with
constraints for reasoning about sets and association lists. {Kanren} includes
first-class set objects, a functionally complete family of set-theoretic
constraints (including membership, union, and disjointedness), and new
constraints for reasoning about association lists with shadowing and scoped
lookup. These additions allow programmers to describe collections declaratively
and lazily, without relying on structural encodings and eager search over
representation spaces. The result is improved expressiveness and operational
behavior in programs that manipulate abstract data -- particularly interpreters
-- by supporting set equality based on contents, enabling finite failure. We
describe the design and implementation of {Kanren} in a constraint-enabled
miniKanren system and illustrate its use in representative examples.

</details>
