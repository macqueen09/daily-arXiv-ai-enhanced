{"id": "2510.03415", "pdf": "https://arxiv.org/pdf/2510.03415", "abs": "https://arxiv.org/abs/2510.03415", "authors": ["Aditya Thimmaiah", "Jiyang Zhang", "Jayanth Srinivasa", "Junyi Jessy Li", "Milos Gligoric"], "title": "PLSEMANTICSBENCH: Large Language Models As Programming Language Interpreters", "categories": ["cs.PL", "cs.AI", "cs.CL", "cs.SE"], "comment": null, "summary": "As large language models (LLMs) excel at code reasoning, a natural question\narises: can an LLM execute programs (i.e., act as an interpreter) purely based\non a programming language's formal semantics? If so, it will enable rapid\nprototyping of new programming languages and language features. We study this\nquestion using the imperative language IMP (a subset of C), formalized via\nsmall-step operational semantics (SOS) and rewriting-based operational\nsemantics (K-semantics). We introduce three evaluation sets-Human-Written,\nLLM-Translated, and Fuzzer- Generated-whose difficulty is controlled by\ncode-complexity metrics spanning the size, control-flow, and data-flow axes.\nGiven a program and its semantics formalized with SOS/K-semantics, models are\nevaluated on three tasks ranging from coarse to fine: (1) final-state\nprediction, (2) semantic rule prediction, and (3) execution trace prediction.\nTo distinguish pretraining memorization from semantic competence, we define two\nnonstandard semantics obtained through systematic mutations of the standard\nrules. Across strong code/reasoning LLMs, performance drops under nonstandard\nsemantics despite high performance under the standard one. We further find that\n(i) there are patterns to different model failures, (ii) most reasoning models\nperform exceptionally well on coarse grained tasks involving reasoning about\nhighly complex programs often containing nested loop depths beyond five, and\nsurprisingly, (iii) providing formal semantics helps on simple programs but\noften hurts on more complex ones. Overall, the results show a promise that LLMs\ncould serve as programming language interpreters, but points to the lack of\ntheir robust semantics understanding. We release the benchmark and the\nsupporting code at https://github.com/EngineeringSoftware/PLSemanticsBench."}
{"id": "2510.04049", "pdf": "https://arxiv.org/pdf/2510.04049", "abs": "https://arxiv.org/abs/2510.04049", "authors": ["Xiangyu Guo", "Ajay Bansal"], "title": "Encoding Numeric Computations and Infusing Heuristic Knowledge Using Integrity Constraints in stableKanren", "categories": ["cs.PL", "03B70, 68T27, 68T30"], "comment": "12 pages, 2 figures, ICFP '25 The miniKanren and Relational\n  Programming Workshop", "summary": "This paper presents examples of using integrity constraints in stableKanren\nto encode numeric computations for problem solving. Then, we use one of the\nexamples to introduce multiple ways to infuse heuristic knowledge and reduce\nsolving time. stableKanren is an extension of miniKanren that supports normal\nlogic programs under stable model semantics. stableKanren further supports\nnumeric computation by constructing a constraint store for integrity\nconstraints. There are three ways to extend a relational programming language\nwith numeric computations: relational number representation, grounding numbers\nto symbols, and constraint store construction. We demonstrate that the numeric\ncomputations in stableKanren have a straightforward numerical representation\ncompared to relational number representations. More importantly, stableKanren\nbalances symbolic and numeric computation in relational programming by avoiding\nthe grounding of all numbers to symbols. Lastly, it also has simpler syntax\ncompared to other constraint store construction approaches. stableKanren\nsupports combinatorial search problem solving under a declarative generate and\ntest paradigm. Such a paradigm generates all possible combinations of solutions\nto the problem, then applies a set of constraints to prune out the unwanted\nsolutions. We demonstrate that different approaches to writing programs or\nqueries affect the solver's performance in the SEND+MORE=MONEY puzzle. The\nperformance gradually improves as more heuristic knowledge is infused through\nthe programs or queries. Additionally, we show how to use an external function\nto achieve a hybrid solution."}
{"id": "2510.04890", "pdf": "https://arxiv.org/pdf/2510.04890", "abs": "https://arxiv.org/abs/2510.04890", "authors": ["Shihan Fang", "Wenxin Zheng"], "title": "Retrofitting Control Flow Graphs in LLVM IR for Auto Vectorization", "categories": ["cs.PL", "cs.AR", "cs.SE"], "comment": null, "summary": "Modern processors increasingly rely on SIMD instruction sets, such as AVX and\nRVV, to significantly enhance parallelism and computational performance.\nHowever, production-ready compilers like LLVM and GCC often fail to fully\nexploit available vectorization opportunities due to disjoint vectorization\npasses and limited extensibility. Although recent attempts in heuristics and\nintermediate representation (IR) designs have attempted to address these\nproblems, efficiently simplifying control flow analysis and accurately\nidentifying vectorization opportunities remain challenging tasks.\n  To address these issues, we introduce a novel vectorization pipeline\nfeaturing two specialized IR extensions: SIR, which encodes high-level\nstructural information, and VIR, which explicitly represents instruction\ndependencies through data dependency analysis. Leveraging the detailed\ndependency information provided by VIR, we develop a flexible and extensible\nvectorization framework. This approach substantially improves interoperability\nacross vectorization passes and expands the search space for identifying\nisomorphic instructions, ultimately enhancing both the scope and efficiency of\nautomatic vectorization. Experimental evaluations demonstrate that our proposed\nvectorization pipeline achieves significant performance improvements,\ndelivering speedups of up to 53% and 58% compared to LLVM and GCC,\nrespectively."}
{"id": "2510.04994", "pdf": "https://arxiv.org/pdf/2510.04994", "abs": "https://arxiv.org/abs/2510.04994", "authors": ["Sjoerd Dost"], "title": "concurrentKanren: miniKanren for parallel execution", "categories": ["cs.PL"], "comment": "13 pages, 1 figure, for associated repo see\n  https://github.com/deosjr/concurrentKanren", "summary": "Concurrent logic programming predates miniKanren, but concurrent\nimplementations of miniKanren have remained largely unexplored. In this work we\npresent a parallel implementation of miniKanren in Go, demonstrating its\nfeasibility and potential for performance improvements. Our approach leverages\nimplicit parallelism allowing legacy programs to benefit from parallel\nexecution. We discuss implementation strategies and evaluate the impact of\nparallelism, laying groundwork for future language-agnostic models."}
{"id": "2510.03789", "pdf": "https://arxiv.org/pdf/2510.03789", "abs": "https://arxiv.org/abs/2510.03789", "authors": ["Eridan Domoratskiy", "Dmitrii Kosarev", "Dmitry Boulytchev"], "title": "An Empirical Study of Rational Tree Unification for miniKanren", "categories": ["cs.LO", "cs.PL"], "comment": null, "summary": "We present a study of unification for rational trees in the context of\nminiKanren. We give the definition of rational trees, specify the unification\nalgorithm and prove some of its properties. We also introduce a number of\nheuristic optimizations and evaluate them for a number of relevant benchmarks.\nFinally we discuss the relations between rational and conventional unification\nalgorithms and possible scenarios of their coexistence in the context of\nrelational programming."}
{"id": "2510.04081", "pdf": "https://arxiv.org/pdf/2510.04081", "abs": "https://arxiv.org/abs/2510.04081", "authors": ["Honglin Lin", "Qizhi Pei", "Xin Gao", "Zhuoshi Pan", "Yu Li", "Juntao Li", "Conghui He", "Lijun Wu"], "title": "Scaling Code-Assisted Chain-of-Thoughts and Instructions for Model Reasoning", "categories": ["cs.CL", "cs.PL"], "comment": "Accepted by NeurIPS2025", "summary": "Reasoning capability is pivotal for Large Language Models (LLMs) to solve\ncomplex tasks, yet achieving reliable and scalable reasoning remains\nchallenging. While Chain-of-Thought (CoT) prompting has become a mainstream\napproach, existing methods often suffer from uncontrolled generation,\ninsufficient quality, and limited diversity in reasoning paths. Recent efforts\nleverage code to enhance CoT by grounding reasoning in executable steps, but\nsuch methods are typically constrained to predefined mathematical problems,\nhindering scalability and generalizability. In this work, we propose Caco\n(Code-Assisted Chain-of-ThOught), a novel framework that automates the\nsynthesis of high-quality, verifiable, and diverse instruction-CoT reasoning\ndata through code-driven augmentation. Unlike prior work, Caco first fine-tunes\na code-based CoT generator on existing math and programming solutions in a\nunified code format, then scales the data generation to a large amount of\ndiverse reasoning traces. Crucially, we introduce automated validation via code\nexecution and rule-based filtering to ensure logical correctness and structural\ndiversity, followed by reverse-engineering filtered outputs into natural\nlanguage instructions and language CoTs to enrich task adaptability. This\nclosed-loop process enables fully automated, scalable synthesis of reasoning\ndata with guaranteed executability. Experiments on our created Caco-1.3M\ndataset demonstrate that Caco-trained models achieve strong competitive\nperformance on mathematical reasoning benchmarks, outperforming existing strong\nbaselines. Further analysis reveals that Caco's code-anchored verification and\ninstruction diversity contribute to superior generalization across unseen\ntasks. Our work establishes a paradigm for building self-sustaining,\ntrustworthy reasoning systems without human intervention."}
