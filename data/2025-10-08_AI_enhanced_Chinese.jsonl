{"id": "2510.05115", "pdf": "https://arxiv.org/pdf/2510.05115", "abs": "https://arxiv.org/abs/2510.05115", "authors": ["Yansen Zhang", "Qingcan Kang", "Yujie Chen", "Yufei Wang", "Xiongwei Han", "Tao Zhong", "Mingxuan Yuan", "Chen Ma"], "title": "Optimization Modeling via Semantic Anchored Alignment", "categories": ["cs.AI", "cs.CL", "cs.PL"], "comment": null, "summary": "Large language models (LLMs) have opened new paradigms in optimization\nmodeling by enabling the generation of executable solver code from natural\nlanguage descriptions. Despite this promise, existing approaches typically\nremain solver-driven: they rely on single-pass forward generation and apply\nlimited post-hoc fixes based on solver error messages, leaving undetected\nsemantic errors that silently produce syntactically correct but logically\nflawed models. To address this challenge, we propose SAC-Opt, a backward-guided\ncorrection framework that grounds optimization modeling in problem semantics\nrather than solver feedback. At each step, SAC-Opt aligns the original semantic\nanchors with those reconstructed from the generated code and selectively\ncorrects only the mismatched components, driving convergence toward a\nsemantically faithful model. This anchor-driven correction enables fine-grained\nrefinement of constraint and objective logic, enhancing both fidelity and\nrobustness without requiring additional training or supervision. Empirical\nresults on seven public datasets demonstrate that SAC-Opt improves average\nmodeling accuracy by 7.8\\%, with gains of up to 21.9\\% on the ComplexLP\ndataset. These findings highlight the importance of semantic-anchored\ncorrection in LLM-based optimization workflows to ensure faithful translation\nfrom problem intent to solver-executable code.", "AI": {"tldr": "SAC-Opt\u662f\u4e00\u4e2a\u57fa\u4e8e\u8bed\u4e49\u951a\u70b9\u7684\u540e\u5411\u5f15\u5bfc\u4fee\u6b63\u6846\u67b6\uff0c\u901a\u8fc7\u5c06\u539f\u59cb\u8bed\u4e49\u951a\u70b9\u4e0e\u751f\u6210\u4ee3\u7801\u91cd\u6784\u7684\u951a\u70b9\u5bf9\u9f50\uff0c\u9009\u62e9\u6027\u4fee\u6b63\u4e0d\u5339\u914d\u7ec4\u4ef6\uff0c\u63d0\u9ad8LLM\u751f\u6210\u4f18\u5316\u6a21\u578b\u7684\u51c6\u786e\u6027\u548c\u9c81\u68d2\u6027\u3002", "motivation": "\u73b0\u6709LLM\u4f18\u5316\u5efa\u6a21\u65b9\u6cd5\u4e3b\u8981\u4f9d\u8d56\u6c42\u89e3\u5668\u9a71\u52a8\uff0c\u91c7\u7528\u5355\u6b21\u524d\u5411\u751f\u6210\u548c\u6709\u9650\u7684\u540e\u5904\u7406\u4fee\u590d\uff0c\u5b58\u5728\u672a\u68c0\u6d4b\u7684\u8bed\u4e49\u9519\u8bef\uff0c\u5bfc\u81f4\u751f\u6210\u8bed\u6cd5\u6b63\u786e\u4f46\u903b\u8f91\u6709\u7f3a\u9677\u7684\u6a21\u578b\u3002", "method": "\u63d0\u51faSAC-Opt\u6846\u67b6\uff0c\u57fa\u4e8e\u8bed\u4e49\u951a\u70b9\u8fdb\u884c\u540e\u5411\u5f15\u5bfc\u4fee\u6b63\uff0c\u5728\u6bcf\u4e2a\u6b65\u9aa4\u4e2d\u5c06\u539f\u59cb\u8bed\u4e49\u951a\u70b9\u4e0e\u4ee3\u7801\u91cd\u6784\u7684\u951a\u70b9\u5bf9\u9f50\uff0c\u9009\u62e9\u6027\u4fee\u6b63\u4e0d\u5339\u914d\u7684\u7ec4\u4ef6\uff0c\u5b9e\u73b0\u7ea6\u675f\u548c\u76ee\u6807\u903b\u8f91\u7684\u7ec6\u7c92\u5ea6\u4f18\u5316\u3002", "result": "\u57287\u4e2a\u516c\u5171\u6570\u636e\u96c6\u4e0a\u7684\u5b9e\u9a8c\u8868\u660e\uff0cSAC-Opt\u5c06\u5e73\u5747\u5efa\u6a21\u51c6\u786e\u7387\u63d0\u9ad8\u4e867.8%\uff0c\u5728ComplexLP\u6570\u636e\u96c6\u4e0a\u6700\u9ad8\u63d0\u534721.9%\u3002", "conclusion": "\u8bed\u4e49\u951a\u70b9\u4fee\u6b63\u5bf9\u4e8eLLM\u9a71\u52a8\u7684\u4f18\u5316\u5de5\u4f5c\u6d41\u81f3\u5173\u91cd\u8981\uff0c\u80fd\u591f\u786e\u4fdd\u4ece\u95ee\u9898\u610f\u56fe\u5230\u6c42\u89e3\u5668\u53ef\u6267\u884c\u4ee3\u7801\u7684\u5fe0\u5b9e\u8f6c\u6362\u3002"}}
{"id": "2510.05376", "pdf": "https://arxiv.org/pdf/2510.05376", "abs": "https://arxiv.org/abs/2510.05376", "authors": ["Yahya Hassanzadeh-Nazarabadi", "Sanaz Taheri-Boshrooyeh"], "title": "Constraint-Level Design of zkEVMs: Architectures, Trade-offs, and Evolution", "categories": ["cs.CR", "cs.PL"], "comment": null, "summary": "Zero-knowledge Ethereum Virtual Machines (zkEVMs) must reconcile a\nfundamental contradiction: the Ethereum Virtual Machine was designed for\ntransparent sequential execution, while zero-knowledge proofs require algebraic\ncircuit representations. This survey provides the first systematic analysis of\nhow existing major production zkEVM implementations resolve this tension\nthrough distinct constraint engineering strategies. We develop a comparative\nframework that maps the design space across three architectural dimensions.\nFirst, arithmetization schemes reveal stark trade-offs: R1CS requires\ncompositional gadget libraries, PLONKish achieves elegance through custom gates\nthat capture complex EVM opcodes in single constraints, while the homogeneous\nstructure of AIR fundamentally mismatches the irregular instruction set of EVM.\nSecond, dispatch mechanisms determine constraint activation patterns:\nselector-based systems waste trace width on inactive constraints, while\nROM-based approaches trade memory lookups for execution flexibility. Third, the\nType 1-4 spectrum quantifies an inescapable trade-off: the bit-level EVM\ncompatibility of Type 1 demands significantly higher constraint complexity than\nthe custom instruction sets of Type 4. Beyond cataloging implementations, we\nidentify critical open problems across multiple domains: performance barriers\npreventing sub-second proving, absence of formal verification for\nconstraint-to-EVM semantic equivalence, lack of standardized benchmarking\nframeworks, and architectural gaps in hybrid zkEVM/zkVM designs, decentralized\nprover coordination, privacy preservation, and interoperability.", "AI": {"tldr": "\u672c\u6587\u7cfb\u7edf\u5206\u6790\u4e86zkEVM\u5b9e\u73b0\u4e2d\u7684\u6838\u5fc3\u77db\u76fe\uff1aEVM\u7684\u900f\u660e\u987a\u5e8f\u6267\u884c\u4e0e\u96f6\u77e5\u8bc6\u8bc1\u660e\u7684\u4ee3\u6570\u7535\u8def\u8868\u793a\u4e4b\u95f4\u7684\u51b2\u7a81\uff0c\u6bd4\u8f83\u4e86\u4e0d\u540c\u67b6\u6784\u5728\u7b97\u672f\u5316\u65b9\u6848\u3001\u8c03\u5ea6\u673a\u5236\u548c\u7c7b\u578b\u8c31\u7cfb\u4e09\u4e2a\u7ef4\u5ea6\u7684\u8bbe\u8ba1\u9009\u62e9\u3002", "motivation": "\u89e3\u51b3EVM\u4e0e\u96f6\u77e5\u8bc6\u8bc1\u660e\u4e4b\u95f4\u7684\u6839\u672c\u77db\u76fe\uff0c\u4e3a\u73b0\u6709\u4e3b\u8981zkEVM\u5b9e\u73b0\u63d0\u4f9b\u7cfb\u7edf\u6027\u7684\u6bd4\u8f83\u6846\u67b6\uff0c\u8bc6\u522b\u8bbe\u8ba1\u7a7a\u95f4\u4e2d\u7684\u5173\u952e\u6743\u8861\u3002", "method": "\u5f00\u53d1\u6bd4\u8f83\u6846\u67b6\uff0c\u4ece\u4e09\u4e2a\u67b6\u6784\u7ef4\u5ea6\u5206\u6790\uff1a\u7b97\u672f\u5316\u65b9\u6848\uff08R1CS\u3001PLONKish\u3001AIR\uff09\u3001\u8c03\u5ea6\u673a\u5236\uff08\u9009\u62e9\u5668vs ROM\uff09\u548c\u7c7b\u578b\u8c31\u7cfb\uff08Type 1-4\uff09\u3002", "result": "\u63ed\u793a\u4e86\u4e0d\u540c\u8bbe\u8ba1\u9009\u62e9\u4e4b\u95f4\u7684\u4e25\u683c\u6743\u8861\uff1aPLONKish\u901a\u8fc7\u81ea\u5b9a\u4e49\u95e8\u4f18\u96c5\u5904\u7406\u590d\u6742EVM\u64cd\u4f5c\u7801\uff0c\u4f46AIR\u7ed3\u6784\u4e0eEVM\u4e0d\u89c4\u5219\u6307\u4ee4\u96c6\u4e0d\u5339\u914d\uff1bType 1\u63d0\u4f9b\u6bd4\u7279\u7ea7\u517c\u5bb9\u6027\u4f46\u7ea6\u675f\u590d\u6742\u5ea6\u663e\u8457\u9ad8\u4e8eType 4\u3002", "conclusion": "\u8bc6\u522b\u4e86\u591a\u4e2a\u5173\u952e\u5f00\u653e\u95ee\u9898\uff1a\u6027\u80fd\u969c\u788d\u3001\u5f62\u5f0f\u9a8c\u8bc1\u7f3a\u5931\u3001\u6807\u51c6\u5316\u57fa\u51c6\u6846\u67b6\u4e0d\u8db3\uff0c\u4ee5\u53ca\u5728\u6df7\u5408\u8bbe\u8ba1\u3001\u53bb\u4e2d\u5fc3\u5316\u8bc1\u660e\u8005\u534f\u8c03\u3001\u9690\u79c1\u4fdd\u62a4\u548c\u4e92\u64cd\u4f5c\u6027\u65b9\u9762\u7684\u67b6\u6784\u7a7a\u767d\u3002"}}
