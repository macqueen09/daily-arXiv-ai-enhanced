<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.DB](#cs.DB) [Total: 1]
- [cs.CR](#cs.CR) [Total: 1]
- [cs.LO](#cs.LO) [Total: 1]
- [quant-ph](#quant-ph) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [VeriEquivBench: An Equivalence Score for Ground-Truth-Free Evaluation of Formally Verifiable Code](https://arxiv.org/abs/2510.06296)
*Lingfei Zeng,Fengdi Che,Xuhan Huang,Fei Ye,Xu Xu,Binhang Yuan,Jie Fu*

Main category: cs.PL

TL;DR: VeriEquivBench是一个包含2389个复杂算法问题的新基准，用于评估LLM生成可验证代码的能力，采用形式化等价评分替代传统真值匹配。


<details>
  <summary>Details</summary>
Motivation: 当前基于形式化语言的方法在验证LLM生成代码正确性时，受限于规范质量评估的瓶颈，现有数据集规模小且依赖人工专家标注，存在可靠性问题。

Method: 引入VeriEquivBench基准，包含2389个复杂算法问题，采用形式化等价评分作为评估指标，严格验证生成的规范和代码质量。

Result: 实验结果表明，为最先进的LLM生成形式化可验证代码仍然是一个巨大挑战。

Conclusion: 该任务难度很大，需要像VeriEquivBench这样的基准来推动可扩展和可靠编码代理的发展。

Abstract: Formal verification is the next frontier for ensuring the correctness of code
generated by Large Language Models (LLMs). While methods that co-generate code
and formal specifications in formal languages, like Dafny, can, in principle,
prove alignment with user intent, progress is bottlenecked by specification
quality evaluation. Current benchmarks rely on matching against ground-truth
specifications, a manual and expertise-intensive process that has limited
existing datasets to a few hundred simple problems and also suffers from a
reliability issue. To address this, we introduce VeriEquivBench, a new
benchmark with $2,389$ complex algorithmic problems that probe the limitations
of current models in both code generation and formal reasoning. Our evaluation
framework replaces ground-truth matching with a formally grounded metric, the
equivalence score, and rigorously verifies the quality of generated
specifications and code. Our results show that generating formally verifiable
code remains a profound challenge for state-of-the-art LLMs. This underscores
both the difficulty of the task and the need for benchmarks like VeriEquivBench
to drive progress toward scalable and reliable coding agents.

</details>


<div id='cs.DB'></div>

# cs.DB [[Back]](#toc)

### [2] [Automated Discovery of Test Oracles for Database Management Systems Using LLMs](https://arxiv.org/abs/2510.06663)
*Qiuyang Mang,Runyuan He,Suyang Zhong,Xiaoxuan Liu,Huanchen Zhang,Alvin Cheung*

Main category: cs.DB

TL;DR: 本文提出了Argus框架，利用大语言模型自动发现和实例化数据库管理系统的测试预言，通过约束抽象查询和形式化验证来确保正确性，在5个DBMS中发现了40个未知bug。


<details>
  <summary>Details</summary>
Motivation: 解决DBMS测试中测试预言设计需要人工参与的问题，实现完全自动化的DBMS测试，同时克服LLM的幻觉问题和高成本限制。

Method: 使用约束抽象查询（包含占位符和实例化条件的SQL骨架），通过LLM生成语义等价的骨架对，用SQL等价求解器形式化验证，最后用LLM合成具体SQL片段实例化生成复杂测试用例。

Result: 在5个广泛测试的DBMS中发现了40个未知bug（35个逻辑bug），其中36个已确认，26个已被开发者修复。

Conclusion: Argus框架成功实现了自动化测试预言发现和实例化，显著提升了DBMS测试的自动化程度和效率，证明了LLM在软件测试中的实用价值。

Abstract: Since 2020, automated testing for Database Management Systems (DBMSs) has
flourished, uncovering hundreds of bugs in widely-used systems. A cornerstone
of these techniques is test oracle, which typically implements a mechanism to
generate equivalent query pairs, thereby identifying bugs by checking the
consistency between their results. However, while applying these oracles can be
automated, their design remains a fundamentally manual endeavor. This paper
explores the use of large language models (LLMs) to automate the discovery and
instantiation of test oracles, addressing a long-standing bottleneck towards
fully automated DBMS testing. Although LLMs demonstrate impressive creativity,
they are prone to hallucinations that can produce numerous false positive bug
reports. Furthermore, their significant monetary cost and latency mean that LLM
invocations should be limited to ensure that bug detection is efficient and
economical.
  To this end, we introduce Argus, a novel framework built upon the core
concept of the Constrained Abstract Query - a SQL skeleton containing
placeholders and their associated instantiation conditions (e.g., requiring a
placeholder to be filled by a boolean column). Argus uses LLMs to generate
pairs of these skeletons that are asserted to be semantically equivalent. This
equivalence is then formally proven using a SQL equivalence solver to ensure
soundness. Finally, the placeholders within the verified skeletons are
instantiated with concrete, reusable SQL snippets that are also synthesized by
LLMs to efficiently produce complex test cases. We implemented Argus and
evaluated it on five extensively tested DBMSs, discovering 40 previously
unknown bugs, 35 of which are logic bugs, with 36 confirmed and 26 already
fixed by the developers.

</details>


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [3] [Automated Repeatable Adversary Threat Emulation with Effects Language (EL)](https://arxiv.org/abs/2510.06420)
*Suresh K. Damodaran,Paul D. Rowe*

Main category: cs.CR

TL;DR: 本文介绍了使用效果语言(EL)来自动化模拟多步网络攻击的方法，以解决训练防御者和评估防御工具的需求。


<details>
  <summary>Details</summary>
Motivation: 模拟高级持续性威胁的多步攻击对于训练防御者和评估防御工具很有价值，但面临诸多挑战，需要自动化解决方案。

Method: 引入效果语言(EL)，这是一种具有基于图的操作语义的可视化编程语言，用于编码攻击场景并实现可重复的自动化。

Result: 展示了EL在编码公开攻击场景中的应用，证明了其在复杂多步攻击中提供攻击证明的能力，并在时间和资源效率方面取得了显著改进。

Conclusion: EL能够有效解决多步攻击自动化面临的挑战，提供可重复的自动化，显著提高训练和评估的效率。

Abstract: The emulation of multi-step attacks attributed to advanced persistent threats
is valuable for training defenders and evaluating defense tools. In this paper,
we discuss the numerous challenges and desired attributes associated with such
automation. Additionally, we introduce the use of Effects Language (EL), a
visual programming language with graph-based operational semantics, as a
solution to address many of these challenges and requirements. We formally
define the execution semantics of EL, and prove important execution properties.
Furthermore, we showcase the application of EL to codify attacks using an
example from one of the publicly available attack scenarios. We also
demonstrate how EL can be utilized to provide proof-of-attack of complex
multi-step attacks. Our results highlight the improvements in time and resource
efficiency achieved through the use of EL for repeatable automation.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [4] [Strong Dinatural Transformations and Generalised Codensity Monads](https://arxiv.org/abs/2510.06777)
*Maciej Piróg,Filip Sieczkowski*

Main category: cs.LO

TL;DR: 本文介绍了dicodensity monads，这是对点态codensity monads的推广，通过混合变分双函子生成monads。该构造基于强双自然性概念，受多态lambda演算中某些类型的指称模型启发。


<details>
  <summary>Details</summary>
Motivation: 受多态lambda演算中具有全称量化变量的continuation monads（如System F中的列表monad的Church编码）的指称模型启发，推广codensity monads构造。

Method: 基于强双自然性（Barr双自然性）概念，通过混合变分双函子构造dicodensity monads。重点关注使用hom-函子和同态对象双函子实例化构造的monads类。

Result: 提供了建立monad与给定双函子的dicodensity monad之间同构的充分条件。获得了由不同类型半环和其他理论生成的monads的新表示，用于建模有序非确定性计算。

Conclusion: dicodensity monads为codensity monads提供了有用的推广，能够生成各种用于建模有序非确定性计算的monads的新表示。

Abstract: We introduce dicodensity monads: a generalisation of pointwise codensity
monads generated by functors to monads generated by mixed-variant bifunctors.
Our construction is based on the notion of strong dinaturality (also known as
Barr dinaturality), and is inspired by denotational models of certain types in
polymorphic lambda calculi - in particular, a form of continuation monads with
universally quantified variables, such as the Church encoding of the list monad
in System F. Extending some previous results on Cayley-style representations,
we provide a set of sufficient conditions to establish an isomorphism between a
monad and the dicodensity monad for a given bifunctor. Then, we focus on the
class of monads obtained by instantiating our construction with hom-functors
and, more generally, bifunctors given by objects of homomorphisms (that is,
internalised hom-sets between Eilenberg--Moore algebras). This gives us, for
example, novel presentations of monads generated by different kinds of
semirings and other theories used to model ordered nondeterministic
computations.

</details>


<div id='quant-ph'></div>

# quant-ph [[Back]](#toc)

### [5] [A Duality Theorem for Classical-Quantum States with Applications to Complete Relational Program Logics](https://arxiv.org/abs/2510.07051)
*Gilles Barthe,Minbo Gao,Jam Kabeer Ali Khan,Matthijs Muis,Ivan Renison,Keiya Sakabe,Michael Walter,Yingte Xu,Li Zhou*

Main category: quant-ph

TL;DR: 本文建立了经典-量子状态的对偶定理，并基于此构建了完整的经典-量子程序关系逻辑cqOTL，同时提升了现有概率程序逻辑eRHL和量子程序逻辑qOTL的完备性。


<details>
  <summary>Details</summary>
Motivation: 经典-量子程序结合了经典和量子计算，操作经典和量子变量，但此前缺乏完备的关系逻辑。主要障碍是经典-量子设置超出了最优传输和半定规划方法的范围，需要新的理论方法。

Method: 通过新颖的维度无关分析，研究有限维量子设置下的凸优化问题，特别是允许经典状态空间变为无限的情况，从而建立经典-量子状态的对偶定理。

Result: 成功建立了经典-量子状态的对偶定理，并基于此开发了新的关系程序逻辑cqOTL，证明了其可靠性和完备性。

Conclusion: 本文填补了经典-量子程序验证的理论空白，为混合经典-量子系统的形式化验证提供了理论基础，同时提升了现有程序逻辑的完备性。

Abstract: Duality theorems play a fundamental role in convex optimization. Recently, it
was shown how duality theorems for countable probability distributions and
finite-dimensional quantum states can be leveraged for building relatively
complete relational program logics for probabilistic and quantum programs,
respectively. However, complete relational logics for classical-quantum
programs, which combine classical and quantum computations and operate over
classical as well as quantum variables, have remained out of reach. The main
gap is that while prior duality theorems could readily be derived using optimal
transport and semidefinite programming methods, respectively, the combined
setting falls out of the scope of these methods and requires new ideas. In this
paper, we overcome this gap and establish the desired duality theorem for
classical-quantum states. Our argument relies critically on a novel
dimension-independent analysis of the convex optimization problem underlying
the finite-dimensional quantum setting, which, in particular, allows us to take
the limit where the classical state space becomes infinite. Using the resulting
duality theorem, we establish soundness and completeness of a new relational
program logic, called $\mathsf{cqOTL}$, for classical-quantum programs. In
addition, we lift prior restrictions on the completeness of two existing
program logics: $\mathsf{eRHL}$ for probabilistic programs (Avanzini et al.,
POPL 2025) and $\mathsf{qOTL}$ for quantum programs (Barthe et al., LICS 2025).

</details>
