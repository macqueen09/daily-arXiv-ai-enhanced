<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Type, Ability, and Effect Systems: Perspectives on Purity, Semantics, and Expressiveness](https://arxiv.org/abs/2510.07582)
*Yuyan Bao,Tiark Rompf*

Main category: cs.PL

TL;DR: 该论文提出了基于上下文等价性的语义纯度定义，比较了不同类型系统的表达能力，发现最小化效应系统和能力系统在表达能力上不可比较，并提出将类型、能力和效应系统结合的综合方案。


<details>
  <summary>Details</summary>
Motivation: 现有方法（单子、类型效应系统、能力系统）在强制分离纯计算和效应交互时存在精度与可用性之间的张力，各有优缺点，需要更好的评估标准。

Method: 提出基于上下文等价性的语义纯度定义；使用完整性程度衡量表达能力；分析最小化效应系统和能力系统的表达能力；提出类型、能力和效应系统的综合方案；提供逻辑关系来证明纯度和其他属性。

Result: 发现最小化效应系统和能力系统在表达能力上是不可比较的，即没有一种系统能在表达能力上完全包含另一种；提出的综合方案能结合各系统的优点并避免其弱点。

Conclusion: 通过语义纯度定义和表达能力测量，证明了不同类型系统的互补性，提出的综合方案为效应类型系统提供了更好的理论基础和证明工具。

Abstract: Programming benefits from a clear separation between pure, mathematical
computation and impure, effectful interaction with the world. Existing
approaches to enforce this separation include monads, type-and-effect systems,
and capability systems. All share a tension between precision and usability,
and each one has non-obvious strengths and weaknesses.
  This paper aims to raise the bar in assessing such systems. First, we propose
a semantic definition of purity, inspired by contextual equivalence, as a
baseline independent of any specific typing discipline. Second, we propose that
expressiveness should be measured by the degree of completeness, i.e., how many
semantically pure terms can be typed as pure. Using this measure, we focus on
minimal meaningful effect and capability systems and show that they are
incomparable, i.e., neither subsumes the other in terms of expressiveness.
  Based on this result, we propose a synthesis and show that type, ability, and
effect systems combine their respective strengths while avoiding their
weaknesses. As part of our formal model, we provide a logical relation to
facilitate proofs of purity and other properties for a variety of effect typing
disciplines.

</details>


### [2] [The Functional Machine Calculus III: Control](https://arxiv.org/abs/2510.07851)
*Willem Heijltjes*

Main category: cs.PL

TL;DR: Functional Machine Calculus从顺序计算扩展到分支和循环控制流，能够忠实嵌入包含条件、异常处理、迭代等的最小但完整的命令式语言，同时保持汇合归约和类型化终止的关键特性。


<details>
  <summary>Details</summary>
Motivation: 统一函数式和命令式编程范式，将lambda演算扩展到支持计算效果、求值策略和控制流操作，同时保持汇合归约和类型化终止的关键特性。

Method: 通过扩展简化的Krivine机器，添加多个操作数栈来建模效果，以及一个延续栈来建模顺序、分支和循环计算，定义了简单的操作语义。

Result: 该演算具有汇合归约关系和简单类型系统，保证机器终止和强规范化（在无迭代情况下），这些特性延续到嵌入的命令式语言中。

Conclusion: 提供了一个统一的功能-命令式计算模型，支持简单类型、直接直观的操作语义和汇合归约语义。

Abstract: The Functional Machine Calculus (Heijltjes 2022) is a new approach to
unifying the imperative and functional programming paradigms. It extends the
lambda-calculus, preserving the key features of confluent reduction and typed
termination, to embed computational effects, evaluation strategies, and control
flow operations. The first instalment modelled sequential higher-order
computation with global store, input/output, probabilities, and
non-determinism, and embedded both the call-by-name and call-by-value
lambda-calculus, as well as Moggi's computational metalanguage and Levy's
call-by-push-value. The present paper extends the calculus from sequential to
branching and looping control flow. This allows the faithful embedding of a
minimal but complete imperative language, including conditionals, exception
handling, and iteration, as well as constants and algebraic data types.
  The calculus is defined through a simple operational semantics, extending the
(simplified) Krivine machine for the lambda-calculus with multiple operand
stacks to model effects and a continuation stack to model sequential,
branching, and looping computation. It features a confluent reduction relation
and a system of simple types that guarantees termination of the machine and
strong normalization of reduction (in the absence of iteration). These
properties carry over to the embedded imperative language, providing a unified
functional-imperative model of computation that supports simple types, a direct
and intuitive operational semantics, and a confluent reduction semantics.

</details>
