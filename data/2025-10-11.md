<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Type, Ability, and Effect Systems: Perspectives on Purity, Semantics, and Expressiveness](https://arxiv.org/abs/2510.07582)
*Yuyan Bao,Tiark Rompf*

Main category: cs.PL

TL;DR: 本文提出了基于上下文等价的纯度语义定义，比较了不同类型系统的表达能力，发现最小化效果系统和能力系统在表达能力上不可比较，并提出了一种结合类型、能力和效果系统的综合方法。


<details>
  <summary>Details</summary>
Motivation: 现有方法（如单子、类型效果系统和能力系统）在强制纯计算和副作用交互分离时存在精度与可用性之间的张力，各有优缺点。本文旨在提升评估此类系统的标准。

Method: 1. 提出基于上下文等价的纯度语义定义；2. 用完整性程度衡量表达能力；3. 分析最小化效果系统和能力系统的表达能力；4. 提出类型、能力和效果系统的综合方法；5. 提供逻辑关系来促进纯度证明。

Result: 发现最小化效果系统和能力系统在表达能力上是不可比较的，即没有任何一个系统在表达能力上完全包含另一个系统。

Conclusion: 类型、能力和效果系统的综合方法能够结合各自优势并避免弱点，为各种效果类型系统提供了统一的纯度证明框架。

Abstract: Programming benefits from a clear separation between pure, mathematical
computation and impure, effectful interaction with the world. Existing
approaches to enforce this separation include monads, type-and-effect systems,
and capability systems. All share a tension between precision and usability,
and each one has non-obvious strengths and weaknesses.
  This paper aims to raise the bar in assessing such systems. First, we propose
a semantic definition of purity, inspired by contextual equivalence, as a
baseline independent of any specific typing discipline. Second, we propose that
expressiveness should be measured by the degree of completeness, i.e., how many
semantically pure terms can be typed as pure. Using this measure, we focus on
minimal meaningful effect and capability systems and show that they are
incomparable, i.e., neither subsumes the other in terms of expressiveness.
  Based on this result, we propose a synthesis and show that type, ability, and
effect systems combine their respective strengths while avoiding their
weaknesses. As part of our formal model, we provide a logical relation to
facilitate proofs of purity and other properties for a variety of effect typing
disciplines.

</details>


### [2] [The Functional Machine Calculus III: Control](https://arxiv.org/abs/2510.07851)
*Willem Heijltjes*

Main category: cs.PL

TL;DR: Functional Machine Calculus扩展了lambda演算，统一了函数式和命令式编程范式，支持计算效果、控制流操作，并保证汇合归约和类型化终止。


<details>
  <summary>Details</summary>
Motivation: 统一函数式和命令式编程范式，在保持lambda演算核心特性的同时嵌入计算效果、评估策略和控制流操作。

Method: 扩展简化的Krivine机器，增加多个操作数栈来建模效果，以及继续栈来建模顺序、分支和循环计算。通过简单的操作语义定义演算。

Result: 实现了汇合归约关系和简单类型系统，保证机器终止和强规范化（无迭代时）。这些特性可传递到嵌入的命令式语言中。

Conclusion: 提供了一个统一的函数式-命令式计算模型，支持简单类型、直观操作语义和汇合归约语义。

Abstract: The Functional Machine Calculus (Heijltjes 2022) is a new approach to
unifying the imperative and functional programming paradigms. It extends the
lambda-calculus, preserving the key features of confluent reduction and typed
termination, to embed computational effects, evaluation strategies, and control
flow operations. The first instalment modelled sequential higher-order
computation with global store, input/output, probabilities, and
non-determinism, and embedded both the call-by-name and call-by-value
lambda-calculus, as well as Moggi's computational metalanguage and Levy's
call-by-push-value. The present paper extends the calculus from sequential to
branching and looping control flow. This allows the faithful embedding of a
minimal but complete imperative language, including conditionals, exception
handling, and iteration, as well as constants and algebraic data types.
  The calculus is defined through a simple operational semantics, extending the
(simplified) Krivine machine for the lambda-calculus with multiple operand
stacks to model effects and a continuation stack to model sequential,
branching, and looping computation. It features a confluent reduction relation
and a system of simple types that guarantees termination of the machine and
strong normalization of reduction (in the absence of iteration). These
properties carry over to the embedded imperative language, providing a unified
functional-imperative model of computation that supports simple types, a direct
and intuitive operational semantics, and a confluent reduction semantics.

</details>
