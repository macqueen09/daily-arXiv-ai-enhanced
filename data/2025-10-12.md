<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Type, Ability, and Effect Systems: Perspectives on Purity, Semantics, and Expressiveness](https://arxiv.org/abs/2510.07582)
*Yuyan Bao,Tiark Rompf*

Main category: cs.PL

TL;DR: 本文提出了评估编程语言纯度系统的语义基准，比较了不同类型系统的表达能力，并展示了类型、能力和效果系统的组合优势。


<details>
  <summary>Details</summary>
Motivation: 现有强制纯度和效果分离的方法（如单子、类型效果系统、能力系统）在精度和可用性之间存在张力，各有优缺点，需要更好的评估标准。

Method: 1. 基于上下文等价性提出纯度的语义定义；2. 用完整性程度衡量表达能力；3. 比较最小有意义的效果和能力系统；4. 提出类型、能力和效果系统的综合方案。

Result: 发现最小有意义的效果系统和能力系统在表达能力上是不可比较的，即两者互不包含；提出的综合系统能结合各自优势并避免弱点。

Conclusion: 通过语义基准和表达能力测量，证明了不同类型系统的互补性，提出的综合方法为效果类型系统提供了更好的理论基础和证明工具。

Abstract: Programming benefits from a clear separation between pure, mathematical
computation and impure, effectful interaction with the world. Existing
approaches to enforce this separation include monads, type-and-effect systems,
and capability systems. All share a tension between precision and usability,
and each one has non-obvious strengths and weaknesses.
  This paper aims to raise the bar in assessing such systems. First, we propose
a semantic definition of purity, inspired by contextual equivalence, as a
baseline independent of any specific typing discipline. Second, we propose that
expressiveness should be measured by the degree of completeness, i.e., how many
semantically pure terms can be typed as pure. Using this measure, we focus on
minimal meaningful effect and capability systems and show that they are
incomparable, i.e., neither subsumes the other in terms of expressiveness.
  Based on this result, we propose a synthesis and show that type, ability, and
effect systems combine their respective strengths while avoiding their
weaknesses. As part of our formal model, we provide a logical relation to
facilitate proofs of purity and other properties for a variety of effect typing
disciplines.

</details>


### [2] [The Functional Machine Calculus III: Control](https://arxiv.org/abs/2510.07851)
*Willem Heijltjes*

Main category: cs.PL

TL;DR: Functional Machine Calculus从顺序计算扩展到分支和循环控制流，能够忠实嵌入包含条件、异常处理、迭代等的最小但完整的命令式语言，同时保持汇合归约和类型终止等关键特性。


<details>
  <summary>Details</summary>
Motivation: 统一函数式和命令式编程范式，在保持lambda演算核心特性的基础上嵌入计算效应、求值策略和控制流操作，从顺序计算扩展到分支循环控制流。

Method: 通过扩展简化的Krivine机器，使用多个操作数栈建模效应，使用延续栈建模顺序、分支和循环计算，定义简单的操作语义。

Result: 实现了汇合归约关系和简单类型系统，保证机器终止和强规范化（无迭代时），这些特性可传递到嵌入的命令式语言中。

Conclusion: 提供了一个支持简单类型、直观操作语义和汇合归约语义的统一函数式-命令式计算模型。

Abstract: The Functional Machine Calculus (Heijltjes 2022) is a new approach to
unifying the imperative and functional programming paradigms. It extends the
lambda-calculus, preserving the key features of confluent reduction and typed
termination, to embed computational effects, evaluation strategies, and control
flow operations. The first instalment modelled sequential higher-order
computation with global store, input/output, probabilities, and
non-determinism, and embedded both the call-by-name and call-by-value
lambda-calculus, as well as Moggi's computational metalanguage and Levy's
call-by-push-value. The present paper extends the calculus from sequential to
branching and looping control flow. This allows the faithful embedding of a
minimal but complete imperative language, including conditionals, exception
handling, and iteration, as well as constants and algebraic data types.
  The calculus is defined through a simple operational semantics, extending the
(simplified) Krivine machine for the lambda-calculus with multiple operand
stacks to model effects and a continuation stack to model sequential,
branching, and looping computation. It features a confluent reduction relation
and a system of simple types that guarantees termination of the machine and
strong normalization of reduction (in the absence of iteration). These
properties carry over to the embedded imperative language, providing a unified
functional-imperative model of computation that supports simple types, a direct
and intuitive operational semantics, and a confluent reduction semantics.

</details>
