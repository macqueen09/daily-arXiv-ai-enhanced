{"id": "2510.09726", "pdf": "https://arxiv.org/pdf/2510.09726", "abs": "https://arxiv.org/abs/2510.09726", "authors": ["Tilman Hinnerichs", "Reuben Gardos Reid", "Jaap de Jong", "Bart Swinkels", "Pamela Wochner", "Nicolae Filat", "Tudor Magurescu", "Issa Hanou", "Sebastijan Dumancic"], "title": "Herb.jl: A Unifying Program Synthesis Library", "categories": ["cs.PL", "cs.AI", "cs.SE"], "comment": null, "summary": "Program synthesis -- the automatic generation of code given a specification\n-- is one of the most fundamental tasks in artificial intelligence (AI) and\nmany programmers' dream. Numerous synthesizers have been developed to tackle\nprogram synthesis, manifesting different ideas to approach the exponentially\ngrowing program space. While numerous smart program synthesis tools exist,\nreusing and remixing previously developed methods is tedious and\ntime-consuming. We propose Herb.jl, a unifying program synthesis library\nwritten in the Julia programming language, to address these issues. Since\ncurrent methods rely on similar building blocks, we aim to modularize the\nunderlying synthesis algorithm into communicating and fully extendable\nsub-compartments, allowing for straightforward reapplication of these modules.\nTo demonstrate the benefits of using Herb.jl, we show three common use cases:\n1. how to implement a simple problem and grammar, and how to solve it, 2. how\nto implement a previously developed synthesizer with just a few lines of code,\nand 3. how to run a synthesizer against a benchmark."}
{"id": "2510.09932", "pdf": "https://arxiv.org/pdf/2510.09932", "abs": "https://arxiv.org/abs/2510.09932", "authors": ["Devansh Jain", "Akash Pardeshi", "Marco Frigo", "Krut Patel", "Kaustubh Khulbe", "Jai Arora", "Charith Mendis"], "title": "ACT: Automatically Generating Compiler Backends from Tensor Accelerator ISA Descriptions", "categories": ["cs.PL", "cs.AR"], "comment": null, "summary": "Tensor compilers play a key role in enabling high-performance implementations\nof deep learning workloads. These compilers rely on existing CPU and GPU code\ngeneration backends to generate device-specific code. Recently, many tensor\naccelerators (neural processing units) have been proposed to further accelerate\nthese workloads. Compared to commodity hardware, however, most of the proposed\ntensor accelerators do not have compiler backends with code generation support.\nMoreover, the accelerator designs are subject to fast iteration cycles, making\nit difficult to manually develop compiler backends similar to commodity\nhardware platforms. Therefore, to increase adoption and enable faster software\ndevelopment cycles for novel tensor accelerator designs, we need to make the\ncompiler backend construction process more agile.\n  To address this gap, we introduce ACT, a compiler backend generator that\nautomatically generates compiler backends for tensor accelerators, given just\nthe instruction set architecture (ISA) descriptions. We first formally specify\nthe compiler backend generation problem that introduces a novel specification\nfor describing tensor accelerator ISAs. Next, we design ACT such that it\nsupports user-programmable memories and complex parameterized instructions that\nare prevalent in tensor accelerators. ACT uses a novel parameterized equality\nsaturation-based instruction selection phase and a constraint programming-based\nmemory allocation phase. We prove that compiler backends generated by ACT are\nsound and complete. Finally, we generate compiler backends for three\naccelerator platforms from industry and academia, and show that they match or\noutperform code written using hand-optimized kernel libraries while maintaining\nlow compilation overheads."}
{"id": "2510.10015", "pdf": "https://arxiv.org/pdf/2510.10015", "abs": "https://arxiv.org/abs/2510.10015", "authors": ["Jinhua Wu", "Yuting Wang", "Liukun Yu", "Linglong Meng"], "title": "End-to-end Compositional Verification of Program Safety through Verified and Verifying Compilation", "categories": ["cs.PL"], "comment": null, "summary": "Program safety (i.e., absence of undefined behaviors) is critical for correct\noperation of computer systems. It is usually verified at the source level\n(e.g., by separation logics) and preserved to the target by verified compilers\n(e.g., CompCert), thereby achieving end-to-end verification of safety. However,\nmodern safe programming languages like Rust pose new problems in achieving\nend-to-end safety. Because not all functionalities can be implemented in the\nsafe language, mixing safe and unsafe modules is needed. Therefore, verified\ncompilation must preserve a modular notion of safety which can be composed at\nthe target level. Furthermore, certain classes of errors (e.g., memory errors)\nare automatically excluded by verifying compilation (e.g., borrow checking) for\nmodules written in safe languages. As a result, verified compilation needs to\ncooperate with verifying compilation to ensure end-to-end safety.\n  To address the above problems, we propose a modular and generic definition of\nsafety called open safety based on program semantics described as open labeled\ntransition systems (LTS). Open safety is composable at the boundary of modules\nand can be modularly preserved by verified compositional compilation. Those\nproperties enable separate verification of safety for heterogeneous modules and\ncomposition of the safety results at the target level. Open safety can be\ngeneralized to partial safety (i.e., only a certain class of errors can occur).\nBy this we formalized the correctness of verifying compilation as derivation of\ntotal safety from partial safety. We demonstrate how our framework can combine\nverified and verifying compilation by developing a verified compiler for an\nownership language (called Owlang) inspired by Rust. We evaluate our approach\non the compositional safety verification using a hash map implemented by Owlang\nand C."}
{"id": "2510.10209", "pdf": "https://arxiv.org/pdf/2510.10209", "abs": "https://arxiv.org/abs/2510.10209", "authors": ["Massinissa Merouani", "Afif Boudaoud", "Riyadh Baghdadi"], "title": "LOOPerSet: A Large-Scale Dataset for Data-Driven Polyhedral Compiler Optimization", "categories": ["cs.PL", "cs.LG", "cs.PF"], "comment": null, "summary": "The advancement of machine learning for compiler optimization, particularly\nwithin the polyhedral model, is constrained by the scarcity of large-scale,\npublic performance datasets. This data bottleneck forces researchers to\nundertake costly data generation campaigns, slowing down innovation and\nhindering reproducible research learned code optimization. To address this gap,\nwe introduce LOOPerSet, a new public dataset containing 28 million labeled data\npoints derived from 220,000 unique, synthetically generated polyhedral\nprograms. Each data point maps a program and a complex sequence of\nsemantics-preserving transformations (such as fusion, skewing, tiling, and\nparallelism)to a ground truth performance measurement (execution time). The\nscale and diversity of LOOPerSet make it a valuable resource for training and\nevaluating learned cost models, benchmarking new model architectures, and\nexploring the frontiers of automated polyhedral scheduling. The dataset is\nreleased under a permissive license to foster reproducible research and lower\nthe barrier to entry for data-driven compiler optimization."}
{"id": "2510.10216", "pdf": "https://arxiv.org/pdf/2510.10216", "abs": "https://arxiv.org/abs/2510.10216", "authors": ["Zhechong Huang", "Zhao Zhang", "Ruyi Ji", "Tingxuan Xia", "Qihao Zhu", "Qinxiang Cao", "Zeyu Sun", "Yingfei Xiong"], "title": "Learning to Guarantee Type Correctness in Code Generation through Type-Guided Program Synthesis", "categories": ["cs.PL", "cs.AI", "cs.SE"], "comment": null, "summary": "Language models have shown remarkable proficiency in code generation;\nnevertheless, ensuring type correctness remains a challenge. Although\ntraditional methods, such as constrained decoding, alleviate this problem by\nexternally rejecting untypable code, the model itself does not effectively\nlearn type reasoning internally, which ultimately limits its overall\nperformance. This paper introduces TyFlow, a novel system that internalizes\ntype reasoning within code generation to guide the model to learn the type\nsystem. The core of our approach is a novel type-guided program synthesis\nsystem that maintains an isomorphism between type derivation trees and\nsynthesis derivation trees, enabling a new code representation based on\nsynthesis decision sequences rather than traditional text-based token\nsequences. By offloading the complexity of type system learning to the\nrepresentation itself, models can redirect their computational resources toward\nhigher-level program semantics. Our evaluation shows that TyFlow not only\neliminates type errors but also significantly improves functional correctness,\nhighlighting the importance of aligning LMs with type systems internally."}
{"id": "2510.10219", "pdf": "https://arxiv.org/pdf/2510.10219", "abs": "https://arxiv.org/abs/2510.10219", "authors": ["Ruihao Li", "Lizy K. John", "Neeraja J. Yadwadkar"], "title": "Old is Gold: Optimizing Single-threaded Applications with Exgen-Malloc", "categories": ["cs.PL"], "comment": null, "summary": "Memory allocators hide beneath nearly every application stack, yet their\nperformance footprint extends far beyond their code size. Even small\ninefficiencies in the allocators ripple through caches and the rest of the\nmemory hierarchy, collectively imposing what operators often call a \"datacenter\ntax\". At hyperscale, even a 1% improvement in allocator efficiency can unlock\nmillions of dollars in savings and measurable reductions in datacenter energy\nconsumption. Modern memory allocators are designed to optimize allocation speed\nand memory fragmentation in multi-threaded environments, relying on complex\nmetadata and control logic to achieve high performance. However, the overhead\nintroduced by this complexity prompts a reevaluation of allocator design.\nNotably, such overhead can be avoided in single-threaded scenarios, which\ncontinue to be widely used across diverse application domains.\n  In this paper, we introduce Exgen-Malloc, a memory allocator purpose-built\nfor single-threaded applications. By specializing for single-threaded\nexecution, Exgen-Malloc eliminates unnecessary metadata, simplifies the control\nflow, thereby reducing overhead and improving allocation efficiency. Its core\ndesign features include a centralized heap, a single free-block list, and a\nbalanced strategy for memory commitment and relocation. Additionally,\nExgen-Malloc incorporates design principles in modern multi-threaded\nallocators, which do not exist in legacy single-threaded allocators such as\ndlmalloc. We evaluate Exgen-Malloc on two Intel Xeon platforms. Across both\nsystems, Exgen-Malloc achieves a speedup of 1.17x, 1.10x, and 1.93x over\ndlmalloc on SPEC CPU2017, redis-benchmark, and mimalloc-bench, respectively. In\naddition to performance, Exgen-Malloc achieves 6.2%, 0.1%, and 25.2% memory\nsavings over mimalloc on SPEC CPU2017, redis-benchmark, and mimalloc-bench,\nrespectively."}
{"id": "2510.10410", "pdf": "https://arxiv.org/pdf/2510.10410", "abs": "https://arxiv.org/abs/2510.10410", "authors": ["Hui Xu"], "title": "A Trace-based Approach for Code Safety Analysis", "categories": ["cs.PL", "cs.SE"], "comment": null, "summary": "Rust is a memory-safe programming language that disallows undefined behavior.\nIts safety guarantees have been extensively examined by the community through\nempirical studies, which has led to its remarkable success. However, unsafe\ncode remains a critical concern in Rust. By reviewing the safety design of Rust\nand analyzing real-world Rust projects, this paper establishes a systematic\nframework for understanding unsafe code and undefined behavior, and summarizes\nthe soundness criteria for Rust code. It further derives actionable guidance\nfor achieving sound encapsulation."}
{"id": "2510.10517", "pdf": "https://arxiv.org/pdf/2510.10517", "abs": "https://arxiv.org/abs/2510.10517", "authors": ["Su-Hyeon Kim", "Joonghyuk Hahn", "Sooyoung Cha", "Yo-Sub Han"], "title": "ECO: Enhanced Code Optimization via Performance-Aware Prompting for Code-LLMs", "categories": ["cs.PL", "cs.AI", "cs.SE"], "comment": null, "summary": "Code runtime optimization-the task of rewriting a given code to a faster\none-remains challenging, as it requires reasoning about performance trade-offs\ninvolving algorithmic and structural choices. Recent approaches employ\ncode-LLMs with slow-fast code pairs provided as optimization guidance, but such\npair-based methods obscure the causal factors of performance gains and often\nlead to superficial pattern imitation rather than genuine performance\nreasoning. We introduce ECO, a performance-aware prompting framework for code\noptimization. ECO first distills runtime optimization instructions (ROIs) from\nreference slow-fast code pairs; Each ROI describes root causes of inefficiency\nand the rationales that drive performance improvements. For a given input code,\nECO in parallel employs (i) a symbolic advisor to produce a bottleneck\ndiagnosis tailored to the code, and (ii) an ROI retriever to return related\nROIs. These two outputs are then composed into a performance-aware prompt,\nproviding actionable guidance for code-LLMs. ECO's prompts are model-agnostic,\nrequire no fine-tuning, and can be easily prepended to any code-LLM prompt. Our\nempirical studies highlight that ECO prompting significantly improves\ncode-LLMs' ability to generate efficient code, achieving speedups of up to\n7.81x while minimizing correctness loss."}
{"id": "2510.10531", "pdf": "https://arxiv.org/pdf/2510.10531", "abs": "https://arxiv.org/abs/2510.10531", "authors": ["Guillaume Ambal", "George Hodgkins", "Mark Madler", "Gregory Chockler", "Brijesh Dongol", "Joseph Izraelevitz", "Azalea Raad", "Viktor Vafeiadis"], "title": "A Verified High-Performance Composable Object Library for Remote Direct Memory Access (Extended Version)", "categories": ["cs.PL", "cs.DC", "cs.LO", "cs.SY", "eess.SY"], "comment": null, "summary": "Remote Direct Memory Access (RDMA) is a memory technology that allows remote\ndevices to directly write to and read from each other's memory, bypassing\ncomponents such as the CPU and operating system. This enables low-latency\nhigh-throughput networking, as required for many modern data centres, HPC\napplications and AI/ML workloads. However, baseline RDMA comprises a highly\npermissive weak memory model that is difficult to use in practice and has only\nrecently been formalised. In this paper, we introduce the Library of Composable\nObjects (LOCO), a formally verified library for building multi-node objects on\nRDMA, filling the gap between shared memory and distributed system programming.\nLOCO objects are well-encapsulated and take advantage of the strong locality\nand the weak consistency characteristics of RDMA. They have performance\ncomparable to custom RDMA systems (e.g. distributed maps), but with a far\nsimpler programming model amenable to formal proofs of correctness. To support\nverification, we develop a novel modular declarative verification framework,\ncalled Mowgli, that is flexible enough to model multinode objects and is\nindependent of a memory consistency model. We instantiate Mowgli with the RDMA\nmemory model, and use it to verify correctness of LOCO libraries."}
{"id": "2510.11007", "pdf": "https://arxiv.org/pdf/2510.11007", "abs": "https://arxiv.org/abs/2510.11007", "authors": ["Antonina Nepeivoda", "Ilya Afanasyev"], "title": "Abstract String Domain Defined with Word Equations as a Reduced Product (Extended Version)", "categories": ["cs.PL", "cs.FL"], "comment": null, "summary": "We introduce a string-interval abstract domain, where string intervals are\ncharacterized by systems of word equations (encoding lower bounds on string\nvalues) and word disequalities (encoding upper bounds). Building upon the\nlattice structure of string intervals, we define an abstract string object as a\nreduced product on a string property semilattice, determined by\nlength-non-increasing morphisms. We consider several reduction strategies for\nabstract string objects and show that upon these strategies the string object\ndomain forms a lattice. We define basic abstract string operations on the\ndomain, aiming to minimize computational overheads on the reduction, and show\nhow the domain can be used to analyse properties of JavaScript string\nmanipulating programs."}
{"id": "2510.11420", "pdf": "https://arxiv.org/pdf/2510.11420", "abs": "https://arxiv.org/abs/2510.11420", "authors": ["Mark Koch", "Agust√≠n Borgna", "Seyon Sivarajah", "Alan Lawrence", "Alec Edgington", "Douglas Wilson", "Craig Roy", "Luca Mondada", "Lukas Heidemann", "Ross Duncan"], "title": "HUGR: A Quantum-Classical Intermediate Representation", "categories": ["cs.PL", "quant-ph"], "comment": "8 pages, extended abstract submitted to PlanQC25", "summary": "We introduce the Hierarchical Unified Graph Representation (HUGR): a novel\ngraph based intermediate representation for mixed quantum-classical programs.\nHUGR's design features high expressivity and extensibility to capture the\ncapabilities of near-term and forthcoming quantum computing devices, as well as\nnew and evolving abstractions from novel quantum programming paradigms. The\ngraph based structure is machine-friendly and supports powerful pattern\nmatching based compilation techniques. Inspired by MLIR, HUGR's extensibility\nfurther allows compilation tooling to reason about programs at multiple levels\nof abstraction, lowering smoothly between them. Safety guarantees in the\nstructure including strict, static typing and linear quantum types allow rapid\ndevelopment of compilation tooling without fear of program invalidation. A full\nspecification of HUGR and reference implementation are open-source and\navailable online."}
{"id": "2510.11573", "pdf": "https://arxiv.org/pdf/2510.11573", "abs": "https://arxiv.org/abs/2510.11573", "authors": ["Santiago Arranz-Olmos", "Gilles Barthe", "Lionel Blatter", "Xingyu Xie", "Zhiyuan Zhang"], "title": "(Dis)Proving Spectre Security with Speculation-Passing Style", "categories": ["cs.PL"], "comment": null, "summary": "Constant-time (CT) verification tools are commonly used for detecting\npotential side-channel vulnerabilities in cryptographic libraries. Recently, a\nnew class of tools, called speculative constant-time (SCT) tools, has also been\nused for detecting potential Spectre vulnerabilities. In many cases, these SCT\ntools have emerged as liftings of CT tools. However, these liftings are seldom\ndefined precisely and are almost never analyzed formally. The goal of this\npaper is to address this gap, by developing formal foundations for these\nliftings, and to demonstrate that these foundations can yield practical\nbenefits.\n  Concretely, we introduce a program transformation, coined Speculation-Passing\nStyle (SPS), for reducing SCT verification to CT verification. Essentially, the\ntransformation instruments the program with a new input that corresponds to\nattacker-controlled predictions and modifies the program to follow them. This\napproach is sound and complete, in the sense that a program is SCT if and only\nif its SPS transform is CT. Thus, we can leverage existing CT verification\ntools to prove SCT; we illustrate this by combining SPS with three standard\nmethodologies for CT verification, namely reducing it to non-interference,\nassertion safety and dynamic taint analysis. We realize these combinations with\nthree existing tools, EasyCrypt, BINSEC, and ctgrind, and we evaluate them on\nKocher's benchmarks for Spectre-v1. Our results focus on Spectre-v1 in the\nstandard CT leakage model; however, we also discuss applications of our method\nto other variants of Spectre and other leakage models."}
{"id": "2510.09633", "pdf": "https://arxiv.org/pdf/2510.09633", "abs": "https://arxiv.org/abs/2510.09633", "authors": ["Bernhard Mueller"], "title": "Hound: Relation-First Knowledge Graphs for Complex-System Reasoning in Security Audits", "categories": ["cs.CR", "cs.AI", "cs.LG", "cs.PL"], "comment": null, "summary": "Hound introduces a relation-first graph engine that improves system-level\nreasoning across interrelated components in complex codebases. The agent\ndesigns flexible, analyst-defined views with compact annotations (e.g.,\nmonetary/value flows, authentication/authorization roles, call graphs, protocol\ninvariants) and uses them to anchor exact retrieval: for any question, it loads\nprecisely the code that matters (often across components) so it can zoom out to\nsystem structure and zoom in to the decisive lines. A second contribution is a\npersistent belief system: long-lived vulnerability hypotheses whose confidence\nis updated as evidence accrues. The agent employs coverage-versus-intuition\nplanning and a QA finalizer to confirm or reject hypotheses. On a five-project\nsubset of ScaBench[1], Hound improves recall and F1 over a baseline LLM\nanalyzer (micro recall 31.2% vs. 8.3%; F1 14.2% vs. 9.8%) with a modest\nprecision trade-off. We attribute these gains to flexible, relation-first\ngraphs that extend model understanding beyond call/dataflow to abstract\naspects, plus the hypothesis-centric loop; code and artifacts are released to\nsupport reproduction."}
{"id": "2510.10066", "pdf": "https://arxiv.org/pdf/2510.10066", "abs": "https://arxiv.org/abs/2510.10066", "authors": ["Shan Jiang", "Chenguang Zhu", "Sarfraz Khurshid"], "title": "OBsmith: Testing JavaScript Obfuscator using LLM-powered sketching", "categories": ["cs.SE", "cs.AI", "cs.PL"], "comment": null, "summary": "JavaScript obfuscators are widely deployed to protect intellectual property\nand resist reverse engineering, yet their correctness has been largely\noverlooked compared to performance and resilience. Existing evaluations\ntypically measure resistance to deobfuscation, leaving the critical question of\nwhether obfuscators preserve program semantics unanswered. Incorrect\ntransformations can silently alter functionality, compromise reliability, and\nerode security-undermining the very purpose of obfuscation. To address this\ngap, we present OBsmith, a novel framework to systematically test JavaScript\nobfuscators using large language models (LLMs). OBsmith leverages LLMs to\ngenerate program sketches abstract templates capturing diverse language\nconstructs, idioms, and corner cases-which are instantiated into executable\nprograms and subjected to obfuscation under different configurations. Besides\nLLM-powered sketching, OBsmith also employs a second source: automatic\nextraction of sketches from real programs. This extraction path enables more\nfocused testing of project specific features and lets developers inject domain\nknowledge into the resulting test cases. OBsmith uncovers 11 previously unknown\ncorrectness bugs. Under an equal program budget, five general purpose\nstate-of-the-art JavaScript fuzzers (FuzzJIT, Jsfunfuzz, Superion, DIE,\nFuzzilli) failed to detect these issues, highlighting OBsmith's complementary\nfocus on obfuscation induced misbehavior. An ablation shows that all components\nexcept our generic MRs contribute to at least one bug class; the negative MR\nresult suggests the need for obfuscator-specific metamorphic relations. Our\nresults also seed discussion on how to balance obfuscation presets and\nperformance cost. We envision OBsmith as an important step towards automated\ntesting and quality assurance of obfuscators and other semantic-preserving\ntoolchains."}
{"id": "2510.11199", "pdf": "https://arxiv.org/pdf/2510.11199", "abs": "https://arxiv.org/abs/2510.11199", "authors": ["Kaustuv Chaudhuri", "Daniele Nantes-Sobrinho"], "title": "Proceedings Twentieth International Workshop on Logical Frameworks and Meta-Languages: Theory and Practice", "categories": ["cs.LO", "cs.PL"], "comment": null, "summary": "These are the contributed papers presented at the 20th International Workshop\non Logical Frameworks and Meta-Languages: Theory and Practice (LFMTP 2025), at\nBirmingham, UK on 19 July as a satellite event of the FSCD conference. The\nprogram committee for this edition of LFMTP was chaired by Kaustuv Chaudhuri\nand Daniele Nantes-Sobrinho. More information about LFMTP can be found on\nhttps://lfmtp.org."}
