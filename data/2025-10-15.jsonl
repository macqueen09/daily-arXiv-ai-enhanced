{"id": "2510.11751", "pdf": "https://arxiv.org/pdf/2510.11751", "abs": "https://arxiv.org/abs/2510.11751", "authors": ["Jan Pedersen", "Kevin Chalmers"], "title": "Verifying Correctness of Shared Channels in a Cooperatively Scheduled Process-Oriented Language", "categories": ["cs.PL"], "comment": null, "summary": "Correct concurrent behaviour is important in understanding how components\nwill act within certain conditions. In this work. we analyse the behaviour of\nshared communicating channels within a coorporatively scheduled runtime. We use\nthe refinement checking and modelling tool FDR to develop both specifications\nof how such shared channels should behave and models of the implementations of\nthese channels in the cooperatively scheduled language ProcessJ. Our results\ndemonstrate that although we can certainly implement the correct behaviour of\nsuch channels, the outcome is dependant on having adequate resources available\nto execute all processes involved. We conclude that modelling the runtime\nenvironment of concurrent components is necessary to ensure components behave\nas specified in the real world."}
{"id": "2510.11759", "pdf": "https://arxiv.org/pdf/2510.11759", "abs": "https://arxiv.org/abs/2510.11759", "authors": ["Hongyu Lin", "Haolin Pan", "Haoran Luo", "Yuchen Li", "Kaichun Yao", "Libo Zhang", "Mingjie Xing", "Yanjun Wu"], "title": "AwareCompiler: Agentic Context-Aware Compiler Optimization via a Synergistic Knowledge-Data Driven Framework", "categories": ["cs.PL", "cs.AI"], "comment": null, "summary": "Compiler optimization is crucial for enhancing program performance by\ntransforming the sequence of optimization passes while maintaining correctness.\nDespite the promising potential of large language models (LLMs)-based agent for\nsoftware optimization, automating compiler optimization remains challenging due\nto: (1) semantic misalignment between abstract program representations and\nconcrete optimization passes, (2) inefficient interaction mechanisms between\nagents and compiler environments, and (3) reward sparsity from the extensive\ndecision-making process within large optimization spaces. This paper introduces\n\\textbf{AwareCompiler}, an agentic framework for compiler optimization that\naddresses these challenges through three key innovations: structured knowledge\nintegration and dataset construction, knowledge-driven adaptive pass\ngeneration, and data-driven hybrid training pipeline. Experimental results on\nstandard benchmarks demonstrate that AwareCompiler significantly outperforms\nexisting baselines in both performance and efficiency, highlighting the\neffectiveness of our synergistic knowledge-data-driven approach. Our code is\npublicly available at https://github.com/LHY-24/AwareCompiler."}
{"id": "2510.12131", "pdf": "https://arxiv.org/pdf/2510.12131", "abs": "https://arxiv.org/abs/2510.12131", "authors": ["Haobin Ni", "Robbert van Renesse", "Greg Morrisett"], "title": "Functional Reasoning for Distributed Systems with Failures", "categories": ["cs.PL"], "comment": null, "summary": "Distributed system theory literature often argues for correctness using an\ninformal, Hoare-like style of reasoning. While these arguments are intuitive,\nthey have not all been foolproof, and whether they directly correspond to\nformal proofs is in question. We formally ground this kind of reasoning and\nconnect it to standard formal approaches through language design and\nmeta-analysis, which leads to a functional style of compositional formal\nreasoning for a class of distributed systems, including cases involving\nByzantine faults. The core of our approach is twin languages: Sync and Async,\nwhich formalize the insight from distributed system theory that an asynchronous\nsystem can be reduced to a synchronous system for more straightforward\nreasoning under certain conditions. Sync describes a distributed system as a\nsingle, synchronous, data-parallel program. It restricts programs syntactically\nand has a functional denotational semantics suitable for Hoare-style formal\nreasoning. Async models a distributed system as a collection of interacting\nmonadic programs, one for each non-faulty node in the system. It has a standard\ntrace-based operational semantics, modeling asynchrony with interleaving. Sync\ncompiles to Async and can then be extracted to yield executable code. We prove\nthat any safety property proven for a Sync program in its denotational\nsemantics is preserved in the operational semantics of its compiled Async\nprograms. We implement the twin languages in Rocq and verify the safety\nproperties of two fault-tolerant consensus protocols: BOSCO and SeqPaxos."}
{"id": "2510.12295", "pdf": "https://arxiv.org/pdf/2510.12295", "abs": "https://arxiv.org/abs/2510.12295", "authors": ["Roberto M. Amadio"], "title": "Operational methods in semantics", "categories": ["cs.PL", "cs.LO", "ACM F.3.2", "F.3.2"], "comment": null, "summary": "The focus of these lecture notes is on abstract models and basic ideas and\nresults that relate to the operational semantics of programming languages\nlargely conceived. The approach is to start with an abstract description of the\ncomputation steps of programs and then to build on top semantic equivalences,\nspecification languages, and static analyses. While other approaches to the\nsemantics of programming languages are possible, it appears that the\noperational one is particularly effective in that it requires a moderate level\nof mathematical sophistication and scales reasonably well to a large variety of\nprogramming features. In practice, operational semantics is a suitable\nframework to build portable language implementations and to specify and test\nprogram properties. It is also used routinely to tackle more ambitious tasks\nsuch as proving the correctness of a compiler or a static analyzer."}
{"id": "2510.12582", "pdf": "https://arxiv.org/pdf/2510.12582", "abs": "https://arxiv.org/abs/2510.12582", "authors": ["Mark Koch", "Alan Lawrence", "Kartik Singhal", "Seyon Sivarajah", "Ross Duncan"], "title": "GUPPY: Pythonic Quantum-Classical Programming", "categories": ["cs.PL", "cs.SE", "quant-ph"], "comment": "Presented at the Fourth International Workshop on Programming\n  Languages for Quantum Computing (PLanQC 2024)", "summary": "We present ongoing work on Guppy, a domain-specific language embedded in\nPython that allows users to write high-level hybrid quantum programs with\ncomplex control flow in Pythonic syntax, aiming to run them on actual quantum\nhardware."}
{"id": "2510.12269", "pdf": "https://arxiv.org/pdf/2510.12269", "abs": "https://arxiv.org/abs/2510.12269", "authors": ["Pedro Domingos"], "title": "Tensor Logic: The Language of AI", "categories": ["cs.AI", "cs.LG", "cs.NE", "cs.PL", "stat.ML", "I.2.3; I.2.4; I.2.5; I.2.6; I.5.1"], "comment": "17 pages, 0 figures", "summary": "Progress in AI is hindered by the lack of a programming language with all the\nrequisite features. Libraries like PyTorch and TensorFlow provide automatic\ndifferentiation and efficient GPU implementation, but are additions to Python,\nwhich was never intended for AI. Their lack of support for automated reasoning\nand knowledge acquisition has led to a long and costly series of hacky attempts\nto tack them on. On the other hand, AI languages like LISP an Prolog lack\nscalability and support for learning. This paper proposes tensor logic, a\nlanguage that solves these problems by unifying neural and symbolic AI at a\nfundamental level. The sole construct in tensor logic is the tensor equation,\nbased on the observation that logical rules and Einstein summation are\nessentially the same operation, and all else can be reduced to them. I show how\nto elegantly implement key forms of neural, symbolic and statistical AI in\ntensor logic, including transformers, formal reasoning, kernel machines and\ngraphical models. Most importantly, tensor logic makes new directions possible,\nsuch as sound reasoning in embedding space. This combines the scalability and\nlearnability of neural networks with the reliability and transparency of\nsymbolic reasoning, and is potentially a basis for the wider adoption of AI."}
{"id": "2510.12297", "pdf": "https://arxiv.org/pdf/2510.12297", "abs": "https://arxiv.org/abs/2510.12297", "authors": ["Nathan Guermond", "Gopalan Nadathur"], "title": "Ground Stratification for a Logic of Definitions with Induction", "categories": ["cs.LO", "cs.PL", "F.4.1; D.2.4"], "comment": "In Proceedings LFMTP 2025, arXiv:2510.11199", "summary": "The logic underlying the Abella proof assistant includes mechanisms for\ninterpreting atomic predicates through fixed point definitions that can\nadditionally be treated inductively or co-inductively. However, the original\nformulation of the logic includes a strict stratification condition on\ndefinitions that is too restrictive for some applications such as those that\nuse a logical relations based approach to semantic equivalence. Tiu has shown\nhow this restriction can be eased by utilizing a weaker notion referred to as\nground stratification. Tiu's results were limited to a version of the logic\nthat does not treat inductive definitions. We show here that they can be\nextended to cover such definitions. While our results are obtained by using\ntechniques that have been previously deployed in related ways in this context,\ntheir use is sensitive to the particular way in which we generalize the logic.\nIn particular, although ground stratification may be used with arbitrary\nfixed-point definitions, we show that weakening stratification to this form for\ninductive definitions leads to inconsistency. The particular generalization we\ndescribe accords well with the way logical relations are used in practice. Our\nresults are also a intermediate step to building a more flexible form for\ndefinitions into the full logic underlying Abella, which additionally includes\nco-induction, generic quantification, and a mechanism referred to as nominal\nabstraction for analyzing occurrences of objects in terms that are governed by\ngeneric quantifiers."}
{"id": "2510.12702", "pdf": "https://arxiv.org/pdf/2510.12702", "abs": "https://arxiv.org/abs/2510.12702", "authors": ["Cedric Richter", "Heike Wehrheim"], "title": "Beyond Postconditions: Can Large Language Models infer Formal Contracts for Automatic Software Verification?", "categories": ["cs.SE", "cs.AI", "cs.PL"], "comment": "under submission", "summary": "Automatic software verifiers have become increasingly effective at the task\nof checking software against (formal) specifications. Yet, their adoption in\npractice has been hampered by the lack of such specifications in real world\ncode. Large Language Models (LLMs) have shown promise in inferring formal\npostconditions from natural language hints embedded in code such as function\nnames, comments or documentation. Using the generated postconditions as\nspecifications in a subsequent verification, however, often leads verifiers to\nsuggest invalid inputs, hinting at potential issues that ultimately turn out to\nbe false alarms.\n  To address this, we revisit the problem of specification inference from\nnatural language in the context of automatic software verification. In the\nprocess, we introduce NL2Contract, the task of employing LLMs to translate\ninformal natural language into formal functional contracts, consisting of\npostconditions as well as preconditions. We introduce metrics to validate and\ncompare different NL2Contract approaches, using soundness, bug discriminative\npower of the generated contracts and their usability in the context of\nautomatic software verification as key metrics. We evaluate NL2Contract with\ndifferent LLMs and compare it to the task of postcondition generation\nnl2postcond. Our evaluation shows that (1) LLMs are generally effective at\ngenerating functional contracts sound for all possible inputs, (2) the\ngenerated contracts are sufficiently expressive for discriminating buggy from\ncorrect behavior, and (3) verifiers supplied with LLM inferred functional\ncontracts produce fewer false alarms than when provided with postconditions\nalone. Further investigations show that LLM inferred preconditions generally\nalign well with developers intentions which allows us to use automatic software\nverifiers to catch real-world bugs."}
