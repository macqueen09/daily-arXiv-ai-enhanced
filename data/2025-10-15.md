<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 5]
- [cs.LO](#cs.LO) [Total: 1]
- [cs.SE](#cs.SE) [Total: 1]
- [cs.AI](#cs.AI) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Verifying Correctness of Shared Channels in a Cooperatively Scheduled Process-Oriented Language](https://arxiv.org/abs/2510.11751)
*Jan Pedersen,Kevin Chalmers*

Main category: cs.PL

TL;DR: 使用FDR工具分析协作调度运行时中共享通信通道的行为，验证ProcessJ语言中通道实现的正确性，发现正确行为依赖于充足的执行资源。


<details>
  <summary>Details</summary>
Motivation: 理解组件在特定条件下的并发行为非常重要，特别是在协作调度运行时中分析共享通信通道的行为。

Method: 使用FDR精化检查和建模工具，开发共享通道应如何行为的规范，并对ProcessJ语言中这些通道的实现进行建模。

Result: 结果表明虽然可以实现正确的通道行为，但结果取决于是否有足够的资源来执行所有相关进程。

Conclusion: 建模并发组件的运行时环境对于确保组件在现实世界中按规范行为是必要的。

Abstract: Correct concurrent behaviour is important in understanding how components
will act within certain conditions. In this work. we analyse the behaviour of
shared communicating channels within a coorporatively scheduled runtime. We use
the refinement checking and modelling tool FDR to develop both specifications
of how such shared channels should behave and models of the implementations of
these channels in the cooperatively scheduled language ProcessJ. Our results
demonstrate that although we can certainly implement the correct behaviour of
such channels, the outcome is dependant on having adequate resources available
to execute all processes involved. We conclude that modelling the runtime
environment of concurrent components is necessary to ensure components behave
as specified in the real world.

</details>


### [2] [AwareCompiler: Agentic Context-Aware Compiler Optimization via a Synergistic Knowledge-Data Driven Framework](https://arxiv.org/abs/2510.11759)
*Hongyu Lin,Haolin Pan,Haoran Luo,Yuchen Li,Kaichun Yao,Libo Zhang,Mingjie Xing,Yanjun Wu*

Main category: cs.PL

TL;DR: AwareCompiler是一个基于LLM的编译器优化代理框架，通过结构化知识集成、知识驱动的自适应pass生成和数据驱动的混合训练管道，解决了语义对齐、交互效率和奖励稀疏性等挑战。


<details>
  <summary>Details</summary>
Motivation: 编译器优化对提升程序性能至关重要，但现有的LLM代理方法面临语义对齐问题、交互效率低下和奖励稀疏性等挑战。

Method: 提出三阶段方法：结构化知识集成与数据集构建、知识驱动的自适应pass生成、数据驱动的混合训练管道。

Result: 在标准基准测试中，AwareCompiler在性能和效率方面显著优于现有基线方法。

Conclusion: 该框架展示了知识数据驱动方法在编译器优化中的有效性，代码已开源。

Abstract: Compiler optimization is crucial for enhancing program performance by
transforming the sequence of optimization passes while maintaining correctness.
Despite the promising potential of large language models (LLMs)-based agent for
software optimization, automating compiler optimization remains challenging due
to: (1) semantic misalignment between abstract program representations and
concrete optimization passes, (2) inefficient interaction mechanisms between
agents and compiler environments, and (3) reward sparsity from the extensive
decision-making process within large optimization spaces. This paper introduces
\textbf{AwareCompiler}, an agentic framework for compiler optimization that
addresses these challenges through three key innovations: structured knowledge
integration and dataset construction, knowledge-driven adaptive pass
generation, and data-driven hybrid training pipeline. Experimental results on
standard benchmarks demonstrate that AwareCompiler significantly outperforms
existing baselines in both performance and efficiency, highlighting the
effectiveness of our synergistic knowledge-data-driven approach. Our code is
publicly available at https://github.com/LHY-24/AwareCompiler.

</details>


### [3] [Functional Reasoning for Distributed Systems with Failures](https://arxiv.org/abs/2510.12131)
*Haobin Ni,Robbert van Renesse,Greg Morrisett*

Main category: cs.PL

TL;DR: 本文通过设计Sync和Async两种语言，为分布式系统的非正式Hoare式推理提供形式化基础，证明在特定条件下异步系统可简化为同步系统进行推理，并验证了两个容错共识协议的安全性。


<details>
  <summary>Details</summary>
Motivation: 分布式系统理论文献常使用非正式的Hoare式推理来论证正确性，但这些论证并非绝对可靠，且与形式化证明的对应关系存疑。本文旨在为这类推理提供形式化基础。

Method: 设计Sync和Async两种语言：Sync将分布式系统描述为同步数据并行程序，具有函数式指称语义；Async将系统建模为交互式单子程序集合，具有基于轨迹的操作语义。Sync可编译为Async，并最终生成可执行代码。

Result: 证明了在Sync程序的指称语义中证明的任何安全性属性，在其编译后的Async程序的操作语义中都能保持。在Rocq中实现了这两种语言，并验证了BOSCO和SeqPaxos两个容错共识协议的安全性。

Conclusion: 通过语言设计和元分析，为分布式系统的Hoare式推理提供了形式化基础，建立了异步系统向同步系统简化的形式化连接，适用于包括拜占庭容错在内的分布式系统类别。

Abstract: Distributed system theory literature often argues for correctness using an
informal, Hoare-like style of reasoning. While these arguments are intuitive,
they have not all been foolproof, and whether they directly correspond to
formal proofs is in question. We formally ground this kind of reasoning and
connect it to standard formal approaches through language design and
meta-analysis, which leads to a functional style of compositional formal
reasoning for a class of distributed systems, including cases involving
Byzantine faults. The core of our approach is twin languages: Sync and Async,
which formalize the insight from distributed system theory that an asynchronous
system can be reduced to a synchronous system for more straightforward
reasoning under certain conditions. Sync describes a distributed system as a
single, synchronous, data-parallel program. It restricts programs syntactically
and has a functional denotational semantics suitable for Hoare-style formal
reasoning. Async models a distributed system as a collection of interacting
monadic programs, one for each non-faulty node in the system. It has a standard
trace-based operational semantics, modeling asynchrony with interleaving. Sync
compiles to Async and can then be extracted to yield executable code. We prove
that any safety property proven for a Sync program in its denotational
semantics is preserved in the operational semantics of its compiled Async
programs. We implement the twin languages in Rocq and verify the safety
properties of two fault-tolerant consensus protocols: BOSCO and SeqPaxos.

</details>


### [4] [Operational methods in semantics](https://arxiv.org/abs/2510.12295)
*Roberto M. Amadio*

Main category: cs.PL

TL;DR: 这些讲义笔记聚焦于编程语言操作语义的抽象模型、基本思想和结果，采用从程序计算步骤的抽象描述开始，逐步构建语义等价性、规范语言和静态分析的方法。


<details>
  <summary>Details</summary>
Motivation: 操作语义方法需要适度的数学复杂度，能很好地扩展到各种编程特性，是构建可移植语言实现、指定和测试程序属性的合适框架，也常用于证明编译器或静态分析器的正确性。

Method: 从程序计算步骤的抽象描述开始，逐步构建语义等价性、规范语言和静态分析，采用操作语义方法。

Result: 操作语义方法被证明是特别有效的，能够扩展到各种编程特性，并可用于构建便携式语言实现、指定程序属性以及证明编译器或静态分析器的正确性。

Conclusion: 操作语义是编程语言语义学中一个特别有效的方法，它平衡了数学复杂度和可扩展性，为语言实现和程序验证提供了实用的框架。

Abstract: The focus of these lecture notes is on abstract models and basic ideas and
results that relate to the operational semantics of programming languages
largely conceived. The approach is to start with an abstract description of the
computation steps of programs and then to build on top semantic equivalences,
specification languages, and static analyses. While other approaches to the
semantics of programming languages are possible, it appears that the
operational one is particularly effective in that it requires a moderate level
of mathematical sophistication and scales reasonably well to a large variety of
programming features. In practice, operational semantics is a suitable
framework to build portable language implementations and to specify and test
program properties. It is also used routinely to tackle more ambitious tasks
such as proving the correctness of a compiler or a static analyzer.

</details>


### [5] [GUPPY: Pythonic Quantum-Classical Programming](https://arxiv.org/abs/2510.12582)
*Mark Koch,Alan Lawrence,Kartik Singhal,Seyon Sivarajah,Ross Duncan*

Main category: cs.PL

TL;DR: Guppy是一个嵌入Python的领域特定语言，用于编写具有复杂控制流的高层次混合量子程序，目标是能在真实量子硬件上运行。


<details>
  <summary>Details</summary>
Motivation: 开发一种能够在真实量子硬件上运行的高层次混合量子编程语言，支持复杂的控制流和Pythonic语法。

Method: 在Python中嵌入领域特定语言Guppy，允许用户使用Pythonic语法编写混合量子程序。

Result: 提出了Guppy语言的设计和实现，这是一个正在进行的工作。

Conclusion: Guppy为量子编程提供了一种高层次、Pythonic的方法，支持复杂控制流，并面向真实量子硬件执行。

Abstract: We present ongoing work on Guppy, a domain-specific language embedded in
Python that allows users to write high-level hybrid quantum programs with
complex control flow in Pythonic syntax, aiming to run them on actual quantum
hardware.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [6] [Ground Stratification for a Logic of Definitions with Induction](https://arxiv.org/abs/2510.12297)
*Nathan Guermond,Gopalan Nadathur*

Main category: cs.LO

TL;DR: 本文扩展了Tiu关于地面分层的工作，将其应用于包含归纳定义的Abella证明助手的逻辑中，但发现对于归纳定义，将分层弱化为地面分层会导致不一致性。


<details>
  <summary>Details</summary>
Motivation: Abella证明助手的原始逻辑包含严格的分层条件，这在使用逻辑关系方法进行语义等价性证明时过于严格。Tiu提出了较弱的地面分层概念，但仅限于无归纳定义的逻辑版本。

Method: 使用先前在此背景下部署的技术，将地面分层扩展到包含归纳定义的逻辑中，但发现对于归纳定义需要保持严格分层以避免不一致性。

Result: 成功将地面分层扩展到包含归纳定义的逻辑中，但证明对于归纳定义，弱化为地面分层会导致逻辑不一致性。

Conclusion: 虽然地面分层可用于任意固定点定义，但对于归纳定义必须保持严格分层。这为在包含共归纳、泛化量化和名义抽象的完整Abella逻辑中构建更灵活的定义形式提供了中间步骤。

Abstract: The logic underlying the Abella proof assistant includes mechanisms for
interpreting atomic predicates through fixed point definitions that can
additionally be treated inductively or co-inductively. However, the original
formulation of the logic includes a strict stratification condition on
definitions that is too restrictive for some applications such as those that
use a logical relations based approach to semantic equivalence. Tiu has shown
how this restriction can be eased by utilizing a weaker notion referred to as
ground stratification. Tiu's results were limited to a version of the logic
that does not treat inductive definitions. We show here that they can be
extended to cover such definitions. While our results are obtained by using
techniques that have been previously deployed in related ways in this context,
their use is sensitive to the particular way in which we generalize the logic.
In particular, although ground stratification may be used with arbitrary
fixed-point definitions, we show that weakening stratification to this form for
inductive definitions leads to inconsistency. The particular generalization we
describe accords well with the way logical relations are used in practice. Our
results are also a intermediate step to building a more flexible form for
definitions into the full logic underlying Abella, which additionally includes
co-induction, generic quantification, and a mechanism referred to as nominal
abstraction for analyzing occurrences of objects in terms that are governed by
generic quantifiers.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [7] [Beyond Postconditions: Can Large Language Models infer Formal Contracts for Automatic Software Verification?](https://arxiv.org/abs/2510.12702)
*Cedric Richter,Heike Wehrheim*

Main category: cs.SE

TL;DR: NL2Contract任务利用LLM将自然语言转换为形式化功能契约（包含前置条件和后置条件），相比仅生成后置条件，能显著减少自动验证器产生的误报。


<details>
  <summary>Details</summary>
Motivation: 解决自动软件验证中缺乏形式化规范的问题，以及仅使用LLM生成后置条件时验证器会产生大量误报的局限性。

Method: 引入NL2Contract任务，使用LLM从代码中的自然语言提示（如函数名、注释）推断完整的功能契约（前置条件+后置条件），并定义验证指标。

Result: LLM能有效生成对所有可能输入都健全的功能契约，这些契约具有足够的表达能力来区分错误和正确行为，且使用完整契约时验证器产生的误报比仅使用后置条件时更少。

Conclusion: LLM推断的前置条件与开发者意图高度一致，使得自动软件验证器能够捕获真实世界的bug，NL2Contract方法在软件验证中具有实用价值。

Abstract: Automatic software verifiers have become increasingly effective at the task
of checking software against (formal) specifications. Yet, their adoption in
practice has been hampered by the lack of such specifications in real world
code. Large Language Models (LLMs) have shown promise in inferring formal
postconditions from natural language hints embedded in code such as function
names, comments or documentation. Using the generated postconditions as
specifications in a subsequent verification, however, often leads verifiers to
suggest invalid inputs, hinting at potential issues that ultimately turn out to
be false alarms.
  To address this, we revisit the problem of specification inference from
natural language in the context of automatic software verification. In the
process, we introduce NL2Contract, the task of employing LLMs to translate
informal natural language into formal functional contracts, consisting of
postconditions as well as preconditions. We introduce metrics to validate and
compare different NL2Contract approaches, using soundness, bug discriminative
power of the generated contracts and their usability in the context of
automatic software verification as key metrics. We evaluate NL2Contract with
different LLMs and compare it to the task of postcondition generation
nl2postcond. Our evaluation shows that (1) LLMs are generally effective at
generating functional contracts sound for all possible inputs, (2) the
generated contracts are sufficiently expressive for discriminating buggy from
correct behavior, and (3) verifiers supplied with LLM inferred functional
contracts produce fewer false alarms than when provided with postconditions
alone. Further investigations show that LLM inferred preconditions generally
align well with developers intentions which allows us to use automatic software
verifiers to catch real-world bugs.

</details>


<div id='cs.AI'></div>

# cs.AI [[Back]](#toc)

### [8] [Tensor Logic: The Language of AI](https://arxiv.org/abs/2510.12269)
*Pedro Domingos*

Main category: cs.AI

TL;DR: 提出张量逻辑语言，统一神经AI和符号AI，通过张量方程作为唯一构造，将逻辑规则与爱因斯坦求和统一起来。


<details>
  <summary>Details</summary>
Motivation: 当前AI发展缺乏具备所有必要特性的编程语言，PyTorch/TensorFlow缺乏自动推理和知识获取支持，而LISP/Prolog缺乏可扩展性和学习支持。

Method: 基于张量方程构建张量逻辑语言，将逻辑规则和爱因斯坦求和视为相同操作，实现神经、符号和统计AI的统一表示。

Result: 优雅实现了transformer、形式推理、核机器和图模型等关键AI形式，支持嵌入空间中的可靠推理。

Conclusion: 张量逻辑结合了神经网络的可扩展性和可学习性与符号推理的可靠性和透明性，为AI的广泛应用提供了基础。

Abstract: Progress in AI is hindered by the lack of a programming language with all the
requisite features. Libraries like PyTorch and TensorFlow provide automatic
differentiation and efficient GPU implementation, but are additions to Python,
which was never intended for AI. Their lack of support for automated reasoning
and knowledge acquisition has led to a long and costly series of hacky attempts
to tack them on. On the other hand, AI languages like LISP an Prolog lack
scalability and support for learning. This paper proposes tensor logic, a
language that solves these problems by unifying neural and symbolic AI at a
fundamental level. The sole construct in tensor logic is the tensor equation,
based on the observation that logical rules and Einstein summation are
essentially the same operation, and all else can be reduced to them. I show how
to elegantly implement key forms of neural, symbolic and statistical AI in
tensor logic, including transformers, formal reasoning, kernel machines and
graphical models. Most importantly, tensor logic makes new directions possible,
such as sound reasoning in embedding space. This combines the scalability and
learnability of neural networks with the reliability and transparency of
symbolic reasoning, and is potentially a basis for the wider adoption of AI.

</details>
