<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 4]
- [cs.SE](#cs.SE) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Imperative Quantum Programming with Ownership and Borrowing in Guppy](https://arxiv.org/abs/2510.13082)
*Mark Koch,Agustín Borgna,Craig Roy,Alan Lawrence,Kartik Singhal,Seyon Sivarajah,Ross Duncan*

Main category: cs.PL

TL;DR: 开发结合线性类型和命令式语义的量子类型系统，已在Guppy编程语言中实现


<details>
  <summary>Details</summary>
Motivation: 线性类型在函数式量子编程中强制执行无克隆和无删除定理，但在命令式量子编程中未获广泛采用

Method: 开发结合人体工程学线性类型和命令式语义的量子类型系统，保持安全保证

Result: 所有想法已在Quantinuum的Guppy编程语言中实现

Conclusion: 成功开发了结合线性类型和命令式语义的量子类型系统

Abstract: Linear types enforce no-cloning and no-deleting theorems in functional
quantum programming. However, in imperative quantum programming, they have not
gained widespread adoption. This work aims to develop a quantum type system
that combines ergonomic linear typing with imperative semantics and maintains
safety guarantees. All ideas presented here have been implemented in
Quantinuum's Guppy programming language.

</details>


### [2] [Extensibility in Programming Languages: An overview](https://arxiv.org/abs/2510.13236)
*Sebastian mateos Nicolajsen*

Main category: cs.PL

TL;DR: 本文探讨编程语言可扩展性，分析宏、模块、类型和反射等关键主题，强调参数化和一等公民行为等跨主题特性，旨在启发未来语言设计者重视可扩展性。


<details>
  <summary>Details</summary>
Motivation: 作者在调查编程语言时发现缺乏对可扩展性组件的全面概述，希望通过文献综述填补这一空白，为编程语言设计者提供指导。

Method: 通过文献综述方法，识别和分析编程语言可扩展性的关键主题（宏、模块、类型、反射）以及跨主题属性（参数化、一等公民行为）。

Result: 确定了编程语言可扩展性的四个核心主题及其相互关系，揭示了自定义性和灵活性在语言构造中的重要性。

Conclusion: 本文为编程语言可扩展性研究提供了系统框架，鼓励未来语言设计者批判性地评估和考虑其设计的可扩展性。

Abstract: I here conduct an exploration of programming language extensibility, making
an argument for an often overlooked component of conventional language design.
Now, this is not a technical detailing of these components, rather, I attempt
to provide an overview as I myself have lacked during my time investigating
programming languages. Thus, read this as an introduction to the magical world
of extensibility. Through a literature review, I identify key extensibility
themes - Macros, Modules, Types, and Reflection - highlighting diverse
strategies for fostering extensibility. The analysis extends to cross-theme
properties such as Parametricism and First-class citizen behaviour, introducing
layers of complexity by highlighting the importance of customizability and
flexibility in programming language constructs. By outlining these facets of
existing programming languages and research, I aim to inspire future language
designers to assess and consider the extensibility of their creations
critically.

</details>


### [3] [Fast Trigonometric Functions using the RLIBM Approach](https://arxiv.org/abs/2510.13426)
*Sehyeok Park,Santosh Nagarakatte*

Main category: cs.PL

TL;DR: 开发三角函数的多项式近似方法，使用RLIBM方法为多种表示形式和舍入模式生成正确舍入结果。关键挑战在于使用π进行范围缩减，需要高精度π值以避免误差放大。


<details>
  <summary>Details</summary>
Motivation: 三角函数范围缩减过程中，π值的舍入误差会被放大，导致错误结果。需要开发快速且精确的范围缩减技术来处理32位浮点输入。

Method: 使用RLIBM方法开发多项式近似，实现快速范围缩减技术，在浮点和整数计算中保持π的高精度位数。

Result: 实现了快速的三角函数实现，能够为所有32位及以下输入生成正确舍入结果，且单一实现支持多种表示形式。

Conclusion: 通过高精度π值范围和快速缩减技术，成功开发出高效且精确的三角函数实现，解决了范围缩减中的误差放大问题。

Abstract: This paper describes our experience developing polynomial approximations for
trigonometric functions that produce correctly rounded results for multiple
representations and rounding modes using the RLIBM approach. A key challenge
with trigonometric functions concerns range reduction with "pi", which reduces
a given input in the domain of a 32-bit float to a small domain. Any rounding
error in the value of "pi" is amplified during range reduction, which can
result in wrong results. We describe our experience implementing fast range
reduction techniques that maintain a large number of bits of "pi" both with
floating-point and integer computations. The resulting implementations for
trigonometric functions are fast and produce correctly rounded results for all
inputs for multiple representations up to 32-bits with a single implementation.

</details>


### [4] [A Complementary Approach to Incorrectness Typing](https://arxiv.org/abs/2510.13725)
*Celia Mengyue Li,Sophie Pull,Steven Ramsay*

Main category: cs.PL

TL;DR: 提出了一种新的双面类型系统，用于验证带有原子和模式匹配的函数式程序的正确性和不正确性，通过类型补集操作符实现否定推理。


<details>
  <summary>Details</summary>
Motivation: 传统类型系统主要关注程序正确性验证，但缺乏有效验证程序错误行为的方法。需要一种能够同时验证程序正确性和不正确性的类型系统。

Method: 使用基于正规形式集合的类型系统，引入类型补集操作符作为类型公式的否定，通过子类型关系对补集操作符进行可判定的公理化。

Result: 系统能够推导广泛的否定原则，包括类型论中的共蕴涵，并成功验证多个类Erlang程序的错误行为。类型系统的可判定性和完备性得到证明。

Conclusion: 该双面类型系统不仅对正规形式是完备的，还能有效验证程序的不正确性，为程序验证提供了更全面的方法。

Abstract: We introduce a new two-sided type system for verifying the correctness and
incorrectness of functional programs with atoms and pattern matching. A key
idea in the work is that types should range over sets of normal forms, rather
than sets of values, and this allows us to define a complement operator on
types that acts as a negation on typing formulas. We show that the complement
allows us to derive a wide range of refutation principles within the system,
including the type-theoretic analogue of co-implication, and we use them to
certify that a number of Erlang-like programs go wrong. An expressive
axiomatisation of the complement operator via subtyping is shown decidable, and
the type system as a whole is shown to be not only sound, but also complete for
normal forms.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [5] [AutoCode: LLMs as Problem Setters for Competitive Programming](https://arxiv.org/abs/2510.12803)
*Shang Zhou,Zihan Zheng,Kaiyuan Liu,Zeyu Shen,Zerui Cheng,Zexing Chen,Hansen He,Jianzhu Yao,Huanzhi Mao,Qiuyang Mang,Tianfu Fu,Beichen Li,Dongruixuan Li,Wenhao Chai,Zhuang Liu,Aleksandra Korolova,Peter Henderson,Natasha Jaques,Pramod Viswanath,Saining Xie,Jingbo Shang*

Main category: cs.SE

TL;DR: AutoCode是一个自动生成竞赛级编程题目的系统，通过多轮验证生成高质量的问题描述和测试用例，在保留问题上达到99%的与官方判断一致性，并能创建新颖的题目变体。


<details>
  <summary>Details</summary>
Motivation: 编写竞赛编程题目需要精确设置约束条件、输入分布和边界情况，排除捷径，针对特定算法，并校准超出大多数参赛者能力的复杂度。这成为测试大型语言模型通用能力的理想场景。

Method: AutoCode使用多轮验证来生成竞赛级问题描述和测试用例。系统从随机种子问题开始创建新颖变体，并提供参考和暴力解决方案。通过交叉验证这些生成的解决方案与测试用例，进一步过滤掉格式错误的问题。

Result: 在保留问题上，AutoCode测试套件与官方判断的一致性接近99%，显著优于当前最先进方法HardTests（低于81%）。系统成功生成了被顶级程序员（前0.3%）评为具有竞赛质量的新颖问题。

Conclusion: AutoCode系统通过多轮验证和交叉验证确保了高正确性，能够可靠地生成竞赛级编程题目，验证了大型语言模型在此任务上的能力。

Abstract: Writing competitive programming problems is exacting. Authors must: set
constraints, input distributions, and edge cases that rule out shortcuts;
target specific algorithms (e.g., max-flow, dynamic programming, data
structures); and calibrate complexity beyond the reach of most competitors. We
argue that this makes for an ideal test of general large language model
capabilities and study whether they can do this reliably. We introduce
AutoCode, which uses multiple rounds of validation to yield competition-grade
problem statements and test cases. On held-out problems, AutoCode test suites
approach 99% consistency with official judgments, a significant improvement
over current state-of-the-art methods like HardTests, which achieve less than
81%. Furthermore, starting with a random seed problem, AutoCode can create
novel variants with reference and brute-force solutions. By cross-verifying
these generated solutions against test cases, we can further filter out
malformed problems. Our system ensures high correctness, as verified by human
experts. AutoCode successfully produces novel problems judged by
Grandmaster-level (top 0.3%) competitive programmers to be of contest quality.

</details>
