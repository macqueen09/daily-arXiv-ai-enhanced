{"id": "2510.14558", "pdf": "https://arxiv.org/pdf/2510.14558", "abs": "https://arxiv.org/abs/2510.14558", "authors": ["Amir Mohammad Fadaei Ayyam", "Michael Sammler"], "title": "HITrees: Higher-Order Interaction Trees", "categories": ["cs.PL"], "comment": null, "summary": "Recent years have witnessed the rise of compositional semantics as a\nfoundation for formal verification of complex systems. In particular,\ninteraction trees have emerged as a popular denotational semantics. Interaction\ntrees achieve compositionality by providing a reusable library of effects.\nHowever, their notion of effects does not support higher-order effects, i.e.,\neffects that take or return monadic computations. Such effects are essential to\nmodel complex semantic features like parallel composition and call/cc.\n  We introduce Higher-Order Interaction Trees (HITrees), the first variant of\ninteraction trees to support higher-order effects in a non-guarded type theory.\nHITrees accomplish this through two key techniques: first, by designing the\nnotion of effects such that the fixpoints of effects with higher-order input\ncan be expressed as inductive types inside the type theory; and second, using\ndefunctionalization to encode higher-order outputs into a first-order\nrepresentation. We implement HITrees in the Lean proof assistant, accompanied\nby a comprehensive library of effects including concurrency, recursion, and\ncall/cc. Furthermore, we provide two interpretations of HITrees, as state\ntransition systems and as monadic programs. To demonstrate the expressiveness\nof HITrees, we apply them to define the semantics of a language with parallel\ncomposition and call/cc.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u9ad8\u9636\u4ea4\u4e92\u6811\uff08HITrees\uff09\uff0c\u8fd9\u662f\u7b2c\u4e00\u4e2a\u5728\u975e\u5b88\u536b\u7c7b\u578b\u7406\u8bba\u4e2d\u652f\u6301\u9ad8\u9636\u6548\u5e94\u7684\u4ea4\u4e92\u6811\u53d8\u4f53\uff0c\u901a\u8fc7\u4e24\u79cd\u5173\u952e\u6280\u672f\u5b9e\u73b0\uff1a\u8bbe\u8ba1\u6548\u5e94\u6982\u5ff5\u4ee5\u8868\u8fbe\u9ad8\u9636\u8f93\u5165\u7684\u56fa\u5b9a\u70b9\u4f5c\u4e3a\u5f52\u7eb3\u7c7b\u578b\uff0c\u4ee5\u53ca\u4f7f\u7528\u53bb\u51fd\u6570\u5316\u7f16\u7801\u9ad8\u9636\u8f93\u51fa\u4e3a\u4e00\u9636\u8868\u793a\u3002", "motivation": "\u73b0\u6709\u4ea4\u4e92\u6811\u867d\u7136\u63d0\u4f9b\u4e86\u53ef\u91cd\u7528\u7684\u6548\u5e94\u5e93\u5b9e\u73b0\u7ec4\u5408\u8bed\u4e49\uff0c\u4f46\u5176\u6548\u5e94\u6982\u5ff5\u4e0d\u652f\u6301\u9ad8\u9636\u6548\u5e94\uff08\u5373\u63a5\u53d7\u6216\u8fd4\u56de\u5355\u5b50\u8ba1\u7b97\u7684\u6548\u5e94\uff09\uff0c\u800c\u8fd9\u4e9b\u6548\u5e94\u5bf9\u4e8e\u5efa\u6a21\u5e76\u884c\u7ec4\u5408\u548ccall/cc\u7b49\u590d\u6742\u8bed\u4e49\u7279\u6027\u81f3\u5173\u91cd\u8981\u3002", "method": "1. \u8bbe\u8ba1\u6548\u5e94\u6982\u5ff5\u4f7f\u5f97\u9ad8\u9636\u8f93\u5165\u6548\u5e94\u7684\u56fa\u5b9a\u70b9\u53ef\u4ee5\u5728\u7c7b\u578b\u7406\u8bba\u4e2d\u8868\u793a\u4e3a\u5f52\u7eb3\u7c7b\u578b\uff1b2. \u4f7f\u7528\u53bb\u51fd\u6570\u5316\u6280\u672f\u5c06\u9ad8\u9636\u8f93\u51fa\u7f16\u7801\u4e3a\u4e00\u9636\u8868\u793a\uff1b3. \u5728Lean\u8bc1\u660e\u52a9\u624b\u4e2d\u5b9e\u73b0HITrees\uff0c\u5e76\u6784\u5efa\u5305\u542b\u5e76\u53d1\u3001\u9012\u5f52\u548ccall/cc\u7b49\u6548\u5e94\u7684\u7efc\u5408\u5e93\uff1b4. \u63d0\u4f9bHITrees\u7684\u4e24\u79cd\u89e3\u91ca\uff1a\u72b6\u6001\u8f6c\u6362\u7cfb\u7edf\u548c\u5355\u5b50\u7a0b\u5e8f\u3002", "result": "\u6210\u529f\u5b9e\u73b0\u4e86\u652f\u6301\u9ad8\u9636\u6548\u5e94\u7684\u4ea4\u4e92\u6811\u53d8\u4f53HITrees\uff0c\u80fd\u591f\u8868\u8fbe\u5e76\u884c\u7ec4\u5408\u548ccall/cc\u7b49\u590d\u6742\u8bed\u4e49\u7279\u6027\uff0c\u4e3a\u590d\u6742\u7cfb\u7edf\u7684\u5f62\u5f0f\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u66f4\u5f3a\u5927\u7684\u7ec4\u5408\u8bed\u4e49\u57fa\u7840\u3002", "conclusion": "HITrees\u662f\u7b2c\u4e00\u4e2a\u5728\u975e\u5b88\u536b\u7c7b\u578b\u7406\u8bba\u4e2d\u652f\u6301\u9ad8\u9636\u6548\u5e94\u7684\u4ea4\u4e92\u6811\u53d8\u4f53\uff0c\u901a\u8fc7\u521b\u65b0\u7684\u6280\u672f\u65b9\u6cd5\u89e3\u51b3\u4e86\u73b0\u6709\u4ea4\u4e92\u6811\u5728\u9ad8\u9636\u6548\u5e94\u652f\u6301\u65b9\u9762\u7684\u5c40\u9650\u6027\uff0c\u4e3a\u5efa\u6a21\u590d\u6742\u8bed\u4e49\u7279\u6027\u63d0\u4f9b\u4e86\u66f4\u5f3a\u5927\u7684\u5de5\u5177\u3002"}}
{"id": "2510.14279", "pdf": "https://arxiv.org/pdf/2510.14279", "abs": "https://arxiv.org/abs/2510.14279", "authors": ["Evangelos Lamprou", "Seong-Heon Jung", "Mayank Keoliya", "Lukas Lazarek", "Konstantinos Kallas", "Michael Greenberg", "Nikos Vasilakis"], "title": "Caruca: Effective and Efficient Specification Mining for Opaque Software Components", "categories": ["cs.SE", "cs.PL"], "comment": null, "summary": "A wealth of state-of-the-art systems demonstrate impressive improvements in\nperformance, security, and reliability on programs composed of opaque\ncomponents, such as Unix shell commands. To reason about commands, these\nsystems require partial specifications. However, creating such specifications\nis a manual, laborious, and error-prone process, limiting the practicality of\nthese systems. This paper presents Caruca, a system for automatic specification\nmining for opaque commands. To overcome the challenge of language diversity\nacross commands, Caruca first instruments a large language model to translate a\ncommand's user-facing documentation into a structured invocation syntax. Using\nthis representation, Caruca explores the space of syntactically valid command\ninvocations and execution environments. Caruca concretely executes each\ncommand-environment pair, interposing at the system-call and filesystem level\nto extract key command properties such as parallelizability and filesystem pre-\nand post-conditions. These properties can be exported in multiple specification\nformats and are immediately usable by existing systems. Applying Caruca across\n60 GNU Coreutils, POSIX, and third-party commands across several\nspecification-dependent systems shows that Caruca generates correct\nspecifications for all but one case, completely eliminating manual effort from\nthe process and currently powering the full specifications for a\nstate-of-the-art static analysis tool.", "AI": {"tldr": "Caruca\u662f\u4e00\u4e2a\u81ea\u52a8\u5316\u89c4\u8303\u6316\u6398\u7cfb\u7edf\uff0c\u80fd\u591f\u4ece\u547d\u4ee4\u7684\u7528\u6237\u6587\u6863\u4e2d\u81ea\u52a8\u751f\u6210\u89c4\u8303\uff0c\u6d88\u9664\u624b\u52a8\u521b\u5efa\u89c4\u8303\u7684\u9700\u6c42\u3002", "motivation": "\u73b0\u6709\u7cfb\u7edf\u9700\u8981\u624b\u52a8\u521b\u5efa\u90e8\u5206\u89c4\u8303\u6765\u63a8\u7406\u4e0d\u900f\u660e\u7ec4\u4ef6\uff08\u5982Unix shell\u547d\u4ee4\uff09\uff0c\u4f46\u624b\u52a8\u521b\u5efa\u8fc7\u7a0b\u7e41\u7410\u3001\u6613\u9519\uff0c\u9650\u5236\u4e86\u8fd9\u4e9b\u7cfb\u7edf\u7684\u5b9e\u7528\u6027\u3002", "method": "Caruca\u9996\u5148\u4f7f\u7528\u5927\u8bed\u8a00\u6a21\u578b\u5c06\u547d\u4ee4\u6587\u6863\u8f6c\u6362\u4e3a\u7ed3\u6784\u5316\u8c03\u7528\u8bed\u6cd5\uff0c\u7136\u540e\u63a2\u7d22\u8bed\u6cd5\u6709\u6548\u7684\u547d\u4ee4\u8c03\u7528\u548c\u6267\u884c\u73af\u5883\u7a7a\u95f4\uff0c\u901a\u8fc7\u7cfb\u7edf\u8c03\u7528\u548c\u6587\u4ef6\u7cfb\u7edf\u7ea7\u522b\u7684\u62e6\u622a\u6765\u63d0\u53d6\u5173\u952e\u547d\u4ee4\u5c5e\u6027\u3002", "result": "\u572860\u4e2aGNU Coreutils\u3001POSIX\u548c\u7b2c\u4e09\u65b9\u547d\u4ee4\u4e0a\u7684\u5e94\u7528\u8868\u660e\uff0cCaruca\u4e3a\u9664\u4e00\u4e2a\u6848\u4f8b\u5916\u7684\u6240\u6709\u60c5\u51b5\u751f\u6210\u4e86\u6b63\u786e\u89c4\u8303\uff0c\u5b8c\u5168\u6d88\u9664\u4e86\u624b\u52a8\u5de5\u4f5c\uff0c\u5e76\u4e3a\u6700\u5148\u8fdb\u7684\u9759\u6001\u5206\u6790\u5de5\u5177\u63d0\u4f9b\u4e86\u5b8c\u6574\u89c4\u8303\u3002", "conclusion": "Caruca\u6210\u529f\u5b9e\u73b0\u4e86\u547d\u4ee4\u89c4\u8303\u7684\u81ea\u52a8\u5316\u6316\u6398\uff0c\u663e\u8457\u63d0\u9ad8\u4e86\u89c4\u8303\u4f9d\u8d56\u7cfb\u7edf\u7684\u5b9e\u7528\u6027\u3002"}}
{"id": "2510.14719", "pdf": "https://arxiv.org/pdf/2510.14719", "abs": "https://arxiv.org/abs/2510.14719", "authors": ["Hongzheng Chen", "Bin Fan", "Alexander Collins", "Bastian Hagedorn", "Evghenii Gaburov", "Masahiro Masuda", "Matthew Brookhart", "Chris Sullivan", "Jason Knight", "Zhiru Zhang", "Vinod Grover"], "title": "Tawa: Automatic Warp Specialization for Modern GPUs with Asynchronous References", "categories": ["cs.LG", "cs.AR", "cs.PL"], "comment": null, "summary": "Modern GPUs feature specialized hardware units that enable high-performance,\nasynchronous dataflow execution. However, the conventional SIMT programming\nmodel is fundamentally misaligned with this task-parallel hardware, creating a\nsignificant programmability gap. While hardware-level warp specialization is\nthe key to unlocking peak performance, it forces developers to manually\norchestrate complex, low-level communication and software pipelines--a process\nthat is labor-intensive, error-prone, and unsustainable. To address this\nchallenge, we present Tawa, an automated compiler that systematically generates\nhigh-performance, warp-specialized code from a high-level, tile-based program.\nCentral to our approach is a novel IR abstraction, asynchronous references\n(aref), which expresses warp-level communication without exposing low-level\nhardware details. Using this abstraction, Tawa automatically partitions\nprograms into producer-consumer roles and manages the intricate dataflow\npipeline, relieving developers of invasive kernel rewriting. Evaluation on\nNVIDIA H100 GPUs across representative LLM kernels shows that Tawa delivers\nhigh hardware utilization, achieving up to 1.1$\\times$ speedup over highly\noptimized cuBLAS GEMM kernels. For attention workloads, Tawa attains\n1.2$\\times$ speedup over Triton and matches the performance of the\nhand-optimized CUTLASS C++ FlashAttention-3 kernel with far less programming\neffort.", "AI": {"tldr": "Tawa\u662f\u4e00\u4e2a\u81ea\u52a8\u5316\u7f16\u8bd1\u5668\uff0c\u80fd\u4ece\u9ad8\u7ea7\u74e6\u7247\u5316\u7a0b\u5e8f\u81ea\u52a8\u751f\u6210\u9ad8\u6027\u80fd\u7684warp\u4e13\u7528\u4ee3\u7801\uff0c\u89e3\u51b3\u4e86GPU SIMT\u7f16\u7a0b\u6a21\u578b\u4e0e\u4efb\u52a1\u5e76\u884c\u786c\u4ef6\u4e4b\u95f4\u7684\u4e0d\u5339\u914d\u95ee\u9898\u3002", "motivation": "\u73b0\u4ee3GPU\u5177\u6709\u4e13\u95e8\u7684\u786c\u4ef6\u5355\u5143\u652f\u6301\u9ad8\u6027\u80fd\u5f02\u6b65\u6570\u636e\u6d41\u6267\u884c\uff0c\u4f46\u4f20\u7edf\u7684SIMT\u7f16\u7a0b\u6a21\u578b\u4e0e\u8fd9\u79cd\u4efb\u52a1\u5e76\u884c\u786c\u4ef6\u4e0d\u5339\u914d\uff0c\u5bfc\u81f4\u7f16\u7a0b\u56f0\u96be\u3002\u786c\u4ef6\u7ea7\u7684warp\u4e13\u7528\u5316\u867d\u7136\u80fd\u89e3\u9501\u5cf0\u503c\u6027\u80fd\uff0c\u4f46\u9700\u8981\u5f00\u53d1\u8005\u624b\u52a8\u7ba1\u7406\u590d\u6742\u7684\u4f4e\u5c42\u901a\u4fe1\u548c\u8f6f\u4ef6\u6d41\u6c34\u7ebf\uff0c\u5de5\u4f5c\u91cf\u5927\u4e14\u5bb9\u6613\u51fa\u9519\u3002", "method": "\u63d0\u51fa\u4e86Tawa\u7f16\u8bd1\u5668\uff0c\u6838\u5fc3\u662f\u65b0\u9896\u7684IR\u62bd\u8c61\u2014\u2014\u5f02\u6b65\u5f15\u7528(aref)\uff0c\u80fd\u5728\u4e0d\u66b4\u9732\u4f4e\u5c42\u786c\u4ef6\u7ec6\u8282\u7684\u60c5\u51b5\u4e0b\u8868\u8fbewarp\u7ea7\u901a\u4fe1\u3002\u4f7f\u7528\u8fd9\u79cd\u62bd\u8c61\uff0cTawa\u81ea\u52a8\u5c06\u7a0b\u5e8f\u5212\u5206\u4e3a\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u89d2\u8272\uff0c\u5e76\u7ba1\u7406\u590d\u6742\u7684\u6570\u636e\u6d41\u6d41\u6c34\u7ebf\u3002", "result": "\u5728NVIDIA H100 GPU\u4e0a\u7684\u8bc4\u4f30\u663e\u793a\uff0cTawa\u5b9e\u73b0\u4e86\u9ad8\u786c\u4ef6\u5229\u7528\u7387\uff0c\u5728\u4ee3\u8868\u6027LLM\u5185\u6838\u4e0a\u6bd4\u9ad8\u5ea6\u4f18\u5316\u7684cuBLAS GEMM\u5185\u6838\u5feb1.1\u500d\u3002\u5bf9\u4e8e\u6ce8\u610f\u529b\u5de5\u4f5c\u8d1f\u8f7d\uff0c\u6bd4Triton\u5feb1.2\u500d\uff0c\u4e14\u4e0e\u624b\u5de5\u4f18\u5316\u7684CUTLASS C++ FlashAttention-3\u5185\u6838\u6027\u80fd\u76f8\u5f53\uff0c\u4f46\u7f16\u7a0b\u5de5\u4f5c\u91cf\u5927\u5e45\u51cf\u5c11\u3002", "conclusion": "Tawa\u901a\u8fc7\u81ea\u52a8\u5316warp\u4e13\u7528\u5316\u4ee3\u7801\u751f\u6210\uff0c\u663e\u8457\u964d\u4f4e\u4e86GPU\u7f16\u7a0b\u7684\u590d\u6742\u6027\uff0c\u540c\u65f6\u4fdd\u6301\u4e86\u9ad8\u6027\u80fd\uff0c\u4e3a\u89e3\u51b3GPU\u7f16\u7a0b\u6a21\u578b\u4e0e\u786c\u4ef6\u80fd\u529b\u4e4b\u95f4\u7684\u5dee\u8ddd\u63d0\u4f9b\u4e86\u6709\u6548\u65b9\u6848\u3002"}}
{"id": "2510.14972", "pdf": "https://arxiv.org/pdf/2510.14972", "abs": "https://arxiv.org/abs/2510.14972", "authors": ["Yinxi Li", "Yuntian Deng", "Pengyu Nie"], "title": "TokDrift: When LLM Speaks in Subwords but Code Speaks in Grammar", "categories": ["cs.CL", "cs.AI", "cs.LG", "cs.PL", "cs.SE"], "comment": null, "summary": "Large language models (LLMs) for code rely on subword tokenizers, such as\nbyte-pair encoding (BPE), learned from mixed natural language text and\nprogramming language code but driven by statistics rather than grammar. As a\nresult, semantically identical code snippets can be tokenized differently\ndepending on superficial factors such as whitespace or identifier naming. To\nmeasure the impact of this misalignment, we introduce TokDrift, a framework\nthat applies semantic-preserving rewrite rules to create code variants\ndiffering only in tokenization. Across nine code LLMs, including large ones\nwith over 30B parameters, even minor formatting changes can cause substantial\nshifts in model behavior. Layer-wise analysis shows that the issue originates\nin early embeddings, where subword segmentation fails to capture grammar token\nboundaries. Our findings identify misaligned tokenization as a hidden obstacle\nto reliable code understanding and generation, highlighting the need for\ngrammar-aware tokenization for future code LLMs.", "AI": {"tldr": "\u8bba\u6587\u63d0\u51fa\u4e86TokDrift\u6846\u67b6\uff0c\u53d1\u73b0\u4ee3\u7801LLMs\u5bf9\u8bed\u4e49\u76f8\u540c\u4f46\u683c\u5f0f\u4e0d\u540c\u7684\u4ee3\u7801\u4f1a\u4ea7\u751f\u4e0d\u540c\u7684token\u5316\u7ed3\u679c\uff0c\u5bfc\u81f4\u6a21\u578b\u884c\u4e3a\u663e\u8457\u53d8\u5316\uff0c\u8fd9\u63ed\u793a\u4e86\u5f53\u524d\u5b50\u8bcdtokenization\u5728\u4ee3\u7801\u7406\u89e3\u4e2d\u7684\u5c40\u9650\u6027\u3002", "motivation": "\u5f53\u524d\u4ee3\u7801LLMs\u4f7f\u7528\u7684\u5b50\u8bcdtokenizer\uff08\u5982BPE\uff09\u57fa\u4e8e\u7edf\u8ba1\u800c\u975e\u8bed\u6cd5\uff0c\u5bfc\u81f4\u8bed\u4e49\u76f8\u540c\u7684\u4ee3\u7801\u7247\u6bb5\u4f1a\u56e0\u683c\u5f0f\u5dee\u5f02\uff08\u5982\u7a7a\u683c\u3001\u6807\u8bc6\u7b26\u547d\u540d\uff09\u800c\u4ea7\u751f\u4e0d\u540c\u7684token\u5316\u7ed3\u679c\uff0c\u5f71\u54cd\u6a21\u578b\u53ef\u9760\u6027\u3002", "method": "\u5f15\u5165TokDrift\u6846\u67b6\uff0c\u5e94\u7528\u8bed\u4e49\u4fdd\u6301\u7684\u91cd\u5199\u89c4\u5219\u521b\u5efa\u4ec5\u5728tokenization\u4e0a\u4e0d\u540c\u7684\u4ee3\u7801\u53d8\u4f53\uff0c\u57289\u4e2a\u4ee3\u7801LLMs\uff08\u5305\u62ec\u8d85\u8fc7300\u4ebf\u53c2\u6570\u7684\u5927\u6a21\u578b\uff09\u4e0a\u8fdb\u884c\u6d4b\u8bd5\uff0c\u5e76\u8fdb\u884c\u5206\u5c42\u5206\u6790\u3002", "result": "\u5373\u4f7f\u5fae\u5c0f\u7684\u683c\u5f0f\u53d8\u5316\u4e5f\u4f1a\u5bfc\u81f4\u6a21\u578b\u884c\u4e3a\u663e\u8457\u53d8\u5316\uff0c\u5206\u5c42\u5206\u6790\u663e\u793a\u95ee\u9898\u6e90\u4e8e\u65e9\u671f\u5d4c\u5165\u5c42\uff0c\u5b50\u8bcd\u5206\u5272\u672a\u80fd\u6355\u83b7\u8bed\u6cd5token\u8fb9\u754c\u3002", "conclusion": "\u9519\u4f4d\u7684tokenization\u662f\u4ee3\u7801\u7406\u89e3\u548c\u751f\u6210\u53ef\u9760\u6027\u7684\u9690\u85cf\u969c\u788d\uff0c\u672a\u6765\u7684\u4ee3\u7801LLMs\u9700\u8981\u8bed\u6cd5\u611f\u77e5\u7684tokenization\u65b9\u6cd5\u3002"}}
