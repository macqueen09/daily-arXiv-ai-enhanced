{"id": "2510.17889", "pdf": "https://arxiv.org/pdf/2510.17889", "abs": "https://arxiv.org/abs/2510.17889", "authors": ["Eilene Tomkins-Flanagan", "Mary A. Kelly"], "title": "Hey Pentti, We Did It!: A Fully Vector-Symbolic Lisp", "categories": ["cs.PL", "cs.AI"], "comment": null, "summary": "Kanerva (2014) suggested that it would be possible to construct a complete\nLisp out of a vector-symbolic architecture. We present the general form of a\nvector-symbolic representation of the five Lisp elementary functions, lambda\nexpressions, and other auxiliary functions, found in the Lisp 1.5 specification\nMcCarthy (1960), which is near minimal and sufficient for Turing-completeness.\nOur specific implementation uses holographic reduced representations Plate\n(1995), with a lookup table cleanup memory. Lisp, as all Turing-complete\nlanguages, is a Cartesian closed category, unusual in its proximity to the\nmathematical abstraction. We discuss the mathematics, the purpose, and the\nsignificance of demonstrating vector-symbolic architectures' Cartesian-closure,\nas well as the importance of explicitly including cleanup memories in the\nspecification of the architecture.", "AI": {"tldr": "\u8be5\u8bba\u6587\u5c55\u793a\u4e86\u5982\u4f55\u5728\u5411\u91cf\u7b26\u53f7\u67b6\u6784\u4e2d\u5b9e\u73b0\u5b8c\u6574\u7684Lisp\u8bed\u8a00\uff0c\u5305\u62ec\u4e94\u4e2a\u57fa\u672c\u51fd\u6570\u3001lambda\u8868\u8fbe\u5f0f\u7b49\uff0c\u8bc1\u660e\u4e86\u5411\u91cf\u7b26\u53f7\u67b6\u6784\u7684\u7b1b\u5361\u5c14\u95ed\u5305\u6027\u8d28\u3002", "motivation": "\u9a8c\u8bc1Kanerva(2014)\u7684\u5047\u8bbe\uff0c\u5373\u53ef\u4ee5\u5728\u5411\u91cf\u7b26\u53f7\u67b6\u6784\u4e0a\u6784\u5efa\u5b8c\u6574\u7684Lisp\u8bed\u8a00\uff0c\u5e76\u63a2\u8ba8\u5411\u91cf\u7b26\u53f7\u67b6\u6784\u7684\u6570\u5b66\u6027\u8d28\u3002", "method": "\u4f7f\u7528\u5168\u606f\u7b80\u5316\u8868\u793a\u548c\u67e5\u627e\u8868\u6e05\u7406\u5185\u5b58\uff0c\u5b9e\u73b0\u4e86Lisp 1.5\u89c4\u8303\u4e2d\u7684\u4e94\u4e2a\u57fa\u672c\u51fd\u6570\u3001lambda\u8868\u8fbe\u5f0f\u7b49\u8f85\u52a9\u51fd\u6570\u3002", "result": "\u6210\u529f\u6784\u5efa\u4e86\u5411\u91cf\u7b26\u53f7\u8868\u793a\u7684Lisp\u5b9e\u73b0\uff0c\u8bc1\u660e\u4e86\u5411\u91cf\u7b26\u53f7\u67b6\u6784\u5177\u6709\u7b1b\u5361\u5c14\u95ed\u5305\u6027\u8d28\uff0c\u80fd\u591f\u652f\u6301\u56fe\u7075\u5b8c\u5907\u6027\u3002", "conclusion": "\u5411\u91cf\u7b26\u53f7\u67b6\u6784\u786e\u5b9e\u80fd\u591f\u5b9e\u73b0\u5b8c\u6574\u7684Lisp\u8bed\u8a00\uff0c\u8bc1\u660e\u4e86\u5176\u7b1b\u5361\u5c14\u95ed\u5305\u6027\u8d28\uff0c\u5e76\u5f3a\u8c03\u4e86\u6e05\u7406\u5185\u5b58\u5728\u67b6\u6784\u89c4\u8303\u4e2d\u7684\u91cd\u8981\u6027\u3002"}}
{"id": "2510.18479", "pdf": "https://arxiv.org/pdf/2510.18479", "abs": "https://arxiv.org/abs/2510.18479", "authors": ["Samuel Chassot", "Viktor Kun\u010dak"], "title": "ZipLex: Verified Invertible Lexing with Memoized Derivatives and Zippers", "categories": ["cs.PL", "cs.FL"], "comment": null, "summary": "We present ZipLex, a verified framework for invertible lexical analysis.\nUnlike past verified lexers that focus only on satisfying the semantics of\nregular expressions and the maximal munch property, ZipLex also guarantees that\nlexing and printing are mutual inverses. Our design relies on two sets of\nideas: (1) a new abstraction of token sequences that captures the separability\nof tokens in a sequence while supporting their efficient manipulation, and (2)\na combination of verified data structures and optimizations, including Huet's\nzippers and memoized derivatives, to achieve practical performance. We\nimplemented ZipLex in Scala and verified its correctness, including\ninvertibility, using the Stainless verifier. Our evaluation demonstrates that\nZipLex supports realistic applications such as JSON processing and lexers of\nprogramming languages. In comparison to other verified lexers (which do not\nenforce invertibility), ZipLex is 4x slower than Coqlex and two orders of\nmagnitude faster than Verbatim++, showing that verified invertibility can be\nachieved without prohibitive cost.", "AI": {"tldr": "ZipLex\u662f\u4e00\u4e2a\u7ecf\u8fc7\u9a8c\u8bc1\u7684\u53ef\u9006\u8bcd\u6cd5\u5206\u6790\u6846\u67b6\uff0c\u4e0d\u4ec5\u4fdd\u8bc1\u6b63\u5219\u8868\u8fbe\u5f0f\u8bed\u4e49\u548c\u6700\u5927\u5339\u914d\u5c5e\u6027\uff0c\u8fd8\u786e\u4fdd\u8bcd\u6cd5\u5206\u6790\u548c\u6253\u5370\u4e92\u4e3a\u9006\u64cd\u4f5c\u3002", "motivation": "\u73b0\u6709\u9a8c\u8bc1\u8bcd\u6cd5\u5206\u6790\u5668\u53ea\u5173\u6ce8\u6b63\u5219\u8868\u8fbe\u5f0f\u8bed\u4e49\u548c\u6700\u5927\u5339\u914d\u5c5e\u6027\uff0c\u4f46\u7f3a\u4e4f\u5bf9\u8bcd\u6cd5\u5206\u6790\u548c\u6253\u5370\u4e92\u4e3a\u9006\u64cd\u4f5c\u7684\u4fdd\u8bc1\u3002", "method": "\u91c7\u7528\u4e24\u79cd\u521b\u65b0\u8bbe\u8ba1\uff1a(1)\u65b0\u7684token\u5e8f\u5217\u62bd\u8c61\uff0c\u6355\u83b7\u5e8f\u5217\u4e2dtoken\u7684\u53ef\u5206\u79bb\u6027\u5e76\u652f\u6301\u9ad8\u6548\u64cd\u4f5c\uff1b(2)\u7ed3\u5408\u9a8c\u8bc1\u6570\u636e\u7ed3\u6784\uff08Huet\u7684zippers\uff09\u548c\u4f18\u5316\u6280\u672f\uff08\u8bb0\u5fc6\u5316\u5bfc\u6570\uff09\u5b9e\u73b0\u5b9e\u7528\u6027\u80fd\u3002", "result": "\u5728Scala\u4e2d\u5b9e\u73b0ZipLex\u5e76\u4f7f\u7528Stainless\u9a8c\u8bc1\u5668\u9a8c\u8bc1\u5176\u6b63\u786e\u6027\uff08\u5305\u62ec\u53ef\u9006\u6027\uff09\u3002\u8bc4\u4f30\u663e\u793aZipLex\u652f\u6301JSON\u5904\u7406\u548c\u7f16\u7a0b\u8bed\u8a00\u8bcd\u6cd5\u5206\u6790\u7b49\u5b9e\u9645\u5e94\u7528\uff0c\u4e0e\u5176\u4ed6\u9a8c\u8bc1\u8bcd\u6cd5\u5206\u6790\u5668\u76f8\u6bd4\uff0c\u6bd4Coqlex\u61624\u500d\uff0c\u4f46\u6bd4Verbatim++\u5feb\u4e24\u4e2a\u6570\u91cf\u7ea7\u3002", "conclusion": "\u9a8c\u8bc1\u53ef\u9006\u6027\u53ef\u4ee5\u5728\u4e0d\u4ed8\u51fa\u8fc7\u9ad8\u4ee3\u4ef7\u7684\u60c5\u51b5\u4e0b\u5b9e\u73b0\uff0cZipLex\u5728\u6027\u80fd\u548c\u53ef\u9006\u6027\u4fdd\u8bc1\u4e4b\u95f4\u53d6\u5f97\u4e86\u826f\u597d\u5e73\u8861\u3002"}}
{"id": "2510.18651", "pdf": "https://arxiv.org/pdf/2510.18651", "abs": "https://arxiv.org/abs/2510.18651", "authors": ["Uraz Odyurt", "\u00d6mer Sayilir", "Mari\u00eblle Stoelinga", "Vadim Zaytsev"], "title": "CPSLint: A Domain-Specific Language Providing Data Validation and Sanitisation for Industrial Cyber-Physical Systems", "categories": ["cs.PL", "cs.SE"], "comment": null, "summary": "Raw datasets are often too large and unstructured to work with directly, and\nrequire a data preparation process. The domain of industrial Cyber-Physical\nSystems (CPS) is no exception, as raw data typically consists of large amounts\nof time-series data logging the system's status in regular time intervals. Such\ndata has to be sanity checked and preprocessed to be consumable by data-centric\nworkflows. We introduce CPSLint, a Domain-Specific Language designed to provide\ndata preparation for industrial CPS. We build up on the fact that many raw data\ncollections in the CPS domain require similar actions to render them suitable\nfor Machine-Learning (ML) solutions, e.g., Fault Detection and Identification\n(FDI) workflows, yet still vary enough to hope for one universally applicable\nsolution.\n  CPSLint's main features include type checking and enforcing constraints\nthrough validation and remediation for data columns, such as imputing missing\ndata from surrounding rows. More advanced features cover inference of extra\nCPS-specific data structures, both column-wise and row-wise. For instance, as\nrow-wise structures, descriptive execution phases are an effective method of\ndata compartmentalisation are extracted and prepared for ML-assisted FDI\nworkflows. We demonstrate CPSLint's features through a proof of concept\nimplementation.", "AI": {"tldr": "CPSLint\u662f\u4e00\u79cd\u9886\u57df\u7279\u5b9a\u8bed\u8a00\uff0c\u4e13\u95e8\u4e3a\u5de5\u4e1a\u4fe1\u606f\u7269\u7406\u7cfb\u7edf(CPS)\u7684\u6570\u636e\u9884\u5904\u7406\u8bbe\u8ba1\uff0c\u63d0\u4f9b\u7c7b\u578b\u68c0\u67e5\u3001\u7ea6\u675f\u9a8c\u8bc1\u548c\u4fee\u590d\u529f\u80fd\uff0c\u652f\u6301\u673a\u5668\u5b66\u4e60\u5de5\u4f5c\u6d41\u7684\u6570\u636e\u51c6\u5907\u3002", "motivation": "\u5de5\u4e1aCPS\u4ea7\u751f\u7684\u539f\u59cb\u65f6\u95f4\u5e8f\u5217\u6570\u636e\u901a\u5e38\u5e9e\u5927\u4e14\u975e\u7ed3\u6784\u5316\uff0c\u9700\u8981\u8fdb\u884c\u6570\u636e\u9884\u5904\u7406\u624d\u80fd\u7528\u4e8e\u673a\u5668\u5b66\u4e60\u89e3\u51b3\u65b9\u6848\uff0c\u5982\u6545\u969c\u68c0\u6d4b\u548c\u8bc6\u522b\u5de5\u4f5c\u6d41\u3002", "method": "\u5f00\u53d1\u4e86CPSLint\u9886\u57df\u7279\u5b9a\u8bed\u8a00\uff0c\u63d0\u4f9b\u7c7b\u578b\u68c0\u67e5\u3001\u7ea6\u675f\u9a8c\u8bc1\u548c\u4fee\u590d\u529f\u80fd\uff0c\u5305\u62ec\u7f3a\u5931\u6570\u636e\u63d2\u8865\u3001CPS\u7279\u5b9a\u6570\u636e\u7ed3\u6784\u63a8\u65ad\u7b49\u9ad8\u7ea7\u7279\u6027\u3002", "result": "\u901a\u8fc7\u6982\u5ff5\u9a8c\u8bc1\u5b9e\u73b0\u5c55\u793a\u4e86CPSLint\u7684\u529f\u80fd\uff0c\u80fd\u591f\u6709\u6548\u63d0\u53d6\u548c\u51c6\u5907\u63cf\u8ff0\u6027\u6267\u884c\u9636\u6bb5\u7b49\u884c\u7ea7\u6570\u636e\u7ed3\u6784\uff0c\u7528\u4e8eML\u8f85\u52a9\u7684FDI\u5de5\u4f5c\u6d41\u3002", "conclusion": "CPSLint\u4e3a\u5de5\u4e1aCPS\u6570\u636e\u9884\u5904\u7406\u63d0\u4f9b\u4e86\u4e00\u79cd\u6709\u6548\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u80fd\u591f\u5904\u7406\u76f8\u4f3c\u4f46\u5b58\u5728\u5dee\u5f02\u7684\u6570\u636e\u51c6\u5907\u9700\u6c42\uff0c\u652f\u6301\u673a\u5668\u5b66\u4e60\u5de5\u4f5c\u6d41\u7684\u6570\u636e\u6d88\u8d39\u3002"}}
{"id": "2510.18418", "pdf": "https://arxiv.org/pdf/2510.18418", "abs": "https://arxiv.org/abs/2510.18418", "authors": ["Nathana\u00eblle Courant", "Xavier Leroy"], "title": "A Lazy, Concurrent Convertibility Checker", "categories": ["cs.LO", "cs.PL"], "comment": null, "summary": "Convertibility checking - determining whether two lambda-terms are equal up\nto reductions - is a crucial component of proof assistants and\ndependently-typed languages. Practical implementations often use heuristics to\nquickly conclude that two terms are or are not convertible without reducing\nthem to normal form. However, these heuristics can backfire, triggering huge\namounts of unnecessary computation. This paper presents a novel\nconvertibility-checking algorithm that relies crucially on laziness and\nconcurrency} Laziness is used to share computations, while concurrency is used\nto explore multiple convertibility subproblems in parallel or via fair\ninterleaving. Unlike heuristics-based approaches, our algorithm always finds an\neasy solution to the convertibility problem, if one exists. The paper presents\nthe algorithm in process calculus style and discusses its mechanized proof of\npartial correctness, its complexity, and its lightweight experimental\nevaluation.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u60f0\u6027\u548c\u5e76\u53d1\u6027\u7684\u65b0\u578b\u53ef\u8f6c\u6362\u6027\u68c0\u67e5\u7b97\u6cd5\uff0c\u907f\u514d\u542f\u53d1\u5f0f\u65b9\u6cd5\u53ef\u80fd\u5bfc\u81f4\u7684\u5197\u4f59\u8ba1\u7b97\u95ee\u9898", "motivation": "\u73b0\u6709\u53ef\u8f6c\u6362\u6027\u68c0\u67e5\u65b9\u6cd5\u4f9d\u8d56\u542f\u53d1\u5f0f\u7b56\u7565\uff0c\u867d\u7136\u80fd\u5feb\u901f\u5224\u65adlambda\u9879\u662f\u5426\u53ef\u8f6c\u6362\uff0c\u4f46\u53ef\u80fd\u89e6\u53d1\u5927\u91cf\u4e0d\u5fc5\u8981\u7684\u8ba1\u7b97", "method": "\u91c7\u7528\u8fdb\u7a0b\u6f14\u7b97\u98ce\u683c\u8bbe\u8ba1\u7b97\u6cd5\uff0c\u5229\u7528\u60f0\u6027\u5b9e\u73b0\u8ba1\u7b97\u5171\u4eab\uff0c\u901a\u8fc7\u5e76\u53d1\u5e76\u884c\u6216\u516c\u5e73\u4ea4\u9519\u63a2\u7d22\u591a\u4e2a\u53ef\u8f6c\u6362\u6027\u5b50\u95ee\u9898", "result": "\u7b97\u6cd5\u603b\u80fd\u627e\u5230\u53ef\u8f6c\u6362\u6027\u95ee\u9898\u7684\u7b80\u5355\u89e3\uff08\u5982\u679c\u5b58\u5728\uff09\uff0c\u5e76\u63d0\u4f9b\u4e86\u90e8\u5206\u6b63\u786e\u6027\u7684\u673a\u68b0\u5316\u8bc1\u660e\u3001\u590d\u6742\u5ea6\u5206\u6790\u548c\u8f7b\u91cf\u7ea7\u5b9e\u9a8c\u8bc4\u4f30", "conclusion": "\u57fa\u4e8e\u60f0\u6027\u548c\u5e76\u53d1\u7684\u7b97\u6cd5\u4e3a\u53ef\u8f6c\u6362\u6027\u68c0\u67e5\u63d0\u4f9b\u4e86\u53ef\u9760\u4e14\u9ad8\u6548\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u907f\u514d\u4e86\u542f\u53d1\u5f0f\u65b9\u6cd5\u7684\u6f5c\u5728\u95ee\u9898"}}
{"id": "2510.18496", "pdf": "https://arxiv.org/pdf/2510.18496", "abs": "https://arxiv.org/abs/2510.18496", "authors": ["Anamitra Ghorui", "Uday P. Khedker"], "title": "LatticeHashForest: An Efficient Data Structure for Repetitive Data and Operations", "categories": ["cs.DS", "cs.IT", "cs.OS", "cs.PL", "math.IT", "E.1; F.3.2; H.0"], "comment": "Author's original manuscript. 22 pages of main content. Submitted to\n  the Programming Journal (programming-journal.org)", "summary": "Analysis of entire programs as a single unit, or whole-program analysis,\ninvolves propagation of large amounts of information through the control flow\nof the program. This is especially true for pointer analysis, where, unless\nsignificant compromises are made in the precision of the analysis, there is a\ncombinatorial blowup of information. One of the key problems we observed in our\nown efforts is that a lot of duplicate data was being propagated, and many\nlow-level data structure operations were repeated a large number of times.\n  We present what we consider to be a novel and generic data structure,\nLatticeHashForest (LHF), to store and operate on such information in a manner\nthat eliminates a majority of redundant computations and duplicate data in\nscenarios similar to those encountered in compilers and program optimization.\nLHF differs from similar work in this vein, such as hash-consing, ZDDs, and\nBDDs, by not only providing a way to efficiently operate on large, aggregate\nstructures, but also modifying the elements of such structures in a manner that\nthey can be deduplicated immediately. LHF also provides a way to perform a\nnested construction of elements such that they can be deduplicated at multiple\nlevels, cutting down the need for additional, nested computations.\n  We provide a detailed structural description, along with an abstract model of\nthis data structure. An entire C++ implementation of LHF is provided as an\nartifact along with evaluations of LHF using examples and benchmark programs.\nWe also supply API documentation and a user manual for users to make\nindependent applications of LHF. Our main use case in the realm of pointer\nanalysis shows memory usage reduction to an almost negligible fraction, and\nspeedups beyond 4x for input sizes approaching 10 million when compared to\nother implementations.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u540d\u4e3aLatticeHashForest\uff08LHF\uff09\u7684\u65b0\u578b\u6570\u636e\u7ed3\u6784\uff0c\u7528\u4e8e\u5728\u7f16\u8bd1\u5668\u4f18\u5316\u7b49\u573a\u666f\u4e2d\u9ad8\u6548\u5b58\u50a8\u548c\u64cd\u4f5c\u5927\u89c4\u6a21\u4fe1\u606f\uff0c\u663e\u8457\u51cf\u5c11\u5197\u4f59\u8ba1\u7b97\u548c\u91cd\u590d\u6570\u636e\u3002", "motivation": "\u5728\u6307\u9488\u5206\u6790\u7b49\u5168\u7a0b\u5e8f\u5206\u6790\u4e2d\uff0c\u4fe1\u606f\u4f20\u64ad\u4f1a\u5bfc\u81f4\u5927\u91cf\u91cd\u590d\u6570\u636e\u548c\u5197\u4f59\u8ba1\u7b97\uff0c\u4f20\u7edf\u65b9\u6cd5\u5728\u7cbe\u5ea6\u548c\u6548\u7387\u4e4b\u95f4\u5b58\u5728\u6743\u8861\u3002", "method": "\u8bbe\u8ba1\u4e86LHF\u6570\u636e\u7ed3\u6784\uff0c\u901a\u8fc7\u5373\u65f6\u53bb\u91cd\u548c\u591a\u5c42\u5d4c\u5957\u6784\u9020\u6765\u6d88\u9664\u5197\u4f59\uff0c\u4e0d\u540c\u4e8e\u54c8\u5e0c\u4e00\u81f4\u6027\u3001ZDDs\u548cBDDs\u7b49\u73b0\u6709\u6280\u672f\u3002", "result": "\u5728\u6307\u9488\u5206\u6790\u7528\u4f8b\u4e2d\uff0c\u5185\u5b58\u4f7f\u7528\u51cf\u5c11\u5230\u51e0\u4e4e\u53ef\u5ffd\u7565\u7684\u7a0b\u5ea6\uff0c\u5bf9\u4e8e\u63a5\u8fd11000\u4e07\u89c4\u6a21\u7684\u8f93\u5165\uff0c\u901f\u5ea6\u63d0\u5347\u8d85\u8fc74\u500d\u3002", "conclusion": "LHF\u662f\u4e00\u79cd\u6709\u6548\u7684\u6570\u636e\u7ed3\u6784\uff0c\u80fd\u591f\u663e\u8457\u63d0\u9ad8\u7a0b\u5e8f\u5206\u6790\u6548\u7387\uff0c\u7279\u522b\u9002\u7528\u4e8e\u9700\u8981\u5904\u7406\u5927\u89c4\u6a21\u4fe1\u606f\u7684\u573a\u666f\u3002"}}
