{"id": "2510.19129", "pdf": "https://arxiv.org/pdf/2510.19129", "abs": "https://arxiv.org/abs/2510.19129", "authors": ["Qiancheng Fu", "Hongwei Xi", "Ankush Das"], "title": "Dependent Session Types for Verified Concurrent Programming", "categories": ["cs.PL"], "comment": null, "summary": "We present TLLC which extends the Two-Level Linear dependent type theory\n(TLL) with session-based concurrency. Equipped with Martin-L\\\"{o}f style\ndependency, the session types of TLLC allow protocols to specify properties of\ncommunicated messages. When used in conjunction with the dependent type\nmachinery already present in TLL, dependent session types facilitate a form of\nrelational verification by relating concurrent programs with their idealized\nsequential counterparts. Correctness properties proven for sequential programs\ncan be easily lifted to their corresponding concurrent implementations. TLLC\nmakes session types a powerful tool for intrinsically verifying the correctness\nof data structures such as queues and concurrent algorithms such as map-reduce.\nTo extend TLL with session types, we develop a novel formulation of\nintuitionistic session type which we believe to be widely applicable for\nintegrating session types into other type systems beyond the context of TLLC.\nWe study the meta-theory of our language, proving its soundness as both a term\ncalculus and a process calculus. To demonstrate the practicality of TLLC, we\nhave implemented a prototype compiler that translates TLLC programs into\nconcurrent C code, which has been extensively evaluated."}
{"id": "2510.19012", "pdf": "https://arxiv.org/pdf/2510.19012", "abs": "https://arxiv.org/abs/2510.19012", "authors": ["Ivan Borodii", "Illia Fedorovych", "Halyna Osukhivska", "Diana Velychko", "Roman Butsii"], "title": "Comparative analysis of large data processing in Apache Spark using Java, Python and Scala", "categories": ["cs.DC", "cs.DB", "cs.PL", "cs.SE"], "comment": "CITI 2025, 3rd International Workshop on Computer Information\n  Technologies in Industry 4.0, June 11-12, 2025, Ternopil, Ukraine. The\n  article includes 10 pages, 5 figures, 9 tables", "summary": "During the study, the results of a comparative analysis of the process of\nhandling large datasets using the Apache Spark platform in Java, Python, and\nScala programming languages were obtained. Although prior works have focused on\nindividual stages, comprehensive comparisons of full ETL workflows across\nprogramming languages using Apache Iceberg remain limited. The analysis was\nperformed by executing several operations, including downloading data from CSV\nfiles, transforming and loading it into an Apache Iceberg analytical table. It\nwas found that the performance of the Spark algorithm varies significantly\ndepending on the amount of data and the programming language used. When\nprocessing a 5-megabyte CSV file, the best result was achieved in Python: 6.71\nseconds, which is superior to Scala's score of 9.13 seconds and Java's time of\n9.62 seconds. For processing a large CSV file of 1.6 gigabytes, all programming\nlanguages demonstrated similar results: the fastest performance was showed in\nPython: 46.34 seconds, while Scala and Java showed results of 47.72 and 50.56\nseconds, respectively. When performing a more complex operation that involved\ncombining two CSV files into a single dataset for further loading into an\nApache Iceberg table, Scala demonstrated the highest performance, at 374.42\nseconds. Java processing was completed in 379.8 seconds, while Python was the\nleast efficient, with a runtime of 398.32 seconds. It follows that the\nprogramming language significantly affects the efficiency of data processing by\nthe Apache Spark algorithm, with Scala and Java being more productive for\nprocessing large amounts of data and complex operations, while Python\ndemonstrates an advantage in working with small amounts of data. The results\nobtained can be useful for optimizing data handling processes depending on\nspecific performance requirements and the amount of information being\nprocessed."}
{"id": "2510.19279", "pdf": "https://arxiv.org/pdf/2510.19279", "abs": "https://arxiv.org/abs/2510.19279", "authors": ["Lukas Hughes-Noehrer", "Matthew J Parkes", "Andrew Stewart", "Anthony J Wilson", "Gary S Collins", "Richard D Riley", "Maya Mathur", "Matthew P Fox", "Nazrul Islam", "Paul N Zivich", "Timothy J Feeney"], "title": "Code Sharing in Healthcare Research: A Practical Guide and Recommendations for Good Practice", "categories": ["cs.CY", "cs.PL"], "comment": null, "summary": "As computational analysis becomes increasingly more complex in health\nresearch, transparent sharing of analytical code is vital for reproducibility\nand trust. This practical guide, aligned to open science practices, outlines\nactionable recommendations for code sharing in healthcare research. Emphasising\nthe FAIR (Findable, Accessible, Interoperable, Reusable) principles, the\nauthors address common barriers and provide clear guidance to help make code\nmore robust, reusable, and scrutinised as part of the scientific record. This\nsupports better science and more reliable evidence for computationally-driven\npractice and helps to adhere to new standards and guidelines of codesharing\nmandated by publishers and funding bodies."}
{"id": "2510.19281", "pdf": "https://arxiv.org/pdf/2510.19281", "abs": "https://arxiv.org/abs/2510.19281", "authors": ["Shubham Joshi"], "title": "An Empirical Study of Bitwise Operators Intuitiveness through Performance Metrics", "categories": ["cs.SE", "cs.CR", "cs.PL"], "comment": "15 pages, 10 tables, 9 Figures", "summary": "Objectives: This study aims to investigate the readability and\nunderstandability of bitwise operators in programming, with the main hypothesis\nthat there will be a difference in the performance metrics (response time and\nerror rate) between participants exposed to various bitwise operators related\nquestions and those who are not.\n  Participants: Participants in this human research study include people\nwithout programming background, novice programmers, and university students\nwith varying programming experience (from freshmen to PhD level). There were 23\nparticipants for this study.\n  Study Methods: This study uses an Within-Subjects Experimental Design to\nassess how people with diverse programming backgrounds understand and use\nbitwise operators. Participants complete tasks in JavaScript program, and their\ntask completion time and accuracy of the tasks are recorded for analysis.\n  Findings: The results indicate that operators can be one of the factors\npredicting response time, with a small but significant effect, with R-squared\n0.032, (1, 494) = 16.5, p < .001. Additionally, some operators like OR, NOT,\nand Left Shift showed statistical significance in task completion times\ncompared to other operators.\n  Conclusions: While the complexity of bitwise operators did not generally\nresult in longer task completion times, certain operators were found to be less\nintuitive, suggesting the need for further investigation and potential redesign\nfor improved understandability."}
{"id": "2510.19296", "pdf": "https://arxiv.org/pdf/2510.19296", "abs": "https://arxiv.org/abs/2510.19296", "authors": ["Yang Zhang", "Rui Zhang", "Jiaming Guo", "Lei Huang", "Di Huang", "Yunpu Zhao", "Shuyao Cheng", "Pengwei Jin", "Chongxiao Li", "Zidong Du", "Xing Hu", "Qi Guo", "Yunji Chen"], "title": "QiMeng-SALV: Signal-Aware Learning for Verilog Code Generation", "categories": ["cs.LG", "cs.AR", "cs.PL"], "comment": "Accepted to NeurIPS 2025", "summary": "The remarkable progress of Large Language Models (LLMs) presents promising\nopportunities for Verilog code generation which is significantly important for\nautomated circuit design. The lacking of meaningful functional rewards hinders\nthe preference optimization based on Reinforcement Learning (RL) for producing\nfunctionally correct Verilog code. In this paper, we propose Signal-Aware\nLearning for Verilog code generation (QiMeng-SALV) by leveraging code segments\nof functionally correct output signal to optimize RL training. Considering\nVerilog code specifies the structural interconnection of hardware gates and\nwires so that different output signals are independent, the key insight of\nQiMeng-SALV is to extract verified signal-aware implementations in partially\nincorrect modules, so as to enhance the extraction of meaningful functional\nrewards. Roughly, we verify the functional correctness of signals in generated\nmodule by comparing with that of reference module in the training data. Then\nabstract syntax tree (AST) is employed to identify signal-aware code segments\nwhich can provide meaningful functional rewards from erroneous modules.\nFinally, we introduce signal-aware DPO which is optimized on the correct\nsignal-level code segments, thereby preventing noise and interference from\nincorrect signals. The proposed QiMeng-SALV underscores the paradigm shift from\nconventional module-level to fine-grained signal-level optimization in Verilog\ncode generation, addressing the issue of insufficient functional rewards.\nExperiments demonstrate that our method achieves state-of-the-art performance\non VerilogEval and RTLLM, with a 7B parameter model matching the performance of\nthe DeepSeek v3 671B model and significantly outperforming the leading\nopen-source model CodeV trained on the same dataset. Our code is available at\nhttps://github.com/zy1xxx/SALV."}
{"id": "2510.19765", "pdf": "https://arxiv.org/pdf/2510.19765", "abs": "https://arxiv.org/abs/2510.19765", "authors": ["Vinay Banakar", "Suli Yang", "Kan Wu", "Andrea C. Arpaci-Dusseau", "Remzi H. Arpaci-Dusseau", "Kimberly Keeton"], "title": "Tidying Up the Address Space", "categories": ["cs.OS", "cs.PF", "cs.PL"], "comment": null, "summary": "Memory tiering in datacenters does not achieve its full potential due to\nhotness fragmentation -- the intermingling of hot and cold objects within\nmemory pages. This fragmentation prevents page-based reclamation systems from\ndistinguishing truly hot pages from pages containing mostly cold objects,\nfundamentally limiting memory efficiency despite highly skewed accesses. We\nintroduce address-space engineering: dynamically reorganizing application\nvirtual address spaces to create uniformly hot and cold regions that any\npage-level tiering backend can manage effectively. HADES demonstrates this\nfrontend/backend approach through a compiler-runtime system that tracks and\nmigrates objects based on access patterns, requiring minimal developer\nintervention. Evaluations across ten data structures achieve up to 70% memory\nreduction with 3% performance overhead, showing that address space engineering\nenables existing reclamation systems to reclaim memory aggressively without\nperformance degradation."}
