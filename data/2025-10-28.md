<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.CR](#cs.CR) [Total: 1]
- [cs.CL](#cs.CL) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Linear effects, exceptions, and resource safety: a Curry-Howard correspondence for destructors](https://arxiv.org/abs/2510.23517)
*Sidney Congard,Guillaume Munch-Maccagnoni,Rémi Douence*

Main category: cs.PL

TL;DR: 该论文研究了在线性设置中结合线性、效应和异常的问题，通过引入分配monad来建模和研究资源安全性，并开发了两个线性效应演算来验证资源安全性。


<details>
  <summary>Details</summary>
Motivation: 研究如何在抽象编程语言模型中同时处理线性性、效应和异常，特别是通过monad结构来确保资源安全性。

Method: 引入分配monad T(- ⊕ E)，在线性设置中提供某种强度。开发了两个演算：第一个是线性call-by-push-value语言，具有new和delete分配效应；第二个是仿射有序call-by-push-value语言，通过切片范畴中的析构器对象集成异常。

Result: 建立了两个演算的资源安全性属性，第一个基于线性类型规则，第二个通过析构器和移动操作实现随机顺序资源释放。

Conclusion: 通过monad结构和类型系统设计，成功在线性效应设置中整合了异常处理机制，并确保了资源安全性，为C++/Rust风格的资源管理提供了理论基础。

Abstract: We analyse the problem of combining linearity, effects, and exceptions, in
abstract models of programming languages, as the issue of providing some kind
of strength for a monad $T(- \oplus E)$ in a linear setting. We consider in
particular for $T$ the allocation monad, which we introduce to model and study
resource-safety properties. We apply these results to a series of two linear
effectful calculi for which we establish their resource-safety properties.
  The first calculus is a linear call-by-push-value language with two
allocation effects $\mathit{new}$ and $\mathit{delete}$. The resource-safety
properties follow from the linear (and even ordered) character of the typing
rules.
  We then explain how to integrate exceptions on top of linearity and effects
by adjoining default destruction actions to types, as inspired by C++/Rust
destructors. We see destructors as objects $\delta : A\rightarrow TI$ in the
slice category over $TI$. This construction gives rise to a second calculus, an
affine ordered call-by-push-value language with exceptions and destructors, in
which the weakening rule performs a side-effect. As in C++/Rust, a ``move''
operation is necessary to allow random-order release of resources, as opposed
to last-in-first-out order. Moving resources is modelled as an exchange rule
that performs a side-effect.

</details>


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [2] [Beyond Imprecise Distance Metrics: LLM-Predicted Target Call Stacks for Directed Greybox Fuzzing](https://arxiv.org/abs/2510.23101)
*Yifan Zhang,Xin Zhang*

Main category: cs.CR

TL;DR: 本文提出了一种基于大语言模型（LLM）的定向灰盒模糊测试方法，用精确的调用栈表示替换基于静态分析的距离度量，显著提高了漏洞触发效率。


<details>
  <summary>Details</summary>
Motivation: 现有的定向灰盒模糊测试方法由于依赖静态分析的距离度量，存在概率计算不精确的问题，导致大量无关执行路径被误认为可能触发目标漏洞，显著降低了模糊测试效率。

Method: 通过静态分析构建调用图识别可能到达目标位置的方法，然后利用LLM预测最可能触发漏洞的调用栈序列，优先选择执行路径与预测调用栈重叠度更高的种子进行变异。

Result: 在真实世界程序套件上，该方法触发漏洞的速度比基线方法快1.86倍到3.09倍，并发现了10个新漏洞和2个不完整修复，获得了10个CVE编号。

Conclusion: 这是首个将LLM集成到定向灰盒模糊测试核心种子优先级机制的工作，证明了基于调用栈表示和LLM预测的方法在提高模糊测试效率方面的有效性。

Abstract: Directed greybox fuzzing (DGF) aims to efficiently trigger bugs at specific
target locations by prioritizing seeds whose execution paths are more likely to
mutate into triggering target bugs. However, existing DGF approaches suffer
from imprecise probability calculations due to their reliance on complex
distance metrics derived from static analysis. The over-approximations inherent
in static analysis cause a large number of irrelevant execution paths to be
mistakenly considered to potentially mutate into triggering target bugs,
significantly reducing fuzzing efficiency. We propose to replace static
analysis-based distance metrics with precise call stack representations. Call
stacks represent precise control flows, thereby avoiding false information in
static analysis. We leverage large language models (LLMs) to predict
vulnerability-triggering call stacks for guiding seed prioritization. Our
approach constructs call graphs through static analysis to identify methods
that can potentially reach target locations, then utilizes LLMs to predict the
most likely call stack sequence that triggers the vulnerability. Seeds whose
execution paths have higher overlap with the predicted call stack are
prioritized for mutation. This is the first work to integrate LLMs into the
core seed prioritization mechanism of DGF. We implement our approach and
evaluate it against several state-of-the-art fuzzers. On a suite of real-world
programs, our approach triggers vulnerabilities $1.86\times$ to $3.09\times$
faster compared to baselines. In addition, our approach identifies 10 new
vulnerabilities and 2 incomplete fixes in the latest versions of programs used
in our controlled experiments through directed patch testing, with 10 assigned
CVE IDs.

</details>


<div id='cs.CL'></div>

# cs.CL [[Back]](#toc)

### [3] [Language Server CLI Empowers Language Agents with Process Rewards](https://arxiv.org/abs/2510.22907)
*Yifan Zhang,Lanser Contributors*

Main category: cs.CL

TL;DR: Lanser-CLI是一个CLI优先的编排层，通过固定和协调语言服务器协议(LSP)服务器，为编码代理和CI提供确定性、可重放的工作流。


<details>
  <summary>Details</summary>
Motivation: 大型语言模型经常产生幻觉API和错误定位编辑，而语言服务器能计算关于真实代码的已验证、IDE级事实。

Method: 开发了选择器DSL用于稳健寻址、确定性分析包、安全变更操作信封，以及基于语言服务器事实的过程奖励函数。

Result: 实现了在冻结快照下的确定性，建立了过程奖励的单调性属性，适用于过程监督和反事实分析。

Conclusion: 语言服务器不仅提供结构信息，还提供可操作的过程奖励，使代理的规划循环与程序现实对齐。

Abstract: Large language models routinely hallucinate APIs and mislocalize edits, while
language servers compute verified, IDE-grade facts about real code. We present
Lanser-CLI, a CLI-first orchestration layer that pins and mediates a Language
Server Protocol (LSP) server for coding agents and CI, exposing deterministic,
replayable workflows. Our position is that language servers provide not only
structural information (definitions, references, types, diagnostics) but also
an actionable process reward: machine-checked, step-wise signals that align an
agent's planning loop with program reality. In this work, Lanser-CLI
contributes: (i) a robust addressing scheme beyond brittle "file:line:col" via
a Selector DSL (symbolic, AST-path, and content-anchored selectors) with a
principled relocation algorithm; (ii) deterministic Analysis Bundles that
normalize Language Server responses and capture environment/capability metadata
with stable content hashes; (iii) a safety envelope for mutating operations
(rename, code actions) with preview, workspace jails, and Git-aware,
transactional apply; and (iv) a process-reward functional derived from Language
Server facts (diagnostic deltas, disambiguation confidence, and safe-apply
checks) that is computable online and replayable offline. We formalize
determinism under frozen snapshots and establish a monotonicity property for
the process reward, making it suitable for process supervision and
counterfactual analysis. Project Page:
https://github.com/yifanzhang-pro/lanser-cli

</details>
