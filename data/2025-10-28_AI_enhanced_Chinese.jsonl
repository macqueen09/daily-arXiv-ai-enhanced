{"id": "2510.23517", "pdf": "https://arxiv.org/pdf/2510.23517", "abs": "https://arxiv.org/abs/2510.23517", "authors": ["Sidney Congard", "Guillaume Munch-Maccagnoni", "R\u00e9mi Douence"], "title": "Linear effects, exceptions, and resource safety: a Curry-Howard correspondence for destructors", "categories": ["cs.PL", "cs.LO"], "comment": "26 pages + appendix", "summary": "We analyse the problem of combining linearity, effects, and exceptions, in\nabstract models of programming languages, as the issue of providing some kind\nof strength for a monad $T(- \\oplus E)$ in a linear setting. We consider in\nparticular for $T$ the allocation monad, which we introduce to model and study\nresource-safety properties. We apply these results to a series of two linear\neffectful calculi for which we establish their resource-safety properties.\n  The first calculus is a linear call-by-push-value language with two\nallocation effects $\\mathit{new}$ and $\\mathit{delete}$. The resource-safety\nproperties follow from the linear (and even ordered) character of the typing\nrules.\n  We then explain how to integrate exceptions on top of linearity and effects\nby adjoining default destruction actions to types, as inspired by C++/Rust\ndestructors. We see destructors as objects $\\delta : A\\rightarrow TI$ in the\nslice category over $TI$. This construction gives rise to a second calculus, an\naffine ordered call-by-push-value language with exceptions and destructors, in\nwhich the weakening rule performs a side-effect. As in C++/Rust, a ``move''\noperation is necessary to allow random-order release of resources, as opposed\nto last-in-first-out order. Moving resources is modelled as an exchange rule\nthat performs a side-effect.", "AI": {"tldr": "\u8be5\u8bba\u6587\u7814\u7a76\u4e86\u5728\u7ebf\u6027\u8bbe\u7f6e\u4e2d\u7ed3\u5408\u7ebf\u6027\u3001\u6548\u5e94\u548c\u5f02\u5e38\u7684\u95ee\u9898\uff0c\u901a\u8fc7\u5f15\u5165\u5206\u914dmonad\u6765\u5efa\u6a21\u548c\u7814\u7a76\u8d44\u6e90\u5b89\u5168\u6027\uff0c\u5e76\u5f00\u53d1\u4e86\u4e24\u4e2a\u7ebf\u6027\u6548\u5e94\u6f14\u7b97\u6765\u9a8c\u8bc1\u8d44\u6e90\u5b89\u5168\u6027\u3002", "motivation": "\u7814\u7a76\u5982\u4f55\u5728\u62bd\u8c61\u7f16\u7a0b\u8bed\u8a00\u6a21\u578b\u4e2d\u540c\u65f6\u5904\u7406\u7ebf\u6027\u6027\u3001\u6548\u5e94\u548c\u5f02\u5e38\uff0c\u7279\u522b\u662f\u901a\u8fc7monad\u7ed3\u6784\u6765\u786e\u4fdd\u8d44\u6e90\u5b89\u5168\u6027\u3002", "method": "\u5f15\u5165\u5206\u914dmonad T(- \u2295 E)\uff0c\u5728\u7ebf\u6027\u8bbe\u7f6e\u4e2d\u63d0\u4f9b\u67d0\u79cd\u5f3a\u5ea6\u3002\u5f00\u53d1\u4e86\u4e24\u4e2a\u6f14\u7b97\uff1a\u7b2c\u4e00\u4e2a\u662f\u7ebf\u6027call-by-push-value\u8bed\u8a00\uff0c\u5177\u6709new\u548cdelete\u5206\u914d\u6548\u5e94\uff1b\u7b2c\u4e8c\u4e2a\u662f\u4eff\u5c04\u6709\u5e8fcall-by-push-value\u8bed\u8a00\uff0c\u901a\u8fc7\u5207\u7247\u8303\u7574\u4e2d\u7684\u6790\u6784\u5668\u5bf9\u8c61\u96c6\u6210\u5f02\u5e38\u3002", "result": "\u5efa\u7acb\u4e86\u4e24\u4e2a\u6f14\u7b97\u7684\u8d44\u6e90\u5b89\u5168\u6027\u5c5e\u6027\uff0c\u7b2c\u4e00\u4e2a\u57fa\u4e8e\u7ebf\u6027\u7c7b\u578b\u89c4\u5219\uff0c\u7b2c\u4e8c\u4e2a\u901a\u8fc7\u6790\u6784\u5668\u548c\u79fb\u52a8\u64cd\u4f5c\u5b9e\u73b0\u968f\u673a\u987a\u5e8f\u8d44\u6e90\u91ca\u653e\u3002", "conclusion": "\u901a\u8fc7monad\u7ed3\u6784\u548c\u7c7b\u578b\u7cfb\u7edf\u8bbe\u8ba1\uff0c\u6210\u529f\u5728\u7ebf\u6027\u6548\u5e94\u8bbe\u7f6e\u4e2d\u6574\u5408\u4e86\u5f02\u5e38\u5904\u7406\u673a\u5236\uff0c\u5e76\u786e\u4fdd\u4e86\u8d44\u6e90\u5b89\u5168\u6027\uff0c\u4e3aC++/Rust\u98ce\u683c\u7684\u8d44\u6e90\u7ba1\u7406\u63d0\u4f9b\u4e86\u7406\u8bba\u57fa\u7840\u3002"}}
{"id": "2510.22907", "pdf": "https://arxiv.org/pdf/2510.22907", "abs": "https://arxiv.org/abs/2510.22907", "authors": ["Yifan Zhang", "Lanser Contributors"], "title": "Language Server CLI Empowers Language Agents with Process Rewards", "categories": ["cs.CL", "cs.AI", "cs.PL", "cs.SE"], "comment": "Project Page: https://github.com/yifanzhang-pro/lanser-cli", "summary": "Large language models routinely hallucinate APIs and mislocalize edits, while\nlanguage servers compute verified, IDE-grade facts about real code. We present\nLanser-CLI, a CLI-first orchestration layer that pins and mediates a Language\nServer Protocol (LSP) server for coding agents and CI, exposing deterministic,\nreplayable workflows. Our position is that language servers provide not only\nstructural information (definitions, references, types, diagnostics) but also\nan actionable process reward: machine-checked, step-wise signals that align an\nagent's planning loop with program reality. In this work, Lanser-CLI\ncontributes: (i) a robust addressing scheme beyond brittle \"file:line:col\" via\na Selector DSL (symbolic, AST-path, and content-anchored selectors) with a\nprincipled relocation algorithm; (ii) deterministic Analysis Bundles that\nnormalize Language Server responses and capture environment/capability metadata\nwith stable content hashes; (iii) a safety envelope for mutating operations\n(rename, code actions) with preview, workspace jails, and Git-aware,\ntransactional apply; and (iv) a process-reward functional derived from Language\nServer facts (diagnostic deltas, disambiguation confidence, and safe-apply\nchecks) that is computable online and replayable offline. We formalize\ndeterminism under frozen snapshots and establish a monotonicity property for\nthe process reward, making it suitable for process supervision and\ncounterfactual analysis. Project Page:\nhttps://github.com/yifanzhang-pro/lanser-cli", "AI": {"tldr": "Lanser-CLI\u662f\u4e00\u4e2aCLI\u4f18\u5148\u7684\u7f16\u6392\u5c42\uff0c\u901a\u8fc7\u56fa\u5b9a\u548c\u534f\u8c03\u8bed\u8a00\u670d\u52a1\u5668\u534f\u8bae(LSP)\u670d\u52a1\u5668\uff0c\u4e3a\u7f16\u7801\u4ee3\u7406\u548cCI\u63d0\u4f9b\u786e\u5b9a\u6027\u3001\u53ef\u91cd\u653e\u7684\u5de5\u4f5c\u6d41\u3002", "motivation": "\u5927\u578b\u8bed\u8a00\u6a21\u578b\u7ecf\u5e38\u4ea7\u751f\u5e7b\u89c9API\u548c\u9519\u8bef\u5b9a\u4f4d\u7f16\u8f91\uff0c\u800c\u8bed\u8a00\u670d\u52a1\u5668\u80fd\u8ba1\u7b97\u5173\u4e8e\u771f\u5b9e\u4ee3\u7801\u7684\u5df2\u9a8c\u8bc1\u3001IDE\u7ea7\u4e8b\u5b9e\u3002", "method": "\u5f00\u53d1\u4e86\u9009\u62e9\u5668DSL\u7528\u4e8e\u7a33\u5065\u5bfb\u5740\u3001\u786e\u5b9a\u6027\u5206\u6790\u5305\u3001\u5b89\u5168\u53d8\u66f4\u64cd\u4f5c\u4fe1\u5c01\uff0c\u4ee5\u53ca\u57fa\u4e8e\u8bed\u8a00\u670d\u52a1\u5668\u4e8b\u5b9e\u7684\u8fc7\u7a0b\u5956\u52b1\u51fd\u6570\u3002", "result": "\u5b9e\u73b0\u4e86\u5728\u51bb\u7ed3\u5feb\u7167\u4e0b\u7684\u786e\u5b9a\u6027\uff0c\u5efa\u7acb\u4e86\u8fc7\u7a0b\u5956\u52b1\u7684\u5355\u8c03\u6027\u5c5e\u6027\uff0c\u9002\u7528\u4e8e\u8fc7\u7a0b\u76d1\u7763\u548c\u53cd\u4e8b\u5b9e\u5206\u6790\u3002", "conclusion": "\u8bed\u8a00\u670d\u52a1\u5668\u4e0d\u4ec5\u63d0\u4f9b\u7ed3\u6784\u4fe1\u606f\uff0c\u8fd8\u63d0\u4f9b\u53ef\u64cd\u4f5c\u7684\u8fc7\u7a0b\u5956\u52b1\uff0c\u4f7f\u4ee3\u7406\u7684\u89c4\u5212\u5faa\u73af\u4e0e\u7a0b\u5e8f\u73b0\u5b9e\u5bf9\u9f50\u3002"}}
{"id": "2510.23101", "pdf": "https://arxiv.org/pdf/2510.23101", "abs": "https://arxiv.org/abs/2510.23101", "authors": ["Yifan Zhang", "Xin Zhang"], "title": "Beyond Imprecise Distance Metrics: LLM-Predicted Target Call Stacks for Directed Greybox Fuzzing", "categories": ["cs.CR", "cs.PL", "cs.SE"], "comment": "Preprint, under submission", "summary": "Directed greybox fuzzing (DGF) aims to efficiently trigger bugs at specific\ntarget locations by prioritizing seeds whose execution paths are more likely to\nmutate into triggering target bugs. However, existing DGF approaches suffer\nfrom imprecise probability calculations due to their reliance on complex\ndistance metrics derived from static analysis. The over-approximations inherent\nin static analysis cause a large number of irrelevant execution paths to be\nmistakenly considered to potentially mutate into triggering target bugs,\nsignificantly reducing fuzzing efficiency. We propose to replace static\nanalysis-based distance metrics with precise call stack representations. Call\nstacks represent precise control flows, thereby avoiding false information in\nstatic analysis. We leverage large language models (LLMs) to predict\nvulnerability-triggering call stacks for guiding seed prioritization. Our\napproach constructs call graphs through static analysis to identify methods\nthat can potentially reach target locations, then utilizes LLMs to predict the\nmost likely call stack sequence that triggers the vulnerability. Seeds whose\nexecution paths have higher overlap with the predicted call stack are\nprioritized for mutation. This is the first work to integrate LLMs into the\ncore seed prioritization mechanism of DGF. We implement our approach and\nevaluate it against several state-of-the-art fuzzers. On a suite of real-world\nprograms, our approach triggers vulnerabilities $1.86\\times$ to $3.09\\times$\nfaster compared to baselines. In addition, our approach identifies 10 new\nvulnerabilities and 2 incomplete fixes in the latest versions of programs used\nin our controlled experiments through directed patch testing, with 10 assigned\nCVE IDs.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u5927\u8bed\u8a00\u6a21\u578b\uff08LLM\uff09\u7684\u5b9a\u5411\u7070\u76d2\u6a21\u7cca\u6d4b\u8bd5\u65b9\u6cd5\uff0c\u7528\u7cbe\u786e\u7684\u8c03\u7528\u6808\u8868\u793a\u66ff\u6362\u57fa\u4e8e\u9759\u6001\u5206\u6790\u7684\u8ddd\u79bb\u5ea6\u91cf\uff0c\u663e\u8457\u63d0\u9ad8\u4e86\u6f0f\u6d1e\u89e6\u53d1\u6548\u7387\u3002", "motivation": "\u73b0\u6709\u7684\u5b9a\u5411\u7070\u76d2\u6a21\u7cca\u6d4b\u8bd5\u65b9\u6cd5\u7531\u4e8e\u4f9d\u8d56\u9759\u6001\u5206\u6790\u7684\u8ddd\u79bb\u5ea6\u91cf\uff0c\u5b58\u5728\u6982\u7387\u8ba1\u7b97\u4e0d\u7cbe\u786e\u7684\u95ee\u9898\uff0c\u5bfc\u81f4\u5927\u91cf\u65e0\u5173\u6267\u884c\u8def\u5f84\u88ab\u8bef\u8ba4\u4e3a\u53ef\u80fd\u89e6\u53d1\u76ee\u6807\u6f0f\u6d1e\uff0c\u663e\u8457\u964d\u4f4e\u4e86\u6a21\u7cca\u6d4b\u8bd5\u6548\u7387\u3002", "method": "\u901a\u8fc7\u9759\u6001\u5206\u6790\u6784\u5efa\u8c03\u7528\u56fe\u8bc6\u522b\u53ef\u80fd\u5230\u8fbe\u76ee\u6807\u4f4d\u7f6e\u7684\u65b9\u6cd5\uff0c\u7136\u540e\u5229\u7528LLM\u9884\u6d4b\u6700\u53ef\u80fd\u89e6\u53d1\u6f0f\u6d1e\u7684\u8c03\u7528\u6808\u5e8f\u5217\uff0c\u4f18\u5148\u9009\u62e9\u6267\u884c\u8def\u5f84\u4e0e\u9884\u6d4b\u8c03\u7528\u6808\u91cd\u53e0\u5ea6\u66f4\u9ad8\u7684\u79cd\u5b50\u8fdb\u884c\u53d8\u5f02\u3002", "result": "\u5728\u771f\u5b9e\u4e16\u754c\u7a0b\u5e8f\u5957\u4ef6\u4e0a\uff0c\u8be5\u65b9\u6cd5\u89e6\u53d1\u6f0f\u6d1e\u7684\u901f\u5ea6\u6bd4\u57fa\u7ebf\u65b9\u6cd5\u5feb1.86\u500d\u52303.09\u500d\uff0c\u5e76\u53d1\u73b0\u4e8610\u4e2a\u65b0\u6f0f\u6d1e\u548c2\u4e2a\u4e0d\u5b8c\u6574\u4fee\u590d\uff0c\u83b7\u5f97\u4e8610\u4e2aCVE\u7f16\u53f7\u3002", "conclusion": "\u8fd9\u662f\u9996\u4e2a\u5c06LLM\u96c6\u6210\u5230\u5b9a\u5411\u7070\u76d2\u6a21\u7cca\u6d4b\u8bd5\u6838\u5fc3\u79cd\u5b50\u4f18\u5148\u7ea7\u673a\u5236\u7684\u5de5\u4f5c\uff0c\u8bc1\u660e\u4e86\u57fa\u4e8e\u8c03\u7528\u6808\u8868\u793a\u548cLLM\u9884\u6d4b\u7684\u65b9\u6cd5\u5728\u63d0\u9ad8\u6a21\u7cca\u6d4b\u8bd5\u6548\u7387\u65b9\u9762\u7684\u6709\u6548\u6027\u3002"}}
