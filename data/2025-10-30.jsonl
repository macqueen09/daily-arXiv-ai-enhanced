{"id": "2510.25112", "pdf": "https://arxiv.org/pdf/2510.25112", "abs": "https://arxiv.org/abs/2510.25112", "authors": ["Di Zhang"], "title": "The Singularity Theory of Concurrent Programs: A Topological Characterization and Detection of Deadlocks and Livelocks", "categories": ["cs.PL", "cs.DC", "cs.LO", "math.AT", "68Q85, 55P99, 68N30, 55U10", "D.2.4; F.3.1; D.1.3; F.1.2"], "comment": "10 pages", "summary": "This paper introduces a novel paradigm for the analysis and verification of\nconcurrent programs -- the Singularity Theory. We model the execution space of\na concurrent program as a branched topological space, where program states are\npoints and state transitions are paths. Within this framework, we characterize\ndeadlocks as attractors and livelocks as non-contractible loops in the\nexecution space. By employing tools from algebraic topology, particularly\nhomotopy and homology groups, we define a series of concurrent topological\ninvariants to systematically detect and classify these concurrent\n\"singularities\" without exhaustively traversing all states. This work aims to\nestablish a geometric and topological foundation for concurrent program\nverification, transcending the limitations of traditional model checking."}
{"id": "2510.25369", "pdf": "https://arxiv.org/pdf/2510.25369", "abs": "https://arxiv.org/abs/2510.25369", "authors": ["Elliot Bobrow", "Bryan Ford", "Stefan MilenkoviÄ‡"], "title": "Have a thing? Reasoning around recursion with dynamic typing in grounded arithmetic", "categories": ["cs.PL", "cs.FL", "cs.LO", "math.LO", "F.3.1; F.4.1"], "comment": null, "summary": "Neither the classical nor intuitionistic logic traditions are\nperfectly-aligned with the purpose of reasoning about computation, in that\nneither logical tradition can normally permit the direct expression of\narbitrary general-recursive functions without inconsistency. We introduce\ngrounded arithmetic or GA, a minimalistic but nonetheless powerful foundation\nfor formal reasoning that allows the direct expression of arbitrary recursive\ndefinitions. GA adjusts the traditional inference rules such that terms that\nexpress nonterminating computations harmlessly denote no semantic value (i.e.,\n\"bottom\") instead of leading into logical paradox or inconsistency. Recursive\nfunctions may be proven terminating in GA essentially by \"dynamically typing\"\nterms, or equivalently, symbolically reverse-executing the computations they\ndenote via GA's inference rules. Once recursive functions have been proven\nterminating, logical reasoning about their results reduce to the familiar\nclassical rules. A mechanically-checked consistency proof in Isabelle/HOL\nexists for the basic quantifier-free fragment of GA. Quantifiers may be added\natop this foundation as ordinary computations, whose inference rules are thus\nadmissible and do not introduce new inconsistency risks. While GA is only a\nfirst step towards richly-typed grounded deduction practical for everyday use\nin manual or automated computational reasoning, it shows the promise that the\nexpressive freedom of arbitrary recursive definition can in principle be\nincorporated into formal systems."}
{"id": "2510.24798", "pdf": "https://arxiv.org/pdf/2510.24798", "abs": "https://arxiv.org/abs/2510.24798", "authors": ["Evgeny Ukhanov"], "title": "Formal Verification of a Token Sale Launchpad: A Compositional Approach in Dafny", "categories": ["cs.LO", "cs.PL"], "comment": "29 pages, no figures. The full Dafny source code and formal proofs\n  are available at:\n  https://github.com/aurora-is-near/aurora-launchpad-contracts/tree/master/verification", "summary": "The proliferation of decentralized financial (DeFi) systems and smart\ncontracts has underscored the critical need for software correctness. Bugs in\nsuch systems can lead to catastrophic financial losses. Formal verification\noffers a path to achieving mathematical certainty about software behavior. This\npaper presents the formal verification of the core logic for a token sale\nlaunchpad, implemented and proven correct using the Dafny programming language\nand verification system. We detail a compositional, bottom-up verification\nstrategy, beginning with the proof of fundamental non-linear integer arithmetic\nproperties, and building upon them to verify complex business logic, including\nasset conversion, time-based discounts, and capped-sale refund mechanics. The\nprincipal contributions are the formal proofs of critical safety and lifecycle\nproperties. Most notably, we prove that refunds in a capped sale can never\nexceed the user's original deposit amount, and that the precision loss in\nround-trip financial calculations is strictly bounded. Furthermore, we verify\nthe complete lifecycle logic, including user withdrawals under various sale\nmechanics and the correctness of post-sale token allocation, vesting, and\nclaiming. This work serves as a comprehensive case study in applying rigorous\nverification techniques to build high-assurance financial software."}
{"id": "2510.24819", "pdf": "https://arxiv.org/pdf/2510.24819", "abs": "https://arxiv.org/abs/2510.24819", "authors": ["Vincenzo Scotti", "Jan Keim", "Tobias Hey", "Andreas Metzger", "Anne Koziolek", "Raffaela Mirandola"], "title": "A Roadmap for Tamed Interactions with Large Language Models", "categories": ["cs.SE", "cs.PL"], "comment": null, "summary": "We are witnessing a bloom of AI-powered software driven by Large Language\nModels (LLMs). Although the applications of these LLMs are impressive and\nseemingly countless, their unreliability hinders adoption. In fact, the\ntendency of LLMs to produce faulty or hallucinated content makes them\nunsuitable for automating workflows and pipelines. In this regard, Software\nEngineering (SE) provides valuable support, offering a wide range of formal\ntools to specify, verify, and validate software behaviour. Such SE tools can be\napplied to define constraints over LLM outputs and, consequently, offer\nstronger guarantees on the generated content. In this paper, we argue that the\ndevelopment of a Domain Specific Language (DSL) for scripting interactions with\nLLMs using an LLM Scripting Language (LSL) may be key to improve AI-based\napplications. Currently, LLMs and LLM-based software still lack reliability,\nrobustness, and trustworthiness, and the tools or frameworks to cope with these\nissues suffer from fragmentation. In this paper, we present our vision of LSL.\nWith LSL, we aim to address the limitations above by exploring ways to control\nLLM outputs, enforce structure in interactions, and integrate these aspects\nwith verification, validation, and explainability. Our goal is to make LLM\ninteraction programmable and decoupled from training or implementation."}
{"id": "2510.25468", "pdf": "https://arxiv.org/pdf/2510.25468", "abs": "https://arxiv.org/abs/2510.25468", "authors": ["Emanuele De Angelis", "Florian Frohn"], "title": "Proceedings of the 12th Workshop on Horn Clauses for Verification and Synthesis", "categories": ["cs.LO", "cs.PL", "cs.SE"], "comment": null, "summary": "This volume contains the post-proceedings of the 12th Workshop on Horn\nClauses for Verification and Synthesis (HCVS 2025), which took place in Zagreb,\nCroatia, on July 22, 2025, as affiliated workshop of the 37th International\nConference on Computer Aided Verification (CAV 2025)."}
