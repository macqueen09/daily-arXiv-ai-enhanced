{"id": "2510.26016", "pdf": "https://arxiv.org/pdf/2510.26016", "abs": "https://arxiv.org/abs/2510.26016", "authors": ["Michael Arntzenius"], "title": "Fair intersection of seekable iterators", "categories": ["cs.PL"], "comment": "8 pages, 2 figures, published in miniKanren 2025", "summary": "miniKanren's key semantic advance over Prolog is to implement a complete yet\nefficient search strategy, fairly interleaving execution between disjuncts.\nThis fairness is accomplished by bounding how much work is done exploring one\ndisjunct before switching to the next. We show that the same idea -- fairness\nvia bounded work -- underlies an elegant compositional approach to implementing\nworst-case optimal joins using a seekable iterator interface, suitable for\nshallow embedding in functional languages."}
{"id": "2510.25975", "pdf": "https://arxiv.org/pdf/2510.25975", "abs": "https://arxiv.org/abs/2510.25975", "authors": ["Sina Bagheri Nezhad", "Yao Li", "Ameeta Agrawal"], "title": "SymCode: A Neurosymbolic Approach to Mathematical Reasoning via Verifiable Code Generation", "categories": ["cs.CL", "cs.PL"], "comment": null, "summary": "Large Language Models (LLMs) often struggle with complex mathematical\nreasoning, where prose-based generation leads to unverified and arithmetically\nunsound solutions. Current prompting strategies like Chain of Thought still\noperate within this unreliable medium, lacking a mechanism for deterministic\nverification. To address these limitations, we introduce SymCode, a\nneurosymbolic framework that reframes mathematical problem-solving as a task of\nverifiable code generation using the SymPy library. We evaluate SymCode on\nchallenging benchmarks, including MATH-500 and OlympiadBench, demonstrating\nsignificant accuracy improvements of up to 13.6 percentage points over\nbaselines. Our analysis shows that SymCode is not only more token-efficient but\nalso fundamentally shifts model failures from opaque logical fallacies towards\ntransparent, programmatic errors. By grounding LLM reasoning in a deterministic\nsymbolic engine, SymCode represents a key step towards more accurate and\ntrustworthy AI in formal domains."}
{"id": "2510.26101", "pdf": "https://arxiv.org/pdf/2510.26101", "abs": "https://arxiv.org/abs/2510.26101", "authors": ["Taku Mikuriya", "Tatsuya Ishigaki", "Masayuki Kawarada", "Shunya Minami", "Tadashi Kadowaki", "Yohichi Suzuki", "Soshun Naito", "Shunya Takata", "Takumi Kato", "Tamotsu Basseda", "Reo Yamada", "Hiroya Takamura"], "title": "QCoder Benchmark: Bridging Language Generation and Quantum Hardware through Simulator-Based Feedback", "categories": ["cs.CL", "cs.PL", "quant-ph"], "comment": null, "summary": "Large language models (LLMs) have increasingly been applied to automatic\nprogramming code generation. This task can be viewed as a language generation\ntask that bridges natural language, human knowledge, and programming logic.\nHowever, it remains underexplored in domains that require interaction with\nhardware devices, such as quantum programming, where human coders write Python\ncode that is executed on a quantum computer. To address this gap, we introduce\nQCoder Benchmark, an evaluation framework that assesses LLMs on quantum\nprogramming with feedback from simulated hardware devices. Our benchmark offers\ntwo key features. First, it supports evaluation using a quantum simulator\nenvironment beyond conventional Python execution, allowing feedback of\ndomain-specific metrics such as circuit depth, execution time, and error\nclassification, which can be used to guide better generation. Second, it\nincorporates human-written code submissions collected from real programming\ncontests, enabling both quantitative comparisons and qualitative analyses of\nLLM outputs against human-written codes. Our experiments reveal that even\nadvanced models like GPT-4o achieve only around 18.97% accuracy, highlighting\nthe difficulty of the benchmark. In contrast, reasoning-based models such as o3\nreach up to 78% accuracy, outperforming averaged success rates of human-written\ncodes (39.98%). We release the QCoder Benchmark dataset and public evaluation\nAPI to support further research."}
{"id": "2510.26428", "pdf": "https://arxiv.org/pdf/2510.26428", "abs": "https://arxiv.org/abs/2510.26428", "authors": ["Gregoire Maire", "Thomas Genet"], "title": "Finding Regular Herbrand Models for CHCs using Answer Set Programming", "categories": ["cs.LO", "cs.FL", "cs.PL"], "comment": "In Proceedings HCVS 2025, arXiv:2510.25468", "summary": "We are interested in proving satisfiability of Constrained Horn Clauses\n(CHCs) over Algebraic Data Types (ADTs). We propose to prove satisfiability by\nbuilding a tree automaton recognizing the Herbrand model of the CHCs. If such\nan automaton exists then the model is said to be regular, i.e., the Herbrand\nmodel is a regular set of atoms. Kostyukov et al. have shown how to derive an\nautomaton when CVC4 finds a finite model of the CHCs. We propose an alternative\nway to build the automaton using an encoding into a SAT problem using Clingo,\nan Answer Set Programming (ASP) tool. We implemented a translation of CHCs with\nADTs into an ASP problem. Combined with Clingo, we obtain a semi-complete\nsatisfiability checker: it finds a tree automaton if a regular Herbrand model\nexists or finds a counter-example if the problem is unsatisfiable."}
{"id": "2510.26429", "pdf": "https://arxiv.org/pdf/2510.26429", "abs": "https://arxiv.org/abs/2510.26429", "authors": ["Salvador Lucas"], "title": "Semantic Properties of Computations Defined by Elementary Inference Systems", "categories": ["cs.LO", "cs.PL", "cs.SC"], "comment": "In Proceedings HCVS 2025, arXiv:2510.25468", "summary": "We consider sets/relations/computations defined by *Elementary Inference\nSystems* I, which are obtained from Smullyan's *elementary formal systems*\nusing Gentzen's notation for inference rules, and proof trees for atoms\nP(t_1,...,t_n), where predicate P represents the considered\nset/relation/computation. A first-order theory Th(I), actually a set of\ndefinite Horn clauses, is given to I. Properties of objects defined by I are\nexpressed as first-order sentences F, which are proved true or false by\n*satisfaction* M |= F of F in a *canonical* model M of Th(I). For this reason,\nwe call F a *semantic property* of I. Since canonical models are, in general,\nincomputable, we show how to (dis)prove semantic properties by satisfiability\nin an *arbitrary* model A of Th(I). We apply these ideas to the analysis of\nproperties of programming languages and systems whose computations can be\ndescribed by means of an elementary inference system. In particular,\nrewriting-based systems."}
{"id": "2510.26431", "pdf": "https://arxiv.org/pdf/2510.26431", "abs": "https://arxiv.org/abs/2510.26431", "authors": ["Mihály Dobos-Kovács", "Levente Bajczi", "András Vörös"], "title": "CHCVerif: A Portfolio-Based Solver for Constrained Horn Clauses", "categories": ["cs.SE", "cs.LO", "cs.PL"], "comment": "In Proceedings HCVS 2025, arXiv:2510.25468", "summary": "Constrained Horn Clauses (CHCs) are widely adopted as intermediate\nrepresentations for a variety of verification tasks, including safety checking,\ninvariant synthesis, and interprocedural analysis. This paper introduces\nCHCVERIF, a portfolio-based CHC solver that adopts a software verification\napproach for solving CHCs. This approach enables us to reuse mature software\nverification tools to tackle CHC benchmarks, particularly those involving\nbitvectors and low-level semantics. Our evaluation shows that while the method\nenjoys only moderate success with linear integer arithmetic, it achieves modest\nsuccess on bitvector benchmarks. Moreover, our results demonstrate the\nviability and potential of using software verification tools as backends for\nCHC solving, particularly when supported by a carefully constructed portfolio."}
