<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.SE](#cs.SE) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [A Data-driven Analysis of Code Optimizations](https://arxiv.org/abs/2511.06117)
*Yacine Hakimi,Riyadh Baghdadi*

Main category: cs.PL

TL;DR: 本文研究编译器自动代码优化中变换顺序对性能的影响，通过数据驱动方法分析固定顺序与任意顺序变换的权衡。


<details>
  <summary>Details</summary>
Motivation: 随着计算需求增长，自动代码优化变得至关重要。编译器开发者面临设计选择：是允许任意顺序应用变换（理论上性能最佳但搜索空间大），还是使用固定顺序（搜索更快但可能限制优化潜力）。

Method: 采用数据驱动方法：生成大量随机程序，应用随机优化序列，记录执行时间，并通过统计分析获得见解。

Result: 通过统计分析提供了指导自动代码优化算法开发的见解，揭示了变换顺序对搜索效率和优化潜力的影响。

Conclusion: 研究为设计更高效的自动代码优化算法提供了数据支持，帮助在搜索速度和优化效果之间找到平衡。

Abstract: As the demand for computational power grows, optimizing code through compilers becomes increasingly crucial. In this context, we focus on fully automatic code optimization techniques that automate the process of selecting and applying code transformations for better performance without manual intervention. Understanding how these transformations behave and interact is key to designing more effective optimization strategies. Compiler developers must make numerous design choices when constructing these heuristics. For instance, they may decide whether to allow transformations to be explored in any arbitrary order or to enforce a fixed sequence. While the former may theoretically offer the best performance gains, it significantly increases the search space. This raises an important question: Can a predefined, fixed order of applying transformations speed up the search without severely compromising optimization potential? In this paper, we address this and other related questions that arise in the design of automatic code optimization algorithms. Using a data-driven approach, we generate a large dataset of random programs, apply random optimization sequences, and record their execution times. Through statistical analysis, we provide insights that guide the development of more efficient automatic code optimization algorithms.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [2] [High-Performance Generation of Constrained Input](https://arxiv.org/abs/2511.05987)
*Addison Crump,Alexi Turcotte,José Antonio Zamudio Amaya,Andreas Zeller*

Main category: cs.SE

TL;DR: 提出了一种基于进化的语言测试新方法，性能比现有技术提高3-4个数量级，将生成和约束求解时间从数小时减少到秒级。


<details>
  <summary>Details</summary>
Motivation: 现有方法在处理复杂约束时面临性能瓶颈：SMT求解器在寻找字符串解时非常慢，进化算法虽然更快更通用，但在处理编译器测试等领域的复杂约束时仍有困难。

Method: 1) 将语法定义精心转换为Rust类型和特征实现，使编译器能够近乎最大化地优化任意语法上的任意操作；2) 使用更好的进化算法，提高语言测试解决复杂约束系统的能力。

Result: 原型系统FANDANGO-RS能够解决先前策略无法处理的约束，在C子集的案例研究中，每分钟能生成401个多样化、复杂且有效的C编译器测试输入。

Conclusion: 该方法的性能和算法改进使得语言测试能够处理更复杂的约束，为编译器测试等应用领域提供了高效的测试输入生成能力。

Abstract: Language-based testing combines context-free grammar definitions with semantic constraints over grammar elements to generate test inputs. By pairing context-free grammars with constraints, users have the expressiveness of unrestricted grammars while retaining simple structure. However, producing inputs in the presence of such constraints can be challenging. In past approaches, SMT solvers have been found to be very slow at finding string solutions; evolutionary algorithms are faster and more general, but current implementations still struggle with complex constraints that would be required for domains such as compiler testing. In this paper, we present a novel approach for evolutionary language-based testing that improves performance by 3-4 orders of magnitude over the current state of the art, reducing hours of generation and constraint solving time to seconds. We accomplish this by (1) carefully transforming grammar definitions into Rust types and trait implementations, ensuring that the compiler may near-maximally optimize arbitrary operations on arbitrary grammars; and (2) using better evolutionary algorithms that improve the ability of language-based testing to solve complex constraint systems. These performance and algorithmic improvements allow our prototype, FANDANGO-RS, to solve constraints that previous strategies simply cannot handle. We demonstrate this by a case study for a C subset, in which FANDANGO-RS is able to generate 401 diverse, complex, and valid test inputs for a C compiler per minute.

</details>
