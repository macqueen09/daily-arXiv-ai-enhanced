<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 5]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Cyclotron: Compilation of Recurrences to Distributed and Systolic Architectures](https://arxiv.org/abs/2511.09987)
*Shiv Sundram,Akhilesh Balasingam,Nathan Zhang,Kunle Olukotun,Fredrik Kjolstad*

Main category: cs.PL

TL;DR: Cyclotron是一个用于流式数据流算法的框架和编译器，使用递归方程表达算法，并将其可移植地编译到分布式处理器拓扑中。


<details>
  <summary>Details</summary>
Motivation: 开发一个能够将递归方程表达的流式数据流算法高效编译到分布式硬件架构的框架，减少内存移动成本，实现高性能计算。

Method: 提供基于逻辑张量递归的输入语言，通过中间语言逐步降低到特定处理器的发送、接收和计算操作，优化内存访问使其局限于迭代空间边界。

Result: 实现了到可重构模拟器和分布式CPU集群的可移植编译，在矩阵乘法和三角求解等算法上生成与ScaLAPACK竞争的实现。

Conclusion: Cyclotron框架成功展示了使用递归方程表达和编译分布式流式数据流算法的可行性，为硬件设计空间探索和高性能计算提供了有效工具。

Abstract: We present Cyclotron, a framework and compiler for using recurrence equations to express streaming dataflow algorithms, which then get portably compiled to distributed topologies of interlinked processors. Our framework provides an input language of recurrences over logical tensors, which then gets lowered into an intermediate language of recurrences over logical iteration spaces, and finally into programs of send, receive, and computation operations specific to each individual processor. In Cyclotron's IR, programs are optimized such that external memory interactions are confined to the boundaries of the iteration space. Within inner iteration spaces, all data accesses become local: data accesses target values residing in local fast memory or on neighboring processing units, avoiding costly memory movement. We provide a scheduling language allowing users to define how data gets streamed and broadcasted between processors, enabling pipelined execution of computation kernels over distributed topologies of processing elements. We demonstrate the portability of our approach by compiling our IR to a reconfigurable simulator of systolic arrays and chiplet style distributed hardware, as well as to distributed-memory CPU clusters. In the simulated reconfigurable setting, we use our compiler for hardware design space exploration in which link costs and latencies can be specified. In the distributed CPU setting, we show how to use recurrences and our scheduling language to express various matrix multiplication routines (Cannon, SUMMA, PUMMA, weight stationary) and solvers (Triangular solve and Cholesky). For matrix multiplication and the triangular solve, we generate distributed implementations competitive with ScaLAPACK.

</details>


### [2] [Omnidirectional type inference for ML: principality any way](https://arxiv.org/abs/2511.10343)
*Alistair O'Brien,Didier Rémy,Gabriel Scherer*

Main category: cs.PL

TL;DR: 本文提出了一种称为"全向类型推断"的新方法，通过动态信息流和悬置匹配约束来解决ML类型系统扩展中的主要性丧失问题，比现有的双向类型推断更灵活。


<details>
  <summary>Details</summary>
Motivation: ML类型系统的许多扩展（如GADTs、高阶多态、静态重载）破坏了主要性，导致类型推断变得脆弱。现有的双向类型推断方法采用固定的推断顺序，经常拒绝本应类型正确的程序。

Method: 提出全向类型推断，允许类型信息以动态顺序流动，使用悬置匹配约束在需要已知类型信息时暂停推断，并在信息可用时恢复。引入增量实例化来处理let泛化问题。

Result: 该方法在OCaml的两个不同特性（记录标签和数据构造器的静态重载、半显式一等多态）上验证了有效性，获得了比OCaml当前类型检查器更具表达性的主要类型推断算法。

Conclusion: 全向类型推断为在脆弱特性存在时恢复主要性提供了一个通用框架，比静态顺序的推断方法更灵活和表达性强。

Abstract: The Damas-Hindley-Milner (ML) type system owes its success to principality, the property that every well-typed expression has a unique most general type. This makes inference predictable and efficient. Unfortunately, many extensions of ML (GADTs, higher-rank polymorphism, and static overloading) endanger princpality by introducing _fragile_ constructs that resist principal inference. Existing approaches recover principality through directional inference algorithms, which propagate _known_ type information in a fixed (or static) order (e.g. as in bidirectional typing) to disambiguate such constructs. However, the rigidity of a static inference order often causes otherwise well-typed programs to be rejected.
  We propose _omnidirectional_ type inference, where type information flows in a dynamic order. Typing constraints may be solved in any order, suspending when progress requires known type information and resuming once it becomes available, using _suspended match constraints_. This approach is straightforward for simply typed systems, but extending it to ML is challenging due to let-generalization. Existing ML inference algorithms type let-bindings (let x = e1 in e2) in a fixed order: type e1, generalize its type, and then type e2. To overcome this, we introduce _incremental instantiation_, allowing partially solved type schemes containing suspended constraints to be instantiated, with a mechanism to incrementally update instances as the scheme is refined.
  Omnidirectionality provides a general framework for restoring principality in the presence of fragile features. We demonstrate its versatility on two fundamentally different features of OCaml: static overloading of record labels and datatype constructors and semi-explicit first-class polymorphism. In both cases, we obtain a principal type inference algorithm that is more expressive than OCaml's current typechecker.

</details>


### [3] [Lazy Linearity for a Core Functional Language](https://arxiv.org/abs/2511.10361)
*Rodrigo Mesquita,Bernardo Toninho*

Main category: cs.PL

TL;DR: 本文提出了Linear Core系统，将线性类型与惰性求值语义相结合，解决了Haskell优化编译器中语法线性性被破坏但语义保持的问题。


<details>
  <summary>Details</summary>
Motivation: 传统线性类型语言中，线性资源的消耗与其在程序中的语法出现等同。但在非严格求值下，线性性应从语义角度理解，语法出现不一定意味着实际使用。Haskell优化编译器会重写程序，破坏语法线性性但保持语义，这促使需要新的系统来处理这种差异。

Method: 引入Linear Core系统，该系统静态接受线性性的惰性语义，适用于惰性语言如GHC的Core中间语言。证明系统是健全的，保证线性资源使用，且多个优化转换在Linear Core中保持线性性而在Core中失败。

Result: 实现了Linear Core作为编译器插件，验证了系统在线性性密集型库（包括linear-base）中的有效性。

Conclusion: Linear Core成功解决了惰性语言中线性类型与优化编译之间的冲突，为线性类型在惰性函数式语言中的实际应用提供了可行方案。

Abstract: Traditionally, in linearly typed languages, consuming a linear resource is synonymous with its syntactic occurrence in the program. However, under the lens of non-strict evaluation, linearity can be further understood semantically, where a syntactic occurrence of a resource does not necessarily entail using that resource when the program is executed. While this distinction has been largely unexplored, it turns out to be inescapable in Haskell's optimising compiler, which heavily rewrites the source program in ways that break syntactic linearity but preserve the program's semantics. We introduce Linear Core, a novel system which accepts the lazy semantics of linearity statically and is suitable for lazy languages such as the Core intermediate language of the Glasgow Haskell Compiler. We prove that Linear Core is sound, guaranteeing linear resource usage, and that multiple optimising transformations preserve linearity in Linear Core while failing to do so in Core. We have implemented Linear Core as a compiler plugin to validate the system against linearity-heavy libraries, including linear-base.

</details>


### [4] [Modeling Layout Abstractions Using Integer Set Relations](https://arxiv.org/abs/2511.10374)
*Somashekaracharya G Bhaskaracharya,Aravind Acharya,Bastian Hagedorn,Vinod Grover*

Main category: cs.PL

TL;DR: 该论文提出了一种使用整数集库（ISL）来统一表示CuTe布局和Triton线性布局的数学方法，通过整数集关系建立两种布局系统的统一表示，支持形式化分析和正确性验证。


<details>
  <summary>Details</summary>
Motivation: 现代深度学习编译器依赖布局抽象来管理逻辑张量结构与物理内存排列的复杂映射。CuTe布局和Triton线性布局是广泛采用的行业标准，但它们基于不同的数学基础独立运行，阻碍了统一的形式化分析和跨系统推理。

Method: 使用整数集库（ISL）创建统一的数学表示：对于CuTe布局，通过整数集关系编码从多维坐标到线性索引的转换，包括使用基于步长的计算和复杂的swizzle操作；对于Triton线性布局，构建整数集关系来建模二进制向量空间变换，其中算术运算遵循有限域F_2规则。

Result: 实现了一套完整的布局操作算法（组合、反转、补集），使用ISL内置操作确保数学正确性和布局语义保持。实验评估表明系统能够处理从基本恒等变换到具有复杂步长配置和swizzle模式的多维张量排列的完整布局复杂度谱系。

Conclusion: 该方法成功地在不同布局范式之间验证了数学建模方法，为未来的跨系统优化策略奠定了基础。

Abstract: Modern deep learning compilers rely on layout abstractions to manage the complex mapping between logical tensor structures and physical memory arrangements. CuTe layouts and Triton linear layouts are widely adopted industry standards. However, these layout systems operate independently with distinct mathematical underpinnings, preventing unified formal analysis and cross-system reasoning. We bridge this gap by introducing a novel approach that leverages the Integer Set Library (ISL) to create a unified mathematical representation for both layout systems through integer set relations, thereby enabling rigorous formal analysis, correctness verification, and the foundation for future cross-system optimization strategies. Our approach models CuTe layouts through integer set relations that encode the transformation from multi-dimensional coordinates to linear indices using stride-based calculations, including sophisticated swizzle operations that perform bit-level manipulations for enhanced memory access patterns. For Triton linear layouts, we construct integer set relations that model the binary vector space transformations where arithmetic operations follow finite field F_2 rules. We implement a complete suite of layout manipulation algorithms for composition, inversion, complement using built-in operations in ISL to ensure mathematical correctness and preserve layout semantics. Experimental evaluation shows that the system handles the full spectrum of layout complexity, from elementary identity transformations to sophisticated multi-dimensional tensor arrangements with complex stride configurations and swizzle patterns, validating the mathematical modeling approach across different layout paradigms.

</details>


### [5] [zkStruDul: Programming zkSNARKs with Structural Duality](https://arxiv.org/abs/2511.10565)
*Rahul Krishnan,Ashley Samuelson,Emily Yao,Ethan Cecchetti*

Main category: cs.PL

TL;DR: zkStruDul是一个统一输入转换和谓词定义的语言，通过单一抽象消除重复代码和安全风险，支持递归证明等特性


<details>
  <summary>Details</summary>
Motivation: 现有NIZK工具将谓词定义和输入转换分开实现，导致逻辑重复且容易产生安全漏洞，需要统一抽象来避免这些问题

Method: 开发zkStruDul语言，将输入转换和谓词定义统一为单一抽象，编译器可从中投影出两个过程，消除重复代码和错误匹配

Result: 提供了源级语义并证明其行为与投影语义相同，支持递归证明等重要特性

Conclusion: zkStruDul通过统一抽象解决了NIZK应用中逻辑重复和安全风险问题，为现有NIZK技术提供了高层抽象

Abstract: Non-Interactive Zero Knowledge (NIZK) proofs, such as zkSNARKS, let one prove knowledge of private data without revealing it or interacting with a verifier. While existing tooling focuses on specifying the predicate to be proven, real-world applications optimize predicate definitions to minimize proof generation overhead, but must correspondingly transform predicate inputs. Implementing these two steps separately duplicates logic that must precisely match to avoid catastrophic security flaws. We address this shortcoming with zkStruDul, a language that unifies input transformations and predicate definitions into a single combined abstraction from which a compiler can project both procedures, eliminating duplicate code and problematic mismatches. zkStruDul provides a high-level abstraction to layer on top of existing NIZK technology and supports important features like recursive proofs. We provide a source-level semantics and prove its behavior is identical to the projected semantics, allowing straightforward standard reasoning.

</details>
