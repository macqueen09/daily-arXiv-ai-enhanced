<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 4]
- [cs.CY](#cs.CY) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Data Race Detection by Digest-Driven Abstract Interpretation (Extended Version)](https://arxiv.org/abs/2511.11055)
*Michael Schwarz,Julian Erhard*

Main category: cs.PL

TL;DR: 该论文提出了一种基于摘要的静态数据竞争检测方法，通过捕获冲突访问不能并行发生的条件来证明数据竞争的缺失。


<details>
  <summary>Details</summary>
Motivation: 将摘要概念从线程模块化值分析重新用于数据竞争检测，以捕获冲突内存访问不能同时发生的条件。

Method: 在Goblint静态分析器中实现摘要驱动的数据竞争检测，结合锁集摘要与线程ID和线程连接的摘要推理。

Result: 在SV-COMP基准测试套件上，结合锁集摘要与线程ID和线程连接摘要相比单独使用锁集推理，正确解决任务数量增加了五倍以上。

Conclusion: 摘要驱动的数据竞争检测方法显著提高了静态分析器检测数据竞争的能力，证明了该方法在证明无数据竞争方面的有效性。

Abstract: Sound static analysis can prove the absence of data races by establishing that no two conflicting memory accesses can occur at the same time. We repurpose the concept of digests -- summaries of computational histories originally introduced to bring tunable concurrency-sensitivity to thread-modular value analysis by abstract interpretation, extending this idea to race detection: We use digests to capture the conditions under which conflicting accesses may not happen in parallel. To formalize this, we give a definition of data races in the thread-modular local trace semantics and show how exclusion criteria for potential conflicts can be expressed as digests. We report on our implementation of digest-driven data race detection in the static analyzer Goblint, and evaluate it on the SV-COMP benchmark suite. Combining the lockset digest with digests reasoning on thread ids and thread joins increases the number of correctly solved tasks by more than a factor of five compared to lockset reasoning alone.

</details>


### [2] [Optimising Density Computations in Probabilistic Programs via Automatic Loop Vectorisation](https://arxiv.org/abs/2511.11070)
*Sangho Lim,Hyoungjin Lim,Wonyeol Lee,Xavier Rival,Hongseok Yang*

Main category: cs.PL

TL;DR: 提出了一种自动向量化概率程序中循环的方法，通过推测性并行执行循环迭代来提高性能，同时通过定点检查保持原始循环语义。


<details>
  <summary>Details</summary>
Motivation: 概率推理在处理大型数据集或长序列随机样本时成本高昂，现有向量化方法要么需要手动操作容易出错，要么无法处理通用循环结构如嵌套循环和数据依赖控制流。

Method: 将命令式概率编程语言翻译为支持向量化原语的底层目标语言，使用推测性并行执行循环迭代，并通过定点检查保持语义正确性。

Result: 在Pyro概率编程语言上实现该方法，实验显示相比现有基线获得1.1-6倍加速，并减少GPU内存使用，且能处理所有测试模型。

Conclusion: 该方法能有效自动向量化概率程序中的循环，显著提升性能并减少内存使用，且适用范围更广。

Abstract: Probabilistic programming languages (PPLs) are a popular tool for high-level modelling across many fields. They provide a range of algorithms for probabilistic inference, which analyse models by learning their parameters from a dataset or estimating their posterior distributions. However, probabilistic inference is known to be very costly. One of the bottlenecks of probabilistic inference stems from the iteration over entries of a large dataset or a long series of random samples. Vectorisation can mitigate this cost, but manual vectorisation is error-prone, and existing automatic techniques are often ad-hoc and limited, unable to handle general repetition structures, such as nested loops and loops with data-dependent control flow, without significant user intervention. To address this bottleneck, we propose a sound and effective method for automatically vectorising loops in probabilistic programs. Our method achieves high throughput using speculative parallel execution of loop iterations, while preserving the semantics of the original loop through a fixed-point check. We formalise our method as a translation from an imperative PPL into a lower-level target language with primitives geared towards vectorisation. We implemented our method for the Pyro PPL and evaluated it on a range of probabilistic models. Our experiments show significant performance gains against an existing vectorisation baseline, achieving $1.1$--$6\times$ speedups and reducing GPU memory usage in many cases. Unlike the baseline, which is limited to a subset of models, our method effectively handled all the tested models.

</details>


### [3] [Kleene Algebra](https://arxiv.org/abs/2511.11264)
*Tobias Kappé,Alexandra Silva,Jana Wagemaker*

Main category: cs.PL

TL;DR: 这篇小册子介绍了Kleene代数(KA)，它是一组用于研究程序等价性的定律。内容涵盖用正则表达式建模程序、表达式与自动机的对应关系，以及KA的核心结果：正则表达式等价当且仅当可以用KA定律证明。


<details>
  <summary>Details</summary>
Motivation: 为研究程序等价性提供理论基础，通过代数方法分析程序的语义等价关系。

Method: 使用正则表达式建模程序，建立正则表达式与自动机的对应关系，并利用Kleene代数的定律体系进行形式化证明。

Result: 证明了KA的核心结果：正则表达式的等价性可以通过KA的定律来证明，反之亦然。

Conclusion: Kleene代数为程序等价性研究提供了完整的代数框架，通过正则表达式和自动机的对应关系建立了形式化的理论基础。

Abstract: This booklet serves as an introduction to Kleene Algebra (KA), a set of laws that can be used to study general equivalences between programs. It discusses how general programs can be modeled using regular expressions, how those expressions correspond to automata, and how this correspondence can be exploited to obtain the central result of KA, namely that an equivalence of regular expressions is true if and only if it can be proved using the laws of KA. Each chapter closes with a set of exercises to further build intuition and understanding, and there is an optional chapter that develops automata theory through the lens of coalgebra.

</details>


### [4] [The Jasmin Compiler Preserves Cryptographic Security](https://arxiv.org/abs/2511.11292)
*Santiago Arranz-Olmos,Gilles Barthe,Lionel Blatter,Benjamin Grégoire,Vincent Laporte,Paolo Torrini*

Main category: cs.PL

TL;DR: 本文显著增强了Jasmin编译器的安全保障，证明其前端（25/30个编译过程）在Rocq证明器中能保持密码学安全性，包括针对非终止和概率计算的保护。


<details>
  <summary>Details</summary>
Motivation: Jasmin框架原有的功能正确性证明不适用于密码学中必需的非终止和概率计算，需要增强编译器在密码学安全性方面的保证。

Method: 1) 定义适用于编译器正确性证明的关系式霍尔逻辑；2) 基于交互树的新语义证明程序逻辑的可靠性；3) 使用该逻辑证明Jasmin编译器的功能正确性；4) 用交互树形式化密码学安全性（IND-CCA）并证明编译器保持该安全性。

Result: 成功证明Jasmin编译器前端（25个编译过程）在Rocq证明器中能保持密码学安全性，为密码实现提供了更强的形式化验证保障。

Conclusion: 通过新的程序逻辑和语义模型，显著提升了Jasmin编译器在密码学安全性方面的形式化验证能力，为开发安全密码实现提供了更可靠的框架。

Abstract: Jasmin is a programming and verification framework for developing efficient, formally verified, cryptographic implementations. A main component of the framework is the Jasmin compiler, which empowers programmers to write efficient implementations of state-of-the-art cryptographic primitives, including post-quantum cryptographic standards. The Jasmin compiler is proven functionally correct in the Rocq prover. However, this functional correctness statement does not apply to nonterminating or probabilistic computations, which are essential features in cryptography.
  In this paper, we significantly enhance the guarantees of the compiler by showing, in the Rocq prover, that its front-end (25 out of 30 passes) preserves cryptographic security. To this end, we first define a Relational Hoare Logic tailored for compiler correctness proofs. We prove the soundness of our logic w.r.t. a new denotational semantics of Jasmin programs based on interaction trees. Secondly, we use our program logic to prove the functional correctness of the (unmodified) Jasmin compiler w.r.t. said semantics. Lastly, we formalize cryptographic security -- focusing on IND-CCA -- with interaction trees and prove that the Jasmin compiler preserves cryptographic security.

</details>


<div id='cs.CY'></div>

# cs.CY [[Back]](#toc)

### [5] [AI as a component in the action research tradition of learning-by-doing](https://arxiv.org/abs/2511.11445)
*Ian Benson,Alexei Semenov*

Main category: cs.CY

TL;DR: 提出基于行动研究、黑客精神、发现和动手学习的数学教育模式，反对19世纪的工业教学模式，强调自我意识、类型、函数、结构化绘图和形式化图表。


<details>
  <summary>Details</summary>
Motivation: 解决传统练习和统计预测的弱点，避免大型语言模型的陷阱，建立基于专业数学家建模和程序设计活动的数学/信息学教育。

Method: 采用语言/行动方法，教师设计数学化情境来支持学习者解决未知问题，通过师生书面-口头对话（通常1对1），并由更资深的同学担任教师/对话者角色（每5-7名学生配1名）。

Result: 提出人类智能通过数字技术增强的隐喻，将学习者分为生物部分（通过内心对话反应）和数字部分（提出问题、解释代码、提出想法）。

Conclusion: 构建了基于专业数学实践、强调对话和动手的数学教育框架，结合数字技术增强人类智能，形成生物-数字混合的学习模式。

Abstract: We consider learning mathematics through action research, hacking, discovery, inquiry, learning-by-doing as opposed to the instruct and perform, industrial model of the 19th century. A learning model based on self-awareness, types, functions, structured drawing and formal diagrams addresses the weaknesses of drill and practice and the pitfalls of statistical prediction with Large Language Models.
  In other words, we build mathematics/informatics education on the activity of a professional mathematician in mathematical modelling and designing programs. This tradition emphasises the role of dialogue and doing mathematics. In the Language/Action approach the teacher designs mathematising situations that scaffold previously encountered, or not-known-how-to-solve problems for the learner while teachers and teacher/interlocutors supervise the process.
  A critical feature is the written-oral dialogue between the learner and the teacher. As a rule, this is 1 to 1 communication. The role of the teacher/interlocutor, a more knowledgeable other, is mostly performed by a more senior student, 1 per 5 to 7 pupils. After Doug Engelbart we propose the metaphor of human intellect augmented by digital technologies such as interactive development environments or AI. Every human has their bio and digital parts. The bio part of the learner reacts to their work through dialogue in the mind. The digital part poses questions, interprets code and proposes not necessarily sound ideas.

</details>
