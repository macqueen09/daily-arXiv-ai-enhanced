<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 6]
- [cs.SE](#cs.SE) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Compiling to recurrent neurons](https://arxiv.org/abs/2511.14953)
*Joey Velez-Ginorio,Nada Amin,Konrad Kording,Steve Zdancewic*

Main category: cs.PL

TL;DR: 该论文提出了一种将离散结构（如迭代）编译为可微分形式的方法，使迭代成为可微分编程中的一等公民，从而扩展了可微分算法的表达能力。


<details>
  <summary>Details</summary>
Motivation: 当前可微分编程中离散结构是二等公民，缺乏显式导数，限制了条件语句和迭代的使用范围，进而限制了可微分算法的表达能力。

Method: 设计了一个名为Cajal的最小类型化、高阶线性编程语言，包含迭代功能，并证明其程序可以正确编译为循环神经元。

Result: 通过实验验证，将循环神经元与神经网络结合用于迭代图像变换任务，网络学习速度更快且数据效率更高。

Conclusion: 循环神经元实现了学习与普通编程离散结构之间的丰富交互，扩展了可微分编程的能力。

Abstract: Discrete structures are currently second-class in differentiable programming. Since functions over discrete structures lack overt derivatives, differentiable programs do not differentiate through them and limit where they can be used. For example, when programming a neural network, conditionals and iteration cannot be used everywhere; they can break the derivatives necessary for gradient-based learning to work. This limits the class of differentiable algorithms we can directly express, imposing restraints on how we build neural networks and differentiable programs more generally. However, these restraints are not fundamental. Recent work shows conditionals can be first-class, by compiling them into differentiable form as linear neurons. Similarly, this work shows iteration can be first-class -- by compiling to linear recurrent neurons. We present a minimal typed, higher-order and linear programming language with iteration called $\textsf{Cajal}\scriptstyle(\mathbb{\multimap}, \mathbb{2}, \mathbb{N})$. We prove its programs compile correctly to recurrent neurons, allowing discrete algorithms to be expressed in a differentiable form compatible with gradient-based learning. With our implementation, we conduct two experiments where we link these recurrent neurons against a neural network solving an iterative image transformation task. This determines part of its function prior to learning. As a result, the network learns faster and with greater data-efficiency relative to a neural network programmed without first-class iteration. A key lesson is that recurrent neurons enable a rich interplay between learning and the discrete structures of ordinary programming.

</details>


### [2] [Compiling Set Queries into Work-Efficient Tree Traversals](https://arxiv.org/abs/2511.15000)
*Alexander J Root,Christophe Gyurgyik,Purvi Goel,Kayvon Fatahalian,Jonathan Ragan-Kelley,Andrew Adams,Fredrik Kjolstad*

Main category: cs.PL

TL;DR: 本文提出了一种自动生成树结构查询优化的通用方法，通过符号区间分析和几何谓词处理，能够自动推导出支持广泛连接谓词的树遍历算法。


<details>
  <summary>Details</summary>
Motivation: 现有系统需要为每个查询谓词和数据结构手动实现剪枝逻辑，这限制了查询优化的通用性和效率。

Method: 使用符号区间分析生成子树剪枝条件，扩展规则处理几何谓词，并将复合查询融合为单次树遍历。

Result: 生成的遍历算法与专家手写代码行为一致，在无手写优化的情况下显著优于线性扫描和嵌套循环连接。

Conclusion: 该方法能够自动推导通用树索引和双索引树连接，支持超出标准相等和范围谓词的广泛连接谓词类别。

Abstract: Trees can accelerate queries that search or aggregate values over large collections. They achieve this by storing metadata that enables quick pruning (or inclusion) of subtrees when predicates on that metadata can prove that none (or all) of the data in a subtree affect the query result. Existing systems implement this pruning logic manually for each query predicate and data structure. We generalize and mechanize this class of optimization. Our method derives conditions for when subtrees can be pruned (or included wholesale), expressed in terms of the metadata available at each node. We efficiently generate these conditions using symbolic interval analysis, extended with new rules to handle geometric predicates (e.g., intersection, containment). Additionally, our compiler fuses compound queries (e.g., reductions on filters) into a single tree traversal. These techniques enable the automatic derivation of generalized single-index and dual-index tree joins that support a wide class of join predicates beyond standard equality and range predicates. The generated traversals match the behavior of expert-written code that implements query-specific traversals, and can asymptotically outperform the linear scans and nested-loop joins that existing systems fall back to when hand-written cases do not apply.

</details>


### [3] [Data Layout Polymorphism for Bounding Volume Hierarchies](https://arxiv.org/abs/2511.15028)
*Christophe Gyurgyik,Alexander J Root,Fredrik Kjolstad*

Main category: cs.PL

TL;DR: Scion是一种用于边界体积层次结构数据布局的领域特定语言和编译器，将数据布局与遍历算法解耦，实现跨架构的性能优化。


<details>
  <summary>Details</summary>
Motivation: 传统编程系统中边界体积层次结构的数据布局与遍历逻辑紧密耦合，阻碍了在不同上下文中的独立优化，导致性能与可移植性之间的虚假二分法。

Method: 开发Scion领域特定语言和编译器，允许独立指定边界体积层次结构的数据布局，支持广泛的布局优化技术。

Result: 通过系统化设计探索，发现帕累托最优布局随算法、架构和工作负载特性而变化，并识别出一种结合先前优化技术的新型光线追踪布局。

Conclusion: Scion能够表达高性能计算中使用的各种布局优化，同时保持架构无关性，证明了解耦数据布局与遍历算法的可行性。

Abstract: Bounding volume hierarchies are ubiquitous acceleration structures in graphics, scientific computing, and data analytics. Their performance depends critically on data layout choices that affect cache utilization, memory bandwidth, and vectorization -- increasingly dominant factors in modern computing. Yet, in most programming systems, these layout choices are hopelessly entangled with the traversal logic. This entanglement prevents developers from independently optimizing data layouts and algorithms across different contexts, perpetuating a false dichotomy between performance and portability. We introduce Scion, a domain-specific language and compiler for specifying the data layouts of bounding volume hierarchies independent of tree traversal algorithms. We show that Scion can express a broad spectrum of layout optimizations used in high performance computing while remaining architecture-agnostic. We demonstrate empirically that Pareto-optimal layouts (along performance and memory footprint axes) vary across algorithms, architectures, and workload characteristics. Through systematic design exploration, we also identify a novel ray tracing layout that combines optimization techniques from prior work, achieving Pareto-optimality across diverse architectures and scenes.

</details>


### [4] [Cement2: Temporal Hardware Transactions for High-Level and Efficient FPGA Programming](https://arxiv.org/abs/2511.15073)
*Youwei Xiao,Zizhang Luo,Weijie Peng,Yuyang Zou,Yun Liang*

Main category: cs.PL

TL;DR: 提出了一种名为时间硬件事务的新抽象，将周期级时序意识引入事务级语言，支持描述跨多个时钟周期的规则，在Cement2中实现并验证了其高效性。


<details>
  <summary>Details</summary>
Motivation: 硬件设计面临提升抽象度以提高生产力与保持对低级别细节控制之间的根本挑战。传统RTL设计通过连线式连接提供弱行为正确性保证，而HLS和其他抽象方法要么引入不可预测的开销，要么限制设计通用性。

Method: 提出时间硬件事务抽象，在Cement2（嵌入Rust的事务性HDL）中实现，支持描述跨多个时钟周期的规则，通过多阶段分析和优化降低抽象级别生成高效硬件。

Result: 使用Cement2编程了RISC-V软核处理器、自定义CPU指令、线性代数内核和脉动阵列加速器，评估显示与手写RTL设计相比不牺牲性能和资源。

Conclusion: Cement2的时间硬件事务抽象为通用FPGA设计任务提供了高适用性，通过高层次抽象提升了生产力而不损失性能。

Abstract: Hardware design faces a fundamental challenge: raising abstraction to improve productivity while maintaining control over low-level details like cycle accuracy. Traditional RTL design in languages like SystemVerilog composes modules through wiring-style connections that provide weak guarantees for behavioral correctness. While high-level synthesis (HLS) and emerging abstractions attempt to address this, they either introduce unpredictable overhead or restrict design generality. Although transactional HDLs provide a promising foundation by lifting design abstraction to atomic and composable rules, they solely model intra-cycle behavior and do not reflect the native temporal design characteristics, hindering applicability and productivity for FPGA programming scenarios.
  We propose temporal hardware transactions, a new abstraction that brings cycle-level timing awareness to designers at the transactional language level. Our approach models temporal relationships between rules and supports the description of rules whose actions span multiple clock cycles, providing intuitive abstraction to describe multi-cycle architectural behavior. We implement this in Cement2, a transactional HDL embedded in Rust, enabling programming hardware constructors to build both intra-cycle and temporal transactions. Cement2's synthesis framework lowers description abstraction through multiple analysis and optimization phases, generating efficient hardware. With Cement2's abstraction, we program a RISC-V soft-core processor, custom CPU instructions, linear algebra kernels, and systolic array accelerators, leveraging the high-level abstraction for boosted productivity. Evaluation shows that Cement2 does not sacrifice performance and resources compared to hand-coded RTL designs, demonstrating the high applicability for general FPGA design tasks.

</details>


### [5] [SkyEgg: Joint Implementation Selection and Scheduling for Hardware Synthesis using E-graphs](https://arxiv.org/abs/2511.15323)
*Youwei Xiao,Yuyang Zou,Yun Liang*

Main category: cs.PL

TL;DR: SkyEgg是一个新颖的硬件合成框架，通过e-graph数据结构联合优化实现选择与调度，解决了传统HLS工具中这两个步骤分离导致的次优设计问题。


<details>
  <summary>Details</summary>
Motivation: 传统硬件合成方法将实现选择与调度分离优化，导致无法充分利用现代FPGA异构架构的优势，产生次优设计。实现选择通常通过临时模式匹配完成，不考虑对调度的影响，而调度算法基于固定的选择方案和不准确的延迟估计。

Method: 1. 从输入程序构建e-graph；2. 通过等式饱和应用代数和实现重写规则；3. 在饱和e-graph上将联合优化建模为混合整数线性规划问题；4. 提供精确MILP求解和高效的ASAP启发式方法。

Result: 在针对Xilinx Kintex UltraScale+ FPGA的多样化应用基准测试中，SkyEgg相比Vitis HLS实现了平均3.01倍的加速，对于复杂表达式最高可达5.22倍的改进。

Conclusion: SkyEgg通过联合优化实现选择与调度，有效克服了传统硬件合成方法的局限性，能够充分利用现代FPGA架构的优势，显著提升性能。

Abstract: Hardware synthesis from high-level descriptions remains fundamentally limited by the sequential optimization of interdependent design decisions. Current methodologies, including state-of-the-art high-level synthesis (HLS) tools, artificially separate implementation selection from scheduling, leading to suboptimal designs that cannot fully exploit modern FPGA heterogeneous architectures. Implementation selection is typically performed by ad-hoc pattern matching on operations, a process that does not consider the impact on scheduling. Subsequently, scheduling algorithms operate on fixed selection solutions with inaccurate delay estimates, which misses critical optimization opportunities from appropriately configured FPGA blocks like DSP slices.
  We present SkyEgg, a novel hardware synthesis framework that jointly optimizes implementation selection and scheduling using the e-graph data structure. Our key insight is that both algebraic transformations and hardware implementation choices can be uniformly represented as rewrite rules within an e-graph, modeling the complete design space of implementation candidates to be selected and scheduled together. First, SkyEgg constructs an e-graph from the input program. It then applies both algebraic and implementation rewrites through equality saturation. Finally, it formulates the joint optimization as a mixed-integer linear programming (MILP) problem on the saturated e-graph. We provide both exact MILP solving and an efficient ASAP heuristic for scalable synthesis. Our evaluation on benchmarks from diverse applications targeting Xilinx Kintex UltraScale+ FPGAs demonstrates that SkyEgg achieves an average speedup of 3.01x over Vitis HLS, with improvements up to 5.22x for complex expressions.

</details>


### [6] [Graph Rewriting Language as a Platform for Quantum Diagrammatic Calculi](https://arxiv.org/abs/2511.15581)
*Kayo Tei,Haruto Mishina,Naoki Yamamoto,Kazunori Ueda*

Main category: cs.PL

TL;DR: 使用通用图重写语言LMNtal构建量子电路简化的图示变换和验证平台，通过原生图变换规则、量化模式匹配和状态空间探索实现ZX图的操作和优化路径分析。


<details>
  <summary>Details</summary>
Motivation: 量子电路简化的优化路径系统发现仍具挑战性，现有工具如PyZX和Quantomatic提供特定领域支持，但需要从不同视角研究量子电路变换的新平台。

Method: 利用LMNtal通用层次图重写语言，通过原生图变换规则直接实现ZX图基本规则，使用QLMNtal扩展进行量化模式匹配简化规则规范，并通过状态空间探索实现交互式可视化和优化路径验证。

Result: 案例研究表明该框架有助于理解优化路径并设计新算法和策略，证明LMNtal可作为研究量子电路变换的新平台。

Conclusion: 声明式语言LMNtal及其工具链为从不同视角研究量子电路变换提供了新的平台可能性。

Abstract: Systematic discovery of optimization paths in quantum circuit simplification remains a challenge. Today, ZX-calculus, a computing model for quantum circuit transformation, is attracting attention for its highly abstract graph-based approach. Whereas existing tools such as PyZX and Quantomatic offer domain-specific support for quantum circuit optimization, visualization and theorem-proving, we present a complementary approach using LMNtal, a general-purpose hierarchical graph rewriting language, to establish a diagrammatic transformation and verification platform with model checking. Our methodology shows three advantages: (1) manipulation of ZX-diagrams through native graph transformation rules, enabling direct implementation of basic rules; (2) quantified pattern matching via QLMNtal extensions, greatly simplifying rule specification; and (3) interactive visualization and validation of optimization paths through state space exploration. Through case studies, we demonstrate how our framework helps understand optimization paths and design new algorithms and strategies. This suggests that the declarative language LMNtal and its toolchain could serve as a new platform to investigate quantum circuit transformation from a different perspective.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [7] [MutDafny: A Mutation-Based Approach to Assess Dafny Specifications](https://arxiv.org/abs/2511.15403)
*Isabel Amaral,Alexandra Mendes,José Campos*

Main category: cs.SE

TL;DR: 提出了MutDafny工具，通过变异测试来检测Dafny形式化规范中的弱点，能够自动识别可能导致已验证程序偏离预期行为的规范缺陷。


<details>
  <summary>Details</summary>
Motivation: 在验证感知编程语言如Dafny中，规范与实现一样容易出错。规范中的缺陷可能导致形式化验证的程序偏离预期行为，因此需要提高Dafny规范的可靠性。

Method: 采用变异测试方法，在代码中引入故障（变异），依赖形式化规范来检测这些变异。如果带有变异的程序仍能通过验证，则表明规范可能存在弱点。从流行工具中分析适用的变异算子，并从GitHub上的Dafny项目bug修复提交中合成新的算子，共包含32个变异算子。

Result: 在794个真实世界Dafny程序数据集上评估MutDafny的有效性和效率。手动分析未检测到的变异子集，识别出5个弱真实世界规范（平均每241行代码就有一个），这些规范需要加强。

Conclusion: MutDafny工具能够有效识别Dafny规范中的潜在弱点，提高形式化验证的可靠性，通过变异测试方法为规范质量提供了实用的评估手段。

Abstract: This paper explores the use of mutation testing to reveal weaknesses in formal specifications written in Dafny. In verification-aware programming languages, such as Dafny, despite their critical role, specifications are as prone to errors as implementations. Flaws in specs can result in formally verified programs that deviate from the intended behavior.
  We present MutDafny, a tool that increases the reliability of Dafny specifications by automatically signaling potential weaknesses. Using a mutation testing approach, we introduce faults (mutations) into the code and rely on formal specifications for detecting them. If a program with a mutant verifies, this may indicate a weakness in the specification. We extensively analyze mutation operators from popular tools, identifying the ones applicable to Dafny. In addition, we synthesize new operators tailored for Dafny from bugfix commits in publicly available Dafny projects on GitHub. Drawing from both, we equipped our tool with a total of 32 mutation operators. We evaluate MutDafny's effectiveness and efficiency in a dataset of 794 real-world Dafny programs and we manually analyze a subset of the resulting undetected mutants, identifying five weak real-world specifications (on average, one at every 241 lines of code) that would benefit from strengthening.

</details>
