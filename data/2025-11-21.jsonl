{"id": "2511.15819", "pdf": "https://arxiv.org/pdf/2511.15819", "abs": "https://arxiv.org/abs/2511.15819", "authors": ["Bohdan Liesnikov", "David Binder", "Tim Süberkrüb"], "title": "Filling the Gaps of Polarity: Implementing Dependent Data and Codata Types with Implicit Arguments", "categories": ["cs.PL"], "comment": null, "summary": "The expression problem describes a fundamental tradeoff between two types of extensibility: extending a type with new operations, such as by pattern matching on an algebraic data type in functional programming, and extending a type with new constructors, such as by adding a new object implementing an interface in object-oriented programming. Most dependently typed languages have good support for the former style through inductive types, but support for the latter style through coinductive types is usually much poorer. Polarity is a language that treats both kinds of types symmetrically and allows the developer to switch between type representations.However, it currently lacks several features expected of a state-of-the-art dependently typed language, such as implicit arguments. The central aim of this paper is to provide an algorithmic type system and inference algorithm for implicit arguments that respect the core symmetry of the language. Our work provides two key contributions: a complete algorithmic description of the type system backing Polarity, and a comprehensive description of a unification algorithm that covers arbitrary inductive and coinductive types. We give rules for reduction semantics, conversion checking, and a unification algorithm for pattern-matching, which are essential for a usable implementation. A work-in-progress implementation of the algorithms in this paper is available at https://polarity-lang.github.io/. We expect that the comprehensive account of the unification algorithm and our design decisions can serve as a blueprint for other dependently typed languages that support inductive and coinductive types symmetrically."}
{"id": "2511.15820", "pdf": "https://arxiv.org/pdf/2511.15820", "abs": "https://arxiv.org/abs/2511.15820", "authors": ["Ashton Wiersdorf", "Ben Greenman"], "title": "Chorex: Restartable, Language-Integrated Choreographies", "categories": ["cs.PL"], "comment": null, "summary": "We built Chorex, a language that brings choreographic programming to Elixir as a path toward robust distributed applications. Chorex is unique among choreographic languages because it tolerates failure among actors: when an actor crashes, Chorex spawns a new process, restores state using a checkpoint, and updates the network configuration for all actors. Chorex also proves that full-featured choreographies can be implemented via metaprogramming, and that doing so achieves tight integration with the host language. For example, mismatches between choreography requirements and an actor implementation are reported statically and in terms of source code rather than macro-expanded code. This paper illustrates Chorex on several examples, ranging from a higher-order bookseller to a secure remote password protocol, details its implementation, and measures the overhead of checkpointing. We conjecture that Chorex's projection strategy, which outputs sets of stateless functions, is a viable approach for other languages to support restartable actors."}
{"id": "2511.15821", "pdf": "https://arxiv.org/pdf/2511.15821", "abs": "https://arxiv.org/abs/2511.15821", "authors": ["Fumika Mochizuki", "Tetsuro Yamazaki", "Shigeru Chiba"], "title": "BlueScript: A Disaggregated Virtual Machine for Microcontrollers", "categories": ["cs.PL"], "comment": null, "summary": "Virtual machines (VMs) are highly beneficial for microcontroller development. \nIn particular, interactive programming environments greatly facilitate iterative development processes, \nand higher execution speeds expand the range of applications that can be developed. \nHowever, due to their limited memory size, microcontroller VMs provide a limited set of features. \nWidely used VMs for microcontrollers often lack interactive responsiveness and/or high execution speed. \nWhile researchers have investigated offloading certain VM components to other machines,the types of components that can be offloaded are still restricted. \nIn this paper, we propose a disaggregated VM that offloads as many components as possible to a host machine. \nThis makes it possible to exploit the abundant memory of the host machine and its powerful processing capability to provide rich features through the VM. \nAs an instance of a disaggregated VM, we design and implement a BlueScript VM. \nThe BlueScript VM is a virtual machine for microcontrollers that provides an interactive development environment. \nWe offload most of the components of the BlueScript VM to a host machine. \nTo reduce communication overhead between the host machine and the microcontroller,  \nwe employed a data structure called a shadow machine on the host machine, \nwhich mirrors the execution state of the microcontroller. \nThrough our experiments, we confirmed that offloading components does not seriously compromise their expected benefits.  \nWe assess that an offloaded incremental compiler results in faster execution speed than MicroPython and Espruino,  \nwhile keeping interactivity comparable with MicroPython.  \nIn addition, our experiments observe that the offloaded dynamic compiler improves VM performance. \nThrough this investigation, we demonstrate the feasibility of providing rich features even on VMs for memory-limited microcontrollers."}
{"id": "2511.16080", "pdf": "https://arxiv.org/pdf/2511.16080", "abs": "https://arxiv.org/abs/2511.16080", "authors": ["Sungbin Moon", "Jiho Park", "Suyoung Hwang", "Donghyun Koh", "Seunghyun Moon", "Minhyeong Lee"], "title": "Operon: Incremental Construction of Ragged Data via Named Dimensions", "categories": ["cs.PL", "cs.AI", "cs.LG"], "comment": null, "summary": "Modern data processing workflows frequently encounter ragged data: collections with variable-length elements that arise naturally in domains like natural language processing, scientific measurements, and autonomous AI agents. Existing workflow engines lack native support for tracking the shapes and dependencies inherent to ragged data, forcing users to manage complex indexing and dependency bookkeeping manually. We present Operon, a Rust-based workflow engine that addresses these challenges through a novel formalism of named dimensions with explicit dependency relations. Operon provides a domain-specific language where users declare pipelines with dimension annotations that are statically verified for correctness, while the runtime system dynamically schedules tasks as data shapes are incrementally discovered during execution. We formalize the mathematical foundation for reasoning about partial shapes and prove that Operon's incremental construction algorithm guarantees deterministic and confluent execution in parallel settings. The system's explicit modeling of partially-known states enables robust persistence and recovery mechanisms, while its per-task multi-queue architecture achieves efficient parallelism across heterogeneous task types. Empirical evaluation demonstrates that Operon outperforms an existing workflow engine with 14.94x baseline overhead reduction while maintaining near-linear end-to-end output rates as workloads scale, making it particularly suitable for large-scale data generation pipelines in machine learning applications."}
{"id": "2511.15767", "pdf": "https://arxiv.org/pdf/2511.15767", "abs": "https://arxiv.org/abs/2511.15767", "authors": ["Bardia Nadimi", "Khashayar Filom", "Deming Chen", "Hao Zheng"], "title": "TB or Not TB: Coverage-Driven Direct Preference Optimization for Verilog Stimulus Generation", "categories": ["cs.LG", "cs.AI", "cs.PL"], "comment": null, "summary": "With the rapid advancement of Large Language Models (LLMs), there is growing interest in applying them to hardware design and verification. Among these stages, design verification remains the most time-consuming and resource-intensive phase, where generating effective stimuli for the design under test (DUT) is both critical and labor-intensive. We present {\\it TB or not TB}, a framework for automated stimulus generation using LLMs fine-tuned through Coverage-Driven Direct Preference Optimization (CD-DPO). To enable preference-based training, we introduce PairaNet, a dataset derived from PyraNet that pairs high- and low-quality testbenches labeled using simulation-derived coverage metrics. The proposed CD-DPO method integrates quantitative coverage feedback directly into the optimization objective, guiding the model toward generating stimuli that maximize verification coverage. Experiments on the CVDP CID12 benchmark show that {\\it TB or not TB} outperforms both open-source and commercial baselines, achieving up to 77.27\\% improvement in code coverage, demonstrating the effectiveness of Coverage-driven preference optimization for LLM-based hardware verification."}
{"id": "2511.16395", "pdf": "https://arxiv.org/pdf/2511.16395", "abs": "https://arxiv.org/abs/2511.16395", "authors": ["Kangwei Xu", "Grace Li Zhang", "Ulf Schlichtmann", "Bing Li"], "title": "CorrectHDL: Agentic HDL Design with LLMs Leveraging High-Level Synthesis as Reference", "categories": ["cs.AI", "cs.PL", "cs.SE", "eess.SY"], "comment": "7 pages, 15 figures, 2 tables", "summary": "Large Language Models (LLMs) have demonstrated remarkable potential in hardware front-end design using hardware description languages (HDLs). However, their inherent tendency toward hallucination often introduces functional errors into the generated HDL designs. To address this issue, we propose the framework CorrectHDL that leverages high-level synthesis (HLS) results as functional references to correct potential errors in LLM-generated HDL designs.The input to the proposed framework is a C/C++ program that specifies the target circuit's functionality. The program is provided to an LLM to directly generate an HDL design, whose syntax errors are repaired using a Retrieval-Augmented Generation (RAG) mechanism. The functional correctness of the LLM-generated circuit is iteratively improved by comparing its simulated behavior with an HLS reference design produced by conventional HLS tools, which ensures the functional correctness of the result but can lead to suboptimal area and power efficiency. Experimental results demonstrate that circuits generated by the proposed framework achieve significantly better area and power efficiency than conventional HLS designs and approach the quality of human-engineered circuits. Meanwhile, the correctness of the resulting HDL implementation is maintained, highlighting the effectiveness and potential of agentic HDL design leveraging the generative capabilities of LLMs and the rigor of traditional correctness-driven IC design flows."}
