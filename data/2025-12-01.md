<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 6]
- [cs.SE](#cs.SE) [Total: 1]
- [cs.HC](#cs.HC) [Total: 1]
- [quant-ph](#quant-ph) [Total: 1]
- [cs.LO](#cs.LO) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Expanding Specification Capabilities of a Gradual Verifier with Pure Functions](https://arxiv.org/abs/2511.22075)
*Doruk Alp Mutlu*

Main category: cs.PL

TL;DR: 扩展Gradual C0验证器，引入纯函数支持以增强规范表达能力和简化观察者方法编码


<details>
  <summary>Details</summary>
Motivation: Gradual C0是目前唯一基于符号执行的渐进验证器，支持递归堆数据结构，但其规范语言在复杂表达式方面能力有限，需要扩展表达能力

Method: 扩展Gradual C0设计，引入纯函数这一静态验证工具常用构造，解决具有不精确规范的纯函数的公理化技术挑战

Result: 通过纯函数扩展了Gradual C0的规范能力，同时提高了在Gradual C0中编码观察者方法的便利性

Conclusion: 纯函数扩展增强了Gradual C0的表达能力，解决了复杂规范表达的技术挑战，为渐进验证提供了更强大的规范工具

Abstract: Gradual verification soundly combines static checking and dynamic checking to provide an incremental approach for software verification. With gradual verification, programs can be partially specified first, and then the full specification of a program can be achieved in incremental steps. The first and only practicable gradual verifier based on symbolic execution, Gradual C0, supports recursive heap data structures. Despite recent efforts to improve the expressivity of Gradual C0's specification language, Gradual C0's specification language is still limited in its capabilities for complex expressions. This work explores an extension to Gradual C0's design with a common construct supported by many static verification tools, pure functions, which both extend the specification capabilities of Gradual C0 and increase the ease of encoding observer methods in Gradual C0. Our approach addresses the technical challenges related to the axiomatisation of pure functions with imprecise specifications.

</details>


### [2] [On Circuit Description Languages, Indexed Monads, and Resource Analysis](https://arxiv.org/abs/2511.22419)
*Ken Sakayori,Andrea Colledan,Ugo Dal Lago*

Main category: cs.PL

TL;DR: 为Proto-Quipper系列演算建立基于单子的指称模型，将计算值与电路副作用分离，支持控制电路大小的类型系统验证


<details>
  <summary>Details</summary>
Motivation: 为Quipper编程语言的理想化版本Proto-Quipper系列演算提供形式化语义基础，解决量子电路生成与计算值分离的问题，支持对生成电路大小进行控制的类型系统验证

Method: 采用基于单子的指称模型方法，引入电路代数新概念，将术语规约的值与作为副作用产生的电路分离，支持效果类型系统

Result: 建立了Proto-Quipper演算的充分性指称模型，能够验证控制电路大小的丰富类型系统，即使在优化存在的情况下也能保证电路的数量性质

Conclusion: 单子方法为量子编程语言的形式语义提供了有效框架，电路代数概念支持效果类型系统，为量子电路生成和优化提供了形式化验证基础

Abstract: In this paper, a monad-based denotational model is introduced and shown adequate for the Proto-Quipper family of calculi, themselves being idealized versions of the Quipper programming language. The use of a monadic approach allows us to separate the value to which a term reduces from the circuit that the term itself produces as a side effect. In turn, this enables the denotational interpretation and validation of rich type systems in which the size of the produced circuit can be controlled. Notably, the proposed semantic framework, through the novel concept of circuit algebra, suggests forms of effect typing guaranteeing quantitative properties about the resulting circuit, even in presence of optimizations.

</details>


### [3] [A Synthetic Reconstruction of Multiparty Session Types (with Appendix)](https://arxiv.org/abs/2511.22692)
*David Castro-Perez,Francisco Ferreira,Sung-Shik Jongmans*

Main category: cs.PL

TL;DR: 提出了一种新的多会话类型方法，通过直接验证进程与全局协议规范（表示为LTS）来同时实现表达性和组合性，避免了传统投影方法的限制。


<details>
  <summary>Details</summary>
Motivation: 现有多会话类型方法面临表达性与组合性的两难：基于投影的经典方法具有组合性但表达性有限，而较新的方法通过非组合性的全系统模型检查获得更高表达性，但扩展性差。

Method: 提出"合成方法"，开发类型系统直接验证每个进程与全局协议规范（表示为标记转换系统LTS），避免中间本地类型和投影，支持任意"行为良好"的LTS规范。

Result: 该方法支持一系列先前组合性技术无法处理的挑战性协议，概念更简单但表达性更强，已在Agda中形式化验证，并开发了VS Code扩展原型。

Conclusion: 合成方法成功解决了多会话类型中表达性与组合性的传统权衡，为并发系统验证提供了更强大且可扩展的框架。

Abstract: Multiparty session types (MPST) provide a rigorous foundation for verifying the safety and liveness of concurrent systems. However, existing approaches often force a difficult trade-off: classical, projection-based techniques are compositional but limited in expressiveness, while more recent techniques achieve higher expressiveness by relying on non-compositional, whole-system model checking, which scales poorly.
  This paper introduces a new approach to MPST that delivers both expressiveness and compositionality, called the synthetic approach. Our key innovation is a type system that verifies each process directly against a global protocol specification, represented as a labelled transition system (LTS) in general, with global types as a special case. This approach uniquely avoids the need for intermediate local types and projection.
  We demonstrate that our approach, while conceptually simpler, supports a benchmark of challenging protocols that were previously beyond the reach of compositional techniques in the MPST literature. We generalise our type system, showing that it can validate processes against any specification that constitutes a "well-behaved" LTS, supporting protocols not expressible with the standard global type syntax. The entire framework, including all theorems and many examples, has been formalised and mechanised in Agda, and we have developed a prototype implementation as an extension to VS Code.

</details>


### [4] [All for One and One for All: Program Logics for Exploiting Internal Determinism in Parallel Programs](https://arxiv.org/abs/2511.23283)
*Alexandre Moine,Sam Westrick,Joseph Tassarotti*

Main category: cs.PL

TL;DR: 本文提出Musketeer分离逻辑用于证明程序满足调度无关安全性，并开发Angelic逻辑来简化内部确定性程序的验证。


<details>
  <summary>Details</summary>
Motivation: 非确定性使并行程序难以编写和推理。虽然内部确定性编程技术让程序可以按顺序推理，但缺乏利用这一特性简化形式化验证的框架。

Method: 定义调度无关安全性属性，提出Musketeer分离逻辑证明该属性，然后使用Angelic逻辑动态选择和验证单一顺序执行路径。基于此验证MiniDet仿射类型系统的正确性。

Result: 开发了完整的验证框架，证明了MiniDet类型系统的正确性，支持包括确定性并发哈希集在内的核心算法原语，所有结果在Rocq中使用Iris分离逻辑框架验证。

Conclusion: 该工作为内部确定性程序提供了首个系统化的验证框架，通过调度无关安全性和新的逻辑系统显著简化了并行程序的验证复杂度。

Abstract: Nondeterminism makes parallel programs challenging to write and reason about. To avoid these challenges, researchers have developed techniques for internally deterministic parallel programming, in which the steps of a parallel computation proceed in a deterministic way. Internal determinism is useful because it lets a programmer reason about a program as if it executed in a sequential order. However, no verification framework exists to exploit this property and simplify formal reasoning about internally deterministic programs.
  To capture the essence of why internally deterministic programs should be easier to reason about, this paper defines a property called schedule-independent safety. A program satisfies schedule-independent safety, if, to show that the program is safe across all orderings, it suffices to show that one terminating execution of the program is safe. We then present a separation logic called Musketeer for proving that a program satisfies schedule-independent safety. Once a parallel program has been shown to satisfy schedule-independent safety, we can verify it with a new logic called Angelic, which allows one to dynamically select and verify just one sequential ordering of the program.
  Using Musketeer, we prove the soundness of MiniDet, an affine type system for enforcing internal determinism. MiniDet supports several core algorithmic primitives for internally deterministic programming that have been identified in the research literature, including a deterministic version of a concurrent hash set. Because any syntactically well-typed MiniDet program satisfies schedule-independent safety, we can apply Angelic to verify such programs.
  All results in this paper have been verified in Rocq using the Iris separation logic framework.

</details>


### [5] [TypeDis: A Type System for Disentanglement](https://arxiv.org/abs/2511.23358)
*Alexandre Moine,Stephanie Balzer,Alex Xu,Sam Westrick*

Main category: cs.PL

TL;DR: 提出TypeDis类型系统，通过时间戳标注自动验证并行程序的解耦性，避免手动证明负担


<details>
  <summary>Details</summary>
Motivation: 解耦性是并行程序的重要运行时特性，但现有验证方法（如DisLog）需要大量专业知识和手动证明工作，对程序员负担重

Method: 设计TypeDis类型系统，受区域类型启发，每个类型标注时间戳标识分配任务，支持iso递归类型、多态性，以及通过子时间化实现时间戳变化

Result: TypeDis能自动验证任何良类型程序都是解耦的，示例在Rocq证明助手中使用改进的DisLog2进行了机械化验证

Conclusion: TypeDis类型系统成功实现了并行程序解耦性的自动验证，将证明负担从程序员转移到类型系统，并通过机械化验证确保正确性

Abstract: Disentanglement is a runtime property of parallel programs guaranteeing that parallel tasks remain oblivious to each other's allocations. As demonstrated in the MaPLe compiler and run-time system, disentanglement can be exploited for fast automatic memory management, especially task-local garbage collection with no synchronization between parallel tasks. However, as a low-level property, disentanglement can be difficult to reason about for programmers. The only means of statically verifying disentanglement so far has been DisLog, an Iris-fueled variant of separation logic, mechanized in the Rocq proof assistant. DisLog is a fully-featured program logic, allowing for proof of functional correctness as well as verification of disentanglement. Yet its employment requires significant expertise and per-program proof effort.
  This paper explores the route of automatic verification via a type system, ensuring that any well-typed program is disentangled and lifting the burden of carrying out manual proofs from the programmer. It contributes TypeDis, a type system inspired by region types, where each type is annotated with a timestamp, identifying the task that allocated it. TypeDis supports iso-recursive types as well as polymorphism over both types and timestamps. Crucially, timestamps are allowed to change during type-checking, at join points as well as via a form of subtyping, dubbed subtiming. The paper illustrates TypeDis and its features on a range of examples. The soundness of TypeDis and the examples are mechanized in the Rocq proof assistant, using an improved version of DisLog, dubbed DisLog2.

</details>


### [6] [RapunSL: Untangling Quantum Computing with Separation, Linear Combination and Mixing](https://arxiv.org/abs/2511.23472)
*Yusuke Matsushita,Kengo Hirata,Ryo Wakizaka,Emanuele D'Osualdo*

Main category: cs.PL

TL;DR: 提出RapunSL量子分离逻辑，通过引入线性组合和混合连接词，实现基态局部性和结果局部性，显著提升量子程序推理的可扩展性。


<details>
  <summary>Details</summary>
Motivation: 现有量子分离逻辑(QSL)虽然通过纠缠解释分离和框架规则提供了纠缠局部规范，但仍需处理量子特有的两种局部性问题：叠加态到纯态的推理简化，以及测量产生的混合态到纯态的推理简化。

Method: 构建RapunSL量子分离逻辑，引入线性组合和混合两个连接词，与分离连接词结合，实现基态局部性（将叠加态推理简化为纯态推理）和结果局部性（将测量产生的混合态推理简化为纯态推理）。

Result: RapunSL能够显著提升量子程序推理的可扩展性，在一系列具有挑战性的案例研究中得到验证。

Conclusion: RapunSL通过引入量子特有的局部性概念和相应连接词，为量子程序的形式化验证提供了更高效、可扩展的推理框架。

Abstract: Quantum Separation Logic (QSL) has been proposed as an effective tool to improve the scalability of deductive reasoning for quantum programs. In QSL, separation is interpreted as disentanglement, and the frame rule brings a notion of entanglement-local specification (one that only talks about the qubits entangled with those acted upon by the program). In this paper, we identify two notions of locality unique to the quantum domain, and we construct a novel quantum separation logic, RapunSL, which is able to soundly reduce reasoning about superposition states to reasoning about pure states (basis-locality), and reasoning about mixed states arising from measurement to reasoning about pure states (outcome-locality). To do so, we introduce two connectives, linear combination and mixing, which together with separation provide a dramatic improvement in the scalability of reasoning, as we demonstrate on a series of challenging case studies.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [7] [Advancing Automated In-Isolation Validation in Repository-Level Code Translation](https://arxiv.org/abs/2511.21878)
*Kaiyao Ke,Ali Reza Ibrahimzada,Rangeet Pan,Saurabh Sinha,Reyhaneh Jabbarvand*

Main category: cs.SE

TL;DR: TRAM是一个结合上下文感知类型解析和基于模拟的隔离验证的仓库级代码翻译框架，在Java到Python翻译中实现最先进性能


<details>
  <summary>Details</summary>
Motivation: 尽管仓库级代码翻译有所进展，但验证翻译结果仍然具有挑战性。现有方法要么依赖代理进行验证成本高昂，要么需要大量手动工作，且依赖于语言互操作性

Method: TRAM结合RAG-based类型解析和模拟对象验证：1）翻译前检索API文档和上下文代码信息；2）使用LLM解析跨语言类型映射；3）通过自定义序列化/反序列化工作流在目标语言中构建等效模拟对象；4）实现方法片段的隔离验证

Result: TRAM在Java到Python翻译中展示了最先进的性能，证明了其RAG-based类型解析与可靠隔离验证集成的有效性

Conclusion: TRAM通过上下文感知类型解析和模拟对象验证，解决了仓库级代码翻译验证的挑战，提供了一种高效可靠的跨语言代码迁移解决方案

Abstract: Repository-level code translation aims to migrate entire repositories across programming languages while preserving functionality automatically. Despite advancements in repository-level code translation, validating the translations remains challenging. This paper proposes TRAM, which combines context-aware type resolution with mock-based in-isolation validation to achieve high-quality translations between programming languages. Prior to translation, TRAM retrieves API documentation and contextual code information for each variable type in the source language. It then prompts a large language model (LLM) with retrieved contextual information to resolve type mappings across languages with precise semantic interpretations. Using the automatically constructed type mapping, TRAM employs a custom serialization/deserialization workflow that automatically constructs equivalent mock objects in the target language. This enables each method fragment to be validated in isolation, without the high cost of using agents for translation validation, or the heavy manual effort required by existing approaches that rely on language interoperability. TRAM demonstrates state-of-the-art performance in Java-to-Python translation, underscoring the effectiveness of its integration of RAG-based type resolution with reliable in-isolation validation.

</details>


<div id='cs.HC'></div>

# cs.HC [[Back]](#toc)

### [8] [When Are Reactive Notebooks Not Reactive?](https://arxiv.org/abs/2511.21994)
*Megan Zheng,Will Crichton,Akshay Narayan,Deepti Raghavan,Nikos Vasilakis*

Main category: cs.HC

TL;DR: 提出Rex测试套件来评估和讨论反应式笔记本系统的反应能力，帮助程序员理解反应性何时失效，并帮助笔记本实现改进。


<details>
  <summary>Details</summary>
Motivation: 现有反应式笔记本系统（如Ipyflow、Marimo、Observable）各有不同的反应性定义，且简单的笔记本修改就可能破坏系统。这些不一致性使得用户难以构建对反应式笔记本实现的心智模型。

Method: 提出Rex，一个细粒度的测试套件，用于讨论和评估反应式笔记本系统的反应能力。在三个现有反应式笔记本系统上评估Rex，并对它们的失败进行分类。

Result: 通过Rex测试套件评估了三个现有反应式笔记本系统，分类了它们的失败情况。

Conclusion: Rex测试套件有助于程序员理解反应性何时失效，并帮助笔记本实现改进，促进对反应式笔记本系统反应能力的标准化讨论和评估。

Abstract: Computational notebooks are convenient for programmers, but can easily become confusing and inconsistent due to the ability to incrementally edit a program that is running. Recent reactive notebook systems, such as Ipyflow, Marimo and Observable, strive to keep notebook state in sync with the current cell code by re-executing a minimal set of cells upon modification. However, each system defines reactivity a different way. Additionally, within any definition, we find simple notebook modifications that can break each system. Overall, these inconsistencies make it difficult for users to construct a mental model of their reactive notebook's implementation. This paper proposes Rex, a fine-grained test suite to discuss and assess reactivity capabilities within reactive notebook systems. We evaluate Rex on three existing reactive notebook systems and classify their failures with the aims of (i) helping programmers understand when reactivity fails and (ii) helping notebook implementations improve.

</details>


<div id='quant-ph'></div>

# quant-ph [[Back]](#toc)

### [9] [Quantum Circuit Equivalence Checking: A Tractable Bridge From Unitary to Hybrid Circuits](https://arxiv.org/abs/2511.22523)
*Jérome Ricciardi,Sébastien Bardin,Christophe Chareton,Benoît Valiron*

Main category: quant-ph

TL;DR: 提出一种基于延迟测量变换的量子混合电路等价性检查方法，显著优于现有方法，并能处理更大范围的混合电路等价问题


<details>
  <summary>Details</summary>
Motivation: 量子编译器链中普遍存在电路变换，需要自动化检查混合量子电路的等价性。现有方法大多只关注简单幺正电路，而实际量子计算需要包含测量算符的混合电路，现有混合电路方法又局限于特定问题类别

Method: 通过延迟测量变换将幺正电路验证技术提升到混合电路验证，并加入分离和投影两种幺正级技术来处理更大范围的混合电路等价问题

Result: 该方法显著优于先前工作，能够处理更大类别的混合电路等价问题，在标准电路变换（如隐形传态、单向测量、IBM Qiskit编译器）上验证有效，并发现了Qiskit编译器的多个意外行为

Conclusion: 提出的基于延迟测量变换的混合电路等价检查方法具有显著优势，能够有效处理实际量子计算中的混合电路验证需求，同时揭示了现有量子编译器的潜在问题

Abstract: Equivalence checking of hybrid quantum circuits is of primary importance, given that quantum circuit transformations are omnipresent along the quantum compiler chain. While some approaches exist for automating this task, most focus on the simple case of unitary circuits. At the same time, real quantum computing requires hybrid circuits equipped with measurement operators. Moreover, the few approaches targeting the hybrid case are limited to a restricted class of problems. We propose tackling the Quantum Hybrid Circuit Equivalence Checking problem through lifting unitary circuit verification using a transformation known as deferred measurement. We show that this approach alone significantly outperforms prior work, and that, with the addition of specific unitary-level techniques we call separation and projection, it can handle much larger classes of hybrid circuit equivalence problems. We have implemented and evaluated our method over standard circuit transformations such as teleportation, one-way measurement, or the IBM Qiskit compiler, demonstrating its promises. As a side finding, we have identified and reported several unexpected behaviours with the Qiskit compiler.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [10] [A programming language combining quantum and classical control](https://arxiv.org/abs/2511.22537)
*Kinnari Dave,Louis Lemonnier,Romain Péchoux,Vladimir Zamdzhiev*

Main category: cs.LO

TL;DR: 该论文提出了一种将量子控制和经典控制两种范式结合在同一系统中的新方法，通过语法、操作和语义三个层面的创新实现混合量子计算。


<details>
  <summary>Details</summary>
Motivation: 传统上量子编程语言中的量子控制（基于叠加态）和经典控制（基于经典信息）两种范式被分开处理，难以混合使用。作者希望打破这种分离，创建能够同时支持两种控制范式的统一系统。

Method: 1. 语法层面：引入模态系统将纯量子类型纳入混合态量子类型系统；2. 操作层面：改编量子λ演算中的"量子配置"概念，用量子原语替换量子数据；3. 语义层面：使用希尔伯特空间子范畴处理纯计算，冯·诺依曼代数子范畴处理混合态计算（海森堡图景）。

Result: 成功展示了量子控制和经典控制两种范式可以在同一系统中结合，为混合量子编程语言提供了理论基础和实现框架。

Conclusion: 该工作打破了传统量子编程中两种控制范式的分离，通过创新的类型系统、操作语义和语义模型，为实现统一的混合量子计算系统奠定了基础。

Abstract: The two main notions of control in quantum programming languages are often referred to as "quantum" control and "classical" control. With the latter, the control flow is based on classical information, potentially resulting from a quantum measurement, and this paradigm is well-suited to mixed state quantum computation. Whereas with quantum control, we are primarily focused on pure quantum computation and there the "control" is based on superposition. The two paradigms have not mixed well traditionally and they are almost always treated separately. In this work, we show that the paradigms may be combined within the same system. The key ingredients for achieving this are: (1) syntactically: a modality for incorporating pure quantum types into a mixed state quantum type system; (2) operationally: an adaptation of the notion of "quantum configuration" from quantum lambda-calculi, where the quantum data is replaced with pure quantum primitives; (3) denotationally: suitable (sub)categories of Hilbert spaces, for pure computation and von Neumann algebras, for mixed state computation in the Heisenberg picture of quantum mechanics.

</details>
