{"id": "2512.01036", "pdf": "https://arxiv.org/pdf/2512.01036", "abs": "https://arxiv.org/abs/2512.01036", "authors": ["Breandan Considine"], "title": "A Word Sampler for Well-Typed Functions", "categories": ["cs.PL", "cs.FL"], "comment": "2 pages", "summary": "We describe an exact sampler for a simply-typed, first-order functional programming language. Given an acyclic finite automaton, $α_{\\varnothing}$, it samples a random function uniformly without replacement from well-typed functions in $\\mathcal{L}(α_{\\varnothing})$. This is achieved via a fixed-parameter tractable reduction from a syntax-directed type system to a context-free grammar, preserving type soundness and completeness w.r.t. $\\mathcal{L}(α_{\\varnothing})$, while retaining the robust metatheory of formal languages."}
{"id": "2512.00127", "pdf": "https://arxiv.org/pdf/2512.00127", "abs": "https://arxiv.org/abs/2512.00127", "authors": ["Shailja Thakur", "Vaibhav Saxena", "Rohan Kulkarni", "Shivdeep Singh", "Parameswaran Selvam", "Hima Patel", "Hiroshi Kanayama"], "title": "Generating Verifiable CoT from Execution-Traces", "categories": ["cs.SE", "cs.AI", "cs.PL"], "comment": null, "summary": "Teaching language models to reason about code execution remains a fundamental challenge. While Chain-of-Thought (CoT) prompting has shown promise, current synthetic training data suffers from a critical weakness: the reasoning steps are often plausible-sounding explanations generated by teacher models, not verifiable accounts of what the code actually does. This creates a troubling failure mode where models learn to mimic superficially convincing but logically flawed reasoning patterns.\n  We address this by grounding CoT generation directly in program execution traces. Our pipeline instruments code to capture its dynamic behavior, then narrates these verified execution traces into natural language rationales that are correct by construction. This execution-grounded approach ensures every reasoning step reflects what the program genuinely computes, eliminating logical hallucinations at the source. We evaluate our method on code reasoning tasks (forward reasoning on CruxEval and LiveCodeBench-Exec, backward reasoning on CruxEval-Input), as well as code generation and explanation tasks from HumanEval. Models trained on our bi-directional trace-grounded data achieve substantial improvements, with gains of up to 30 points on output prediction and 28 points on input prediction over base models, alongside improved explanation and code generation, demonstrating that verifiable reasoning fundamentally enhances model capabilities. https://github.ibm.com/IBM-Research-AI/Verified-Code-CoT"}
{"id": "2512.00164", "pdf": "https://arxiv.org/pdf/2512.00164", "abs": "https://arxiv.org/abs/2512.00164", "authors": ["Alessandro De Palma", "Greta Dolcetti", "Caterina Urban"], "title": "Faster Verified Explanations for Neural Networks", "categories": ["cs.LG", "cs.PL"], "comment": null, "summary": "Verified explanations are a theoretically-principled way to explain the decisions taken by neural networks, which are otherwise black-box in nature. However, these techniques face significant scalability challenges, as they require multiple calls to neural network verifiers, each of them with an exponential worst-case complexity. We present FaVeX, a novel algorithm to compute verified explanations. FaVeX accelerates the computation by dynamically combining batch and sequential processing of input features, and by reusing information from previous queries, both when proving invariances with respect to certain input features, and when searching for feature assignments altering the prediction. Furthermore, we present a novel and hierarchical definition of verified explanations, termed verifier-optimal robust explanations, that explicitly factors the incompleteness of network verifiers within the explanation. Our comprehensive experimental evaluation demonstrates the superior scalability of both FaVeX, and of verifier-optimal robust explanations, which together can produce meaningful formal explanation on networks with hundreds of thousands of non-linear activations."}
{"id": "2512.00314", "pdf": "https://arxiv.org/pdf/2512.00314", "abs": "https://arxiv.org/abs/2512.00314", "authors": ["Alexis de Colnet", "Kuldeep S. Meel", "Umang Mathur"], "title": "Counting and Sampling Traces in Regular Languages", "categories": ["cs.FL", "cs.CC", "cs.LO", "cs.PL"], "comment": "To appear in POPL 2026. Author order is random", "summary": "In this work, we study the problems of counting and sampling Mazurkiewicz traces that a regular language touches. Fix an alphabet $Σ$ and an independence relation $\\mathbb{I} \\subseteq Σ\\times Σ$. The input consists of a regular language $L \\subseteq Σ^*$, given by a finite automaton with $m$ states, and a natural number $n$ (in unary). For the counting problem, the goal is to compute the number of Mazurkiewicz traces (induced by $\\mathbb{I}$) that intersect the $n^\\text{th}$ slice $L_n = L \\cap Σ^n$, i.e., traces that admit at least one linearization in $L_n$. For the sampling problem, the goal is to output a trace drawn from a distribution that is approximately uniform over all such traces. These tasks are motivated by bounded model checking with partial-order reduction, where an \\emph{a priori} estimate of the reduced state space is valuable, and by testing methods for concurrent programs that use partial-order-aware random exploration.\n  We first show that the counting problem is #P-hard even when $L$ is accepted by a deterministic automaton, in sharp contrast to counting words of a DFA, which is polynomial-time solvable. We then prove that the problem lies in #P for both NFAs and DFAs, irrespective of whether $L$ is trace-closed. Our main algorithmic contributions are a \\emph{fully polynomial-time randomized approximation scheme} (FPRAS) that, with high probability, approximates the desired count within a prescribed accuracy, and a \\emph{fully polynomial-time almost uniform sampler} (FPAUS) that generates traces whose distribution is provably close to uniform."}
{"id": "2512.00487", "pdf": "https://arxiv.org/pdf/2512.00487", "abs": "https://arxiv.org/abs/2512.00487", "authors": ["Yuhao Gu", "Zhongchun Zheng", "Nong Xiao", "Yutong Lu", "Xianwei Zhang"], "title": "Partial Cross-Compilation and Mixed Execution for Accelerating Dynamic Binary Translation", "categories": ["cs.AR", "cs.PL"], "comment": null, "summary": "With the growing diversity of instruction set architectures (ISAs), cross-ISA program execution has become common. Dynamic binary translation (DBT) is the main solution but suffers from poor performance. Cross-compilation avoids emulation costs but is constrained by an \"all-or-nothing\" model-programs are either fully cross-compiled or entirely emulated. Complete cross-compilation is often unfeasible due to ISA-specific code or missing dependencies, leaving programs with high emulation overhead.\n  We propose a hybrid execution system that combines compilation and emulation, featuring a selective function offloading mechanism. This mechanism establishes cross-environment calling channels, offloading eligible functions to the host for native execution to reduce DBT overhead. Key optimizations address offloading costs, enabling efficient hybrid operation. Built on LLVM and QEMU, the system works automatically for both applications and libraries. Evaluations show it achieves up to 13x speedups over existing DBT, with strong practical value."}
{"id": "2512.01678", "pdf": "https://arxiv.org/pdf/2512.01678", "abs": "https://arxiv.org/abs/2512.01678", "authors": ["Anubhab", "Rupesh Nasre"], "title": "Morphling: Fast, Fused, and Flexible GNN Training at Scale", "categories": ["cs.LG", "cs.DC", "cs.PL"], "comment": null, "summary": "Graph Neural Networks (GNNs) present a fundamental hardware challenge by fusing irregular, memory-bound graph traversals with regular, compute-intensive dense matrix operations. While frameworks such as PyTorch Geometric (PyG) and Deep Graph Library (DGL) prioritize high-level usability, they fail to address these divergent execution characteristics. As a result, they rely on generic kernels that suffer from poor cache locality, excessive memory movement, and substantial intermediate allocations. To address these limitations, we present Morphling, a domain-specific code synthesizer designed to bridge this gap. Morphling compiles high-level GNN specifications into portable, backend-specialized implementations targeting OpenMP, CUDA, and MPI. It achieves this by instantiating a library of optimized, architecture-aware primitives tailored to each execution environment. Morphling also incorporates a runtime sparsity-aware execution engine that dynamically selects dense or sparse execution paths using input feature statistics, reducing unnecessary computation on zero-valued entries. We evaluate Morphling on eleven real-world datasets spanning diverse graph structures, feature dimensionalities, and sparsity regimes. The results show that Morphling improves per-epoch training throughput by an average of 20X on CPUs and 19X on GPUs over PyG and DGL, with peak speedups reaching 66X. Morphling's memory-efficient layouts further reduce peak memory consumption by up to 15X, enabling large-scale GNN training on commodity hardware. These findings demonstrate that specialized, architecture-aware code synthesis provides an effective and scalable path toward high-performance GNN execution across diverse parallel and distributed platforms."}
