<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]
- [cs.CR](#cs.CR) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Pushing Tensor Accelerators Beyond MatMul in a User-Schedulable Language](https://arxiv.org/abs/2512.02371)
*Yihong Zhang,Derek Gerstmann,Andrew Adams,Maaz Bin Safeer Ahmad*

Main category: cs.PL

TL;DR: 提出基于编译器的技术，使张量加速器能应用于图像处理等传统ML之外的领域，通过Halide语言和等式饱和实现灵活的张量指令选择，显著提升性能


<details>
  <summary>Details</summary>
Motivation: 张量加速器在现代CPU/GPU中占比增长，但难以编程，主要限于厂商提供的ML和科学计算库。作者希望扩展张量加速器到更广泛的应用领域，特别是图像处理等线性变换任务

Method: 使用Halide可调度语言表达算法，基于等式饱和实现灵活的张量指令选择器，支持CPU和GPU连接的张量加速器，并与现有调度操作（如生产者-消费者融合）协同工作

Result: 在Nvidia RTX 4070 GPU上，下采样例程通过使用Tensor Cores实现了6.1倍的加速。多个图像处理流水线（滤波、重采样、去噪）相比非加速器基线都获得了显著加速

Conclusion: 张量加速器可以超越传统ML领域，通过编译器技术使开发者能用少量代码编写多样化的加速器应用，为图像处理等线性变换任务提供显著的性能提升

Abstract: Tensor accelerators now represent a growing share of compute resources in modern CPUs and GPUs. However, they are hard to program, leading developers to use vendor-provided kernel libraries that support tensor accelerators. As a result, the usage of tensor accelerators is limited to the provided interface, mainly designed for traditional ML and scientific computing workloads.
  In this paper, we show that tensor accelerators can improve the performance of applications beyond simple variants of MatMul. For example, many image processing pipelines are linear transformations over matrices in disguise and can therefore utilize such specialized hardware. This is nonetheless hindered by the difficulties in programming tensor accelerators. We tackle this problem with compiler-based techniques. We use the Halide user-schedulable language and express operations as Halide algorithms succinctly. To this end, we implement a flexible tensor instruction selector based on equality saturation. The tensor instruction selector supports both CPU- and GPU-attached tensor accelerators and works with existing scheduling operations (e.g., producer-consumer fusion). Together, this enables developers to write diverse accelerator-leveraging applications in a few dozen lines.
  Using our system, we demonstrate the potential of tensor accelerators beyond their traditional domains. We implement several image processing pipelines (e.g., filtering, resampling, and denoising) in our system and evaluate them against non-accelerator-leveraging baselines. We show that these pipelines can achieve significant speedups. For example, a downsampling routine is sped up by $6.1\times$ by utilizing Tensor Cores on an Nvidia RTX 4070 GPU.

</details>


### [2] [Probabilistic energy profiler for statically typed JVM-based programming languages](https://arxiv.org/abs/2512.02738)
*Joel Nyholm,Wojciech Mostowski,Christoph Reichenbach*

Main category: cs.PL

TL;DR: 提出基于贝叶斯统计的字节码模式能耗预测方法，用于静态类型JVM语言（Java/Scala），考虑数据大小、类型、操作和设备四个因素，相比传统CPU点估计方法更全面。


<details>
  <summary>Details</summary>
Motivation: 现有能耗分析方法主要关注CPU能耗的点估计，忽略了其他硬件影响，且聚焦于函数或程序层面而非源代码语句级别，限制了统计推理和可解释性。

Method: 测量字节码模式的能耗，构建贝叶斯统计模型，包含四个因素：数据大小、数据类型、操作类型和执行设备。针对Java实现并验证。

Result: 所有四个因素都显著影响能耗，同型号设备间存在差异，操作和数据类型导致能耗差异。模型预测与真实能耗高度吻合。

Conclusion: 提出了一种构建能耗模型的方法论，可为验证工具等未来工作提供能耗估计基础，解决了传统方法局限于CPU点估计的问题。

Abstract: Energy consumption is a growing concern in several fields, from mobile devices to large data centers. Developers need detailed data on the energy consumption of their software to mitigate consumption issues. Previous approaches have a broader focus, such as on specific functions or programs, rather than source code statements. They primarily focus on estimating the CPU's energy consumption using point estimates, thereby disregarding other hardware effects and limiting their use for statistical reasoning and explainability. We developed a novel methodology to address the limitations of measuring only the CPU's consumption and using point estimates, focusing on predicting the energy usage of statically typed JVM-based programming languages, such as Java and Scala. We measure the energy consumption of Bytecode patterns, the translation from the programming language's source code statement to their Java Bytecode representation. With the energy measurements, we construct a statistical model using Bayesian statistics, which allows us to predict the energy consumption through statistical distributions and analyze individual factors. The model includes three factors we obtain statically from the code: data size, data type, operation, and one factor about the hardware platform the code executes on: device. To validate our methodology, we implemented it for Java and evaluated its energy predictions on unseen programs. We observe that all four factors are influential, notably that two devices of the same model may differ in energy consumption and that the operations and data types cause consumption differences. The experiments also show that the energy prediction of programs closely follows the program's real energy consumption, validating our approach. Our work presents a methodology for constructing an energy model that future work, such as verification tools, can use for their energy estimates.

</details>


### [3] [Lumos: Let there be Language Model System Certification](https://arxiv.org/abs/2512.02966)
*Isha Chaudhary,Vedaant Jain,Avaljot Singh,Kavya Sachdeva,Sayan Ranu,Gagandeep Singh*

Main category: cs.PL

TL;DR: Lumos是一个用于形式化规范和认证语言模型系统行为的概率编程框架，通过图结构表示提示分布，支持统计认证，并首次为自动驾驶场景中的视觉语言模型开发了安全规范。


<details>
  <summary>Details</summary>
Motivation: 当前缺乏系统化、可扩展的框架来形式化规范和认证语言模型系统的行为，特别是在安全关键场景中。需要一种能够应对快速演变的威胁环境，并能发现先进语言模型具体失败案例的方法。

Method: Lumos是一个基于图的命令式概率编程领域特定语言，通过图结构表示提示分布，从采样子图生成随机提示。提供混合（操作和指称）语义，支持与统计认证器集成来认证任意提示分布下的语言模型行为。

Result: 使用Lumos为自动驾驶场景中的视觉语言模型开发了首个安全规范，发现最先进的Qwen-VL模型在雨天右转场景中至少90%概率产生错误和不安全响应，揭示了重大安全风险。Lumos的模块化结构便于规范修改，并能发现先进语言模型的具体失败案例。

Conclusion: Lumos是首个系统化、可扩展的基于语言的框架，用于规范和认证语言模型系统行为，为更广泛采用语言模型认证铺平了道路。它能够编码现有规范，支持新属性开发，并能跟上快速演变的威胁环境。

Abstract: We introduce the first principled framework, Lumos, for specifying and formally certifying Language Model System (LMS) behaviors. Lumos is an imperative probabilistic programming DSL over graphs, with constructs to generate independent and identically distributed prompts for LMS. It offers a structured view of prompt distributions via graphs, forming random prompts from sampled subgraphs. Lumos supports certifying LMS for arbitrary prompt distributions via integration with statistical certifiers. We provide hybrid (operational and denotational) semantics for Lumos, providing a rigorous way to interpret the specifications. Using only a small set of composable constructs, Lumos can encode existing LMS specifications, including complex relational and temporal specifications. It also facilitates specifying new properties - we present the first safety specifications for vision-language models (VLMs) in autonomous driving scenarios developed with Lumos. Using these, we show that the state-of-the-art VLM Qwen-VL exhibits critical safety failures, producing incorrect and unsafe responses with at least 90% probability in right-turn scenarios under rainy driving conditions, revealing substantial safety risks. Lumos's modular structure allows easy modification of the specifications, enabling LMS certification to stay abreast with the rapidly evolving threat landscape. We further demonstrate that specification programs written in Lumos enable finding specific failure cases exhibited by state-of-the-art LMS. Lumos is the first systematic and extensible language-based framework for specifying and certifying LMS behaviors, paving the way for a wider adoption of LMS certification.

</details>


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [4] [Belobog: Move Language Fuzzing Framework For Real-World Smart Contracts](https://arxiv.org/abs/2512.02918)
*Wanxu Xia,Ziqiao Kong,Zhengwei Li,Yi Lu,Pan Li,Liqun Yang,Yang Liu,Xiapu Luo,Shaohua Li*

Main category: cs.CR

TL;DR: Belobog是首个针对Move智能合约的模糊测试框架，通过类型感知的测试用例生成和符号执行来检测Move合约中的安全漏洞。


<details>
  <summary>Details</summary>
Motivation: Move语言虽然具有强大的静态类型系统和显式资源语义，但其类型系统无法覆盖所有安全漏洞。现有模糊测试工具由于Move的强类型特性，难以生成语法或语义有效的交易来测试Move智能合约。

Method: Belobog采用类型感知的方法：1) 基于Move类型系统构建类型图；2) 根据类型图轨迹生成或变异交易；3) 设计实现符号执行器来克服Move智能合约中的复杂检查。

Result: 在109个真实Move智能合约项目中，Belobog能够检测到100%的关键漏洞和79%的主要漏洞（与人工审计结果相比）。成功复现了Cetus和Nemo两个近期重大安全事件，无需任何先验知识。

Conclusion: Belobog是首个有效的Move智能合约模糊测试框架，通过类型感知的测试生成和符号执行，能够高效检测Move合约中的安全漏洞，弥补了现有工具的不足。

Abstract: Move is a research-oriented programming language design for secure and verifiable smart contract development and has been widely used in managing billions of digital assets in blockchains, such as Sui and Aptos. Move features a strong static type system and explicit resource semantics to enforce safety properties such as the prevention of data races, invalid asset transfers, and entry vulnerabilities. However, smart contracts written in Move may still contain certain vulnerabilities that are beyond the reach of its type system. It is thus essential to validate Move smart contracts. Unfortunately, due to its strong type system, existing smart contract fuzzers are ineffective in producing syntactically or semantically valid transactions to test Move smart contracts. This paper introduces the first fuzzing framework, Belobog, for Move smart contracts. Belobog is type-aware and ensures that all generated and mutated transactions are well-typed. More specifically, for a target Move smart contract, Belobog first constructs a type graph based on Move's type system, and then generates or mutates a transaction based on the graph trace derived from the type graph. In order to overcome the complex checks in Move smart contracts, we further design and implement a concolic executor in Belobog. We evaluated Belobog on 109 real-world Move smart contract projects. The experimental results show that Belobog is able to detect 100\% critical and 79\% major vulnerabilities manually audited by human experts. We further selected two recent notorious incidents in Move smart contracts, i.e., Cetus and Nemo. Belobog successfully reproduced full exploits for both of them, without any prior knowledge.

</details>
