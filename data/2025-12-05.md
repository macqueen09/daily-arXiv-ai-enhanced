<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Typing Fallback Functions: A Semantic Approach to Type Safe Smart Contracts](https://arxiv.org/abs/2512.04755)
*Stian Lybech,Daniele Gorla,Luca Aceto*

Main category: cs.PL

TL;DR: 该论文提出在智能合约环境中使用语义类型来确保使用静态不可类型化语言构造（如fallback函数）的代码类型安全，采用证明携带代码方法，用户只需验证提供的类型安全证明证书。


<details>
  <summary>Details</summary>
Motivation: 智能合约中某些语言构造（如fallback函数）无法静态类型检查，需要确保这些代码的类型安全性，特别是在区块链不可变环境中。

Method: 采用语义类型和证明携带代码方法：合约创建者为包含不可静态类型化构造的代码提供形式化类型安全证明，用户只需验证证明证书。具体针对TINYSOL语言，通过安全类型确保信息流控制和非干扰性，使用共归纳定义的类型解释和up-to技术紧凑表示证明。

Result: 开发了适用于区块链/智能合约环境的语义类型理论框架，能够确保使用fallback函数等不可静态类型化构造的代码类型安全，并展示了如何为典型的指针到实现模式进行类型检查。

Conclusion: 主要贡献不是安全定理本身，而是提出了在区块链/智能合约环境中实现这种方法所需的理论发展框架，可应用于除非干扰性外的其他安全属性。

Abstract: This paper develops semantic typing in a smart-contract setting to ensure type safety of code that uses statically untypable language constructs, such as the fallback function. The idea is that the creator of a contract on the blockchain equips code containing such constructs with a formal proof of its type safety, given in terms of the semantics of types. Then, a user of the contract only needs to check the validity of the provided `proof certificate' of type safety. This is a form of proof-carrying code, which naturally fits with the immutable nature of the blockchain environment.
  As a concrete application of our approach, we focus on ensuring information flow control and non-interference for the language TINYSOL, a distilled version of the Solidity language, through security types. We provide the semantics of types in terms of a typed operational semantics of TINYSOL, and a way for expressing the proofs of safety as coinductively-defined typing interpretations and for representing them compactly via up-to techniques, similar to those used for bisimilarity. We also show how our machinery can be used to type the typical pointer-to-implementation pattern based on the fallback function. However, our main contribution is not the safety theorem per se (and so security properties different from non-interference can be considered as well), but rather the presentation of the theoretical developments necessary to make this approach work in a blockchain/smart-contract setting.

</details>


### [2] [Optimizations and extensions for fair join pattern matching](https://arxiv.org/abs/2512.04876)
*Ioannis Karras*

Main category: cs.PL

TL;DR: 优化了Haller等人的状态树匹配算法，在特定基准测试中实现10倍性能提升，接近Rete算法性能，同时保持对复杂条件守卫的优势，并扩展了语法和用例。


<details>
  <summary>Details</summary>
Motivation: 连接模式在并发和分布式系统编程中未充分探索，现有状态树匹配算法在时间效率上表现不佳，特别是相比Rete算法在常规基准测试中性能较差，且Rete算法需要大量手动适配。

Method: 增强和优化Haller等人的状态树匹配算法，改进基准测试套件（增加新特性、增强可扩展性和用户友好性），扩展连接模式实现（提供更少歧义的语法和动态模式切换）。

Result: 在特定基准测试中实现高达10倍的性能提升，接近Rete算法在常规基准测试中的性能，同时保持对复杂条件守卫场景的优势，并展示了在微服务Web架构中的适用性。

Conclusion: 优化后的状态树匹配算法在性能上显著提升，接近Rete算法水平，同时保持了灵活性和对复杂条件守卫的优势，扩展了连接模式的实际应用场景。

Abstract: Join patterns are an underexplored approach for the programming of concurrent and distributed systems. When applied to the actor model, join patterns offer the novel capability of matching combinations of messages in the mailbox of an actor. Previous work by Philipp Haller et al. in the paper "Fair Join Pattern Matching for Actors" (ECOOP 2024) explored join patterns with conditional guards in an actor-based setting with a specification of fair and deterministic matching semantics. Nevertheless, the question of time efficiency in fair join pattern matching has remained underexplored. The stateful tree-based matching algorithm of Haller et al. performs worse than an implementation that adapts the Rete algorithm to the regular version of a join pattern matching benchmark, while outperforming on a variant with heavy conditional guards, which take longer to evaluate. Nevertheless, conforming Rete to the problem of join pattern matching requires heavy manual adaptation.
  In this thesis, we enhance and optimize the stateful tree-based matching algorithm of Haller et al. to achieve up to tenfold performance improvements on certain benchmarks, approaching the performance of Rete on regular benchmarks while maintaining the advantages of versatility and performance with heavy guards. We also enhance the benchmark suite, adding new features and enhancing its extensibility and user-friendliness. We extend the join pattern implementation with a less ambiguous syntax as well as dynamic pattern switching. Finally, we present a new complex model use case for join patterns, showing their applicability in a microservice web architecture.

</details>
