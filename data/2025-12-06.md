<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Typing Fallback Functions: A Semantic Approach to Type Safe Smart Contracts](https://arxiv.org/abs/2512.04755)
*Stian Lybech,Daniele Gorla,Luca Aceto*

Main category: cs.PL

TL;DR: 在智能合约环境中开发语义类型系统，通过证明携带代码确保使用静态不可类型化语言构造（如fallback函数）的类型安全，特别关注信息流控制和非干涉性


<details>
  <summary>Details</summary>
Motivation: 解决智能合约中静态不可类型化语言构造（如fallback函数）的类型安全问题，利用区块链不可变特性实现证明携带代码机制

Method: 为TINYSOL语言（Solidity的精简版本）开发基于安全类型的语义类型系统，使用共归纳定义的类型解释和up-to技术紧凑表示证明证书

Result: 建立了智能合约环境下语义类型化的理论框架，能够确保信息流控制和非干涉性，并能类型化基于fallback函数的典型指针到实现模式

Conclusion: 提出了适用于区块链/智能合约环境的语义类型化理论框架，通过证明携带代码机制确保类型安全，特别适用于静态不可类型化语言构造

Abstract: This paper develops semantic typing in a smart-contract setting to ensure type safety of code that uses statically untypable language constructs, such as the fallback function. The idea is that the creator of a contract on the blockchain equips code containing such constructs with a formal proof of its type safety, given in terms of the semantics of types. Then, a user of the contract only needs to check the validity of the provided `proof certificate' of type safety. This is a form of proof-carrying code, which naturally fits with the immutable nature of the blockchain environment.
  As a concrete application of our approach, we focus on ensuring information flow control and non-interference for the language TINYSOL, a distilled version of the Solidity language, through security types. We provide the semantics of types in terms of a typed operational semantics of TINYSOL, and a way for expressing the proofs of safety as coinductively-defined typing interpretations and for representing them compactly via up-to techniques, similar to those used for bisimilarity. We also show how our machinery can be used to type the typical pointer-to-implementation pattern based on the fallback function. However, our main contribution is not the safety theorem per se (and so security properties different from non-interference can be considered as well), but rather the presentation of the theoretical developments necessary to make this approach work in a blockchain/smart-contract setting.

</details>


### [2] [Optimizations and extensions for fair join pattern matching](https://arxiv.org/abs/2512.04876)
*Ioannis Karras*

Main category: cs.PL

TL;DR: 优化了Haller等人的公平连接模式匹配算法，性能提升达10倍，接近Rete算法在常规基准测试中的表现，同时保持了在复杂守卫条件下的优势。


<details>
  <summary>Details</summary>
Motivation: Haller等人提出的公平连接模式匹配算法在时间效率方面仍有不足，其基于状态树的算法在常规基准测试中表现不如Rete算法，而将Rete算法适配到连接模式匹配问题需要大量手动调整。

Method: 增强和优化Haller等人的基于状态树的匹配算法，改进基准测试套件，扩展连接模式实现（包括更清晰的语法和动态模式切换），并展示在微服务Web架构中的新应用案例。

Result: 在某些基准测试中实现了高达10倍的性能提升，接近Rete算法在常规基准测试中的性能，同时保持了在复杂守卫条件下的优势。基准测试套件得到增强，连接模式实现更加完善。

Conclusion: 通过优化算法显著提升了公平连接模式匹配的时间效率，使其在实际应用中更具竞争力，特别是在微服务架构等复杂场景中展示了连接模式的实际应用价值。

Abstract: Join patterns are an underexplored approach for the programming of concurrent and distributed systems. When applied to the actor model, join patterns offer the novel capability of matching combinations of messages in the mailbox of an actor. Previous work by Philipp Haller et al. in the paper "Fair Join Pattern Matching for Actors" (ECOOP 2024) explored join patterns with conditional guards in an actor-based setting with a specification of fair and deterministic matching semantics. Nevertheless, the question of time efficiency in fair join pattern matching has remained underexplored. The stateful tree-based matching algorithm of Haller et al. performs worse than an implementation that adapts the Rete algorithm to the regular version of a join pattern matching benchmark, while outperforming on a variant with heavy conditional guards, which take longer to evaluate. Nevertheless, conforming Rete to the problem of join pattern matching requires heavy manual adaptation.
  In this thesis, we enhance and optimize the stateful tree-based matching algorithm of Haller et al. to achieve up to tenfold performance improvements on certain benchmarks, approaching the performance of Rete on regular benchmarks while maintaining the advantages of versatility and performance with heavy guards. We also enhance the benchmark suite, adding new features and enhancing its extensibility and user-friendliness. We extend the join pattern implementation with a less ambiguous syntax as well as dynamic pattern switching. Finally, we present a new complex model use case for join patterns, showing their applicability in a microservice web architecture.

</details>
