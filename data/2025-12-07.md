<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Typing Fallback Functions: A Semantic Approach to Type Safe Smart Contracts](https://arxiv.org/abs/2512.04755)
*Stian Lybech,Daniele Gorla,Luca Aceto*

Main category: cs.PL

TL;DR: 该论文提出在智能合约环境中使用语义类型来确保包含静态不可类型化构造（如fallback函数）的代码的类型安全，采用证明携带代码方法，用户只需验证类型安全证明证书。


<details>
  <summary>Details</summary>
Motivation: 智能合约中常使用静态不可类型化的语言构造（如fallback函数），这些构造难以通过传统类型系统保证类型安全，需要一种方法在区块链不可变环境中确保这类代码的安全性。

Method: 采用证明携带代码方法：合约创建者为包含不可类型化构造的代码提供形式化类型安全证明；用户只需验证证明证书的有效性；基于TINYSOL语言（Solidity的精简版）实现，通过安全类型确保信息流控制和非干扰性；使用共归纳定义的类型解释和up-to技术紧凑表示证明。

Result: 开发了适用于区块链/智能合约环境的语义类型理论框架；能够为包含fallback函数的典型指针到实现模式提供类型安全保证；实现了信息流控制和非干扰性的安全类型系统。

Conclusion: 该研究的主要贡献不是安全性定理本身，而是展示了在区块链/智能合约环境中实现这种证明携带代码方法所需的理论发展，为处理静态不可类型化构造提供了可行的解决方案。

Abstract: This paper develops semantic typing in a smart-contract setting to ensure type safety of code that uses statically untypable language constructs, such as the fallback function. The idea is that the creator of a contract on the blockchain equips code containing such constructs with a formal proof of its type safety, given in terms of the semantics of types. Then, a user of the contract only needs to check the validity of the provided `proof certificate' of type safety. This is a form of proof-carrying code, which naturally fits with the immutable nature of the blockchain environment.
  As a concrete application of our approach, we focus on ensuring information flow control and non-interference for the language TINYSOL, a distilled version of the Solidity language, through security types. We provide the semantics of types in terms of a typed operational semantics of TINYSOL, and a way for expressing the proofs of safety as coinductively-defined typing interpretations and for representing them compactly via up-to techniques, similar to those used for bisimilarity. We also show how our machinery can be used to type the typical pointer-to-implementation pattern based on the fallback function. However, our main contribution is not the safety theorem per se (and so security properties different from non-interference can be considered as well), but rather the presentation of the theoretical developments necessary to make this approach work in a blockchain/smart-contract setting.

</details>


### [2] [Optimizations and extensions for fair join pattern matching](https://arxiv.org/abs/2512.04876)
*Ioannis Karras*

Main category: cs.PL

TL;DR: 优化了基于状态树的公平连接模式匹配算法，性能提升最高达10倍，接近Rete算法在常规基准测试中的表现，同时保持了复杂守卫条件下的优势。


<details>
  <summary>Details</summary>
Motivation: 现有公平连接模式匹配算法在时间效率方面研究不足，Haller等人的状态树算法在常规基准测试中表现不如Rete算法，而Rete算法需要大量手动适配才能应用于连接模式匹配。

Method: 增强和优化Haller等人的状态树匹配算法，改进基准测试套件，扩展连接模式实现（包括更清晰的语法和动态模式切换），并展示在微服务Web架构中的新应用案例。

Result: 在某些基准测试中实现了高达10倍的性能提升，接近Rete算法在常规基准测试中的表现，同时保持了在复杂守卫条件下的优势和多功能性。

Conclusion: 优化的状态树算法在性能上显著提升，接近Rete算法的表现，同时保持了原有优势，扩展了连接模式在微服务架构等复杂场景中的应用能力。

Abstract: Join patterns are an underexplored approach for the programming of concurrent and distributed systems. When applied to the actor model, join patterns offer the novel capability of matching combinations of messages in the mailbox of an actor. Previous work by Philipp Haller et al. in the paper "Fair Join Pattern Matching for Actors" (ECOOP 2024) explored join patterns with conditional guards in an actor-based setting with a specification of fair and deterministic matching semantics. Nevertheless, the question of time efficiency in fair join pattern matching has remained underexplored. The stateful tree-based matching algorithm of Haller et al. performs worse than an implementation that adapts the Rete algorithm to the regular version of a join pattern matching benchmark, while outperforming on a variant with heavy conditional guards, which take longer to evaluate. Nevertheless, conforming Rete to the problem of join pattern matching requires heavy manual adaptation.
  In this thesis, we enhance and optimize the stateful tree-based matching algorithm of Haller et al. to achieve up to tenfold performance improvements on certain benchmarks, approaching the performance of Rete on regular benchmarks while maintaining the advantages of versatility and performance with heavy guards. We also enhance the benchmark suite, adding new features and enhancing its extensibility and user-friendliness. We extend the join pattern implementation with a less ambiguous syntax as well as dynamic pattern switching. Finally, we present a new complex model use case for join patterns, showing their applicability in a microservice web architecture.

</details>
