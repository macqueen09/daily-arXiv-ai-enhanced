{"id": "2512.11762", "pdf": "https://arxiv.org/pdf/2512.11762", "abs": "https://arxiv.org/abs/2512.11762", "authors": ["Jack Liell-Cock", "Zev Shirazi", "Sam Staton"], "title": "The Relative Monadic Metalanguage", "categories": ["cs.PL", "math.CT"], "comment": "41 pages. Published in Proceedings of the ACM on Programming Languages (POPL 2026)", "summary": "Relative monads provide a controlled view of computation. We generalise the monadic metalanguage to a relative setting and give a complete semantics with strong relative monads. Adopting this perspective, we generalise two existing program calculi from the literature. We provide a linear-non-linear language for graded monads, LNL-RMM, along with a semantic proof that it is a conservative extension of the graded monadic metalanguage. Additionally, we provide a complete semantics for the arrow calculus, showing it is a restricted relative monadic metalanguage. This motivates the introduction of ARMM, a computational lambda calculus-style language for arrows that conservatively extends the arrow calculus."}
{"id": "2512.10977", "pdf": "https://arxiv.org/pdf/2512.10977", "abs": "https://arxiv.org/abs/2512.10977", "authors": ["Alec M. Hammond", "Aram Markosyan", "Aman Dontula", "Simon Mahns", "Zacharias Fisches", "Dmitrii Pedchenko", "Keyur Muzumdar", "Natacha Supper", "Mark Saroufim", "Joe Isaacson", "Laura Wang", "Warren Hunt", "Kaustubh Gondkar", "Roman Levenstein", "Gabriel Synnaeve", "Richard Li", "Jacob Kahn", "Ajit Mathews"], "title": "Agentic Operator Generation for ML ASICs", "categories": ["cs.DC", "cs.AR", "cs.PL"], "comment": null, "summary": "We present TritorX, an agentic AI system designed to generate functionally correct Triton PyTorch ATen kernels at scale for emerging accelerator platforms. TritorX integrates open-source large language models with a custom linter, JIT compilation, and a PyTorch OpInfo-based test harness. This pipeline is compatible with both real Meta Training and Inference Accelerator (MTIA) silicon and in hardware simulation environments for next-generation devices. In contrast to previous kernel-generation approaches that prioritize performance for a limited set of high-usage kernels, TritorX prioritizes coverage. Our system emphasizes correctness and generality across the entire operator set, including diverse data types, shapes, and argument patterns. In our experiments, TritorX successfully generated kernels and wrappers for 481 unique ATen operators that pass all corresponding PyTorch OpInfo tests (over 20,000 in total). TritorX paves the way for overnight generation of complete PyTorch ATen backends for new accelerator platforms."}
{"id": "2512.11200", "pdf": "https://arxiv.org/pdf/2512.11200", "abs": "https://arxiv.org/abs/2512.11200", "authors": ["Adilet Metinov", "Gulida M. Kudakeeva", "Gulnara D. Kabaeva"], "title": "Theoretical Foundations of GPU-Native Compilation for Rapid Code Iteration", "categories": ["cs.DC", "cs.LG", "cs.PL"], "comment": "9 pages , 2 tables", "summary": "Current AI code generation systems suffer from significant latency bottlenecks due to CPU-GPU data transfers during compilation, execution, and testing phases. We establish theoretical foundations for three complementary approaches to GPU-native compilation that eliminate these transfers: (1) parallel traditional compilation adapted for GPU execution, (2) neural compilation using learned sequence-to-sequence translation with probabilistic verification, and (3) hybrid architectures combining both strategies. We derive latency and energy bounds demonstrating potential speedups of 10-100x for code iteration cycles. Our analysis shows that traditional GPU compilation provides 2-5x improvements through transfer elimination, neural compilation achieves 10-100x speedups via massive parallelism, and hybrid approaches offer practical deployment paths with guaranteed correctness. We formalize the probabilistic verification framework that enables trading compilation accuracy for parallel exploration, and discuss implications for self-improving AI systems and future analog computing substrates."}
{"id": "2512.11577", "pdf": "https://arxiv.org/pdf/2512.11577", "abs": "https://arxiv.org/abs/2512.11577", "authors": ["Sergei Stepanenko", "Emma Nardino", "Virgil Marionneau", "Dan Frumin", "Amin Timany", "Lars Birkedal"], "title": "Context-Dependent Effects and Concurrency in Guarded Interaction Trees", "categories": ["cs.LO", "cs.PL"], "comment": null, "summary": "Guarded Interaction Trees are a structure and a fully formalized framework for representing higher-order computations with higher-order effects in Rocq. We present an extension of Guarded Interaction Trees to support formal reasoning about context-dependent effects. That is, effects whose behaviors depend on the evaluation context, e.g., call/cc, shift and reset. Using and reasoning about such effects is challenging since certain compositionality principles no longer hold in the presence of such effects. For example, the so-called ``bind rule'' in modern program logics is no longer valid. The goal of our extension is to support representation and reasoning about context-dependent effects in the most painless way possible. To that end, our extension is conservative: the reasoning principles for context-independent effects remain the same. We use it to give direct-style denotational semantics for higher-order programming languages with call/cc and with delimited continuations. We extend the program logic for Guarded Interaction Trees to account for context-dependent effects, and we use the program logic to prove that the denotational semantics is adequate with respect to the operational semantics. Additionally, we retain the ability to combine multiple effects in a modular way, which we demonstrate by showing type soundness for safe interoperability of a programming language with delimited continuations and a programming language with higher-order store. Furthermore, as another contribution, in addition to context-dependent effects, we show how to extend Guarded Interaction Trees with preemptive concurrency. To support implementation and verification of concurrent data structures and algorithms in the presence of preemptive concurrency one requires atomic state modification operations, e.g., compare-and-exchange."}
