<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.SE](#cs.SE) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Sharing State Between Prompts and Programs](https://arxiv.org/abs/2512.14805)
*Ellie Y. Cheng,Logan Weber,Tian Jin,Michael Carbin*

Main category: cs.PL

TL;DR: Nightjar编程系统引入共享程序状态抽象，让自然语言代码直接与Python程序状态交互，减少手动代码量39.6%，但带来0.4-4.3倍运行时开销


<details>
  <summary>Details</summary>
Motivation: 大型语言模型催生了自然语言编程，但自然语言代码与Python等正式语言之间的互操作性需要大量手动工作。研究者希望消除这种手动工作，让自然语言代码能直接操作程序变量、对象和控制流。

Method: 提出共享程序状态编程抽象，通过自然函数接口模式扩展编程系统支持自然代码。在Nightjar系统中实现该抽象，让Python程序中的自然语言代码能共享Python程序状态。

Result: Nightjar程序相比手动实现达到相当或更高的任务准确率（提升4-19%），平均减少39.6%代码行数。代价是运行时开销为手动实现的0.4-4.3倍。

Conclusion: 共享程序状态抽象有效简化了自然语言代码与正式语言的互操作性，在保持或提升准确率的同时显著减少代码量，但需要考虑运行时开销的权衡。

Abstract: The rise of large language models (LLMs) has introduced a new type of programming: natural language programming. By writing prompts that direct LLMs to perform natural language processing, code generation, reasoning, etc., users are writing code in natural language -- natural language code -- for the LLM to execute.
  An emerging area of research enables interoperability between natural language code and formal languages such as Python. We present a novel programming abstraction, shared program state, that removes the manual work required to enable interoperability between natural language code and program state. With shared program state, programmers can write natural code that directly writes program variables, computes with program objects, and implements control flow in the program. We present a schema for specifying natural function interfaces that extend programming systems to support natural code and leverage this schema to specify shared program state as a natural function interface.
  We implement shared program state in the Nightjar programming system. Nightjar enables programmers to write Python programs that contain natural code that shares the Python program state. We show that Nightjar programs achieve comparable or higher task accuracy than manually written implementations (+4-19%), while decreasing the lines of code by 39.6% on average. The tradeoff to using Nightjar is that it may incur runtime overhead (0.4-4.3x runtime of manual implementations).

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [2] [A High-level Synthesis Toolchain for the Julia Language](https://arxiv.org/abs/2512.15679)
*Benedict Short,Ian McInerney,John Wickerson*

Main category: cs.SE

TL;DR: 提出基于MLIR的Julia到SystemVerilog编译器工具链，解决FPGA专用加速器开发的"双语言问题"，让领域专家能用Julia编写计算内核并自动生成FPGA代码。


<details>
  <summary>Details</summary>
Motivation: 随着Exascale计算和数据驱动方法的发展，问题规模急剧增加，需要将计算卸载到GPU/TPU等硬件加速器，或设计基于FPGA的专用加速器。但当前专用加速器开发存在"双语言问题"：算法用高级语言开发，而内核需用完全不同抽象级别的语言实现，需要不同专业知识。

Method: 提出基于MLIR的编译器工具链，自动将Julia编程语言编写的内核编译为SystemVerilog，无需额外指令或语言定制。支持动态和静态调度，直接集成AXI4-Stream协议与内存子系统接口，生成供应商无关的RTL。

Result: 原型工具链能够合成一组信号处理/数学基准测试，在真实FPGA设备上以100MHz运行，达到仅从C/C++等低级语言编译的最先进工具链生成设计吞吐量的59.71%到82.6%。

Conclusion: 该工具链允许领域专家像往常一样用Julia编写计算内核，然后无需额外编译指示或修改即可将其重定向到FPGA，解决了专用加速器开发的"双语言问题"。

Abstract: With the push towards Exascale computing and data-driven methods, problem sizes have increased dramatically, increasing the computational requirements of the underlying algorithms. This has led to a push to offload computations to general purpose hardware accelerators such as GPUs and TPUs, and a renewed interest in designing problem-specific accelerators using FPGAs. However, the development process of these problem-specific accelerators currently suffers from the "two-language problem": algorithms are developed in one (usually higher-level) language, but the kernels are implemented in another language at a completely different level of abstraction and requiring fundamentally different expertise. To address this problem, we propose a new MLIR-based compiler toolchain that unifies the development process by automatically compiling kernels written in the Julia programming language into SystemVerilog without the need for any additional directives or language customisations. Our toolchain supports both dynamic and static scheduling, directly integrates with the AXI4-Stream protocol to interface with subsystems like on- and off-chip memory, and generates vendor-agnostic RTL. This prototype toolchain is able to synthesize a set of signal processing/mathematical benchmarks that can operate at 100MHz on real FPGA devices, achieving between 59.71% and 82.6% of the throughput of designs generated by state-of-the-art toolchains that only compile from low-level languages like C or C++. Overall, this toolchain allows domain experts to write compute kernels in Julia as they normally would, and then retarget them to an FPGA without additional pragmas or modifications.

</details>
