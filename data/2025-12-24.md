<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.CR](#cs.CR) [Total: 1]
- [cs.SE](#cs.SE) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Error Localization, Certificates, and Hints for Probabilistic Program Verification via Slicing (Extended Version)](https://arxiv.org/abs/2512.20214)
*Philipp Schröer,Darion Haase,Joost-Pieter Katoen*

Main category: cs.PL

TL;DR: 本文提出了一种基于切片技术的概率程序演绎验证用户诊断方法，包括错误报告、证明简化和验证结果保留三种诊断概念，并在Caesar验证器中实现为Brutus工具。


<details>
  <summary>Details</summary>
Motivation: 概率程序验证中缺乏有效的用户诊断工具，难以定位错误、简化证明过程并保留成功验证结果，需要系统化的诊断方法来提高验证效率和用户体验。

Method: 基于HeyVL定量中间验证语言，形式化定义三种诊断切片概念：错误报告切片、证明简化切片和验证结果保留切片。在Caesar验证器中实现Brutus工具，采用二分搜索算法最小化错误见证切片，并比较基于不可满足核、最小不可满足子集枚举和直接SMT编码的多种算法。

Result: Brutus工具能够在现有和新基准测试中找到既小又信息丰富的切片，有效支持定量断言错误定位、证明规则简化，并保持验证结果正确性。

Conclusion: 基于切片的用户诊断方法为概率程序验证提供了有效的错误定位和证明简化工具，形式化定义和实现验证了该方法的可行性和实用性。

Abstract: This paper focuses on effective user diagnostics generated during the deductive verification of probabilistic programs. Our key principle is based on providing slices for (1) error reporting, (2) proof simplification, and (3) preserving successful verification results. By formally defining these different notions on HeyVL, an existing quantitative intermediate verification language (IVL), our concepts (and implementation) can be used to obtain diagnostics for a range of probabilistic programming languages. Slicing for error reporting is a novel notion of error localization for quantitative assertions. We demonstrate slicing-based diagnostics on a variety of proof rules such as quantitative versions of the specification statement and invariant-based loop rules, and formally prove the correctness of specialized error messages and verification hints.
  We implemented our user diagnostics into the deductive verifier Caesar. Our novel implementation -- called \emph{Brutus} -- can search for slices which do or do not verify, corresponding to each of the three diagnostic notions. For error reporting (1), it exploits a binary search-based algorithm that minimizes error-witnessing slices. To solve for slices that verify (2 and 3), we empirically compare different algorithms based on unsatisfiable cores, minimal unsatisfiable subset enumeration, and a direct SMT encoding of the slicing problem. Our empirical evaluation of Brutus on existing and new benchmarks shows that we can find slices that are both small and informative.

</details>


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [2] [Symmaries: Automatic Inference of Formal Security Summaries for Java Programs](https://arxiv.org/abs/2512.20396)
*Narges Khakpour,Nicolas Berthier*

Main category: cs.CR

TL;DR: Symmaries工具通过自动生成Java字节码程序的形式化安全规约（方法摘要），为静态代码分析提供可扩展、模块化且可靠的安全行为抽象表示。


<details>
  <summary>Details</summary>
Motivation: 需要自动化构建Java程序的形式化安全规约，以帮助静态分析工具和开发者理解代码（特别是库代码）的安全行为，评估在应用程序中重用时的安全影响。

Method: 提出可扩展、模块化且可靠的方法，自动构建Java字节码程序的安全规约作为方法摘要。摘要包含安全调用条件、信息流和别名更新规约。实现为Symmaries工具。

Result: Symmaries成功应用于Java API库提取安全规约，并能扩展到分析数十万行代码的大型实际应用。工具精度取决于堆模型，证明了终止不敏感非干扰性的可靠性。

Conclusion: Symmaries提供了一种自动化生成Java程序安全规约的有效方法，具有可扩展性和可靠性，为静态安全分析和代码理解提供了实用工具。

Abstract: We introduce a scalable, modular, and sound approach for automatically constructing formal security specifications for Java bytecode programs in the form of method summaries. A summary provides an abstract representation of a method's security behavior, consisting of the conditions under which the method can be securely invoked, together with specifications of information flows and aliasing updates. Such summaries can be consumed by static code analysis tools and also help developers understand the behavior of code segments, such as libraries, in order to evaluate their security implications when reused in applications. Our approach is implemented in a tool called Symmaries, which automates the generation of security summaries. We applied Symmaries to Java API libraries to extract their security specifications and to large real-world applications to evaluate its scalability. Our results show that the tool successfully scales to analyze applications with hundreds of thousands of lines of code, and that Symmaries achieves a promising precision depending on the heap model used. We prove the soundness of our approach in terms of guaranteeing termination-insensitive non-interference.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [3] [A Declarative Language for Building And Orchestrating LLM-Powered Agent Workflows](https://arxiv.org/abs/2512.19769)
*Ivan Daunis*

Main category: cs.SE

TL;DR: 提出一个声明式系统，将智能体工作流规范与实现分离，使同一管道定义能在多种后端语言和部署环境中执行，显著降低开发时间和部署速度。


<details>
  <summary>Details</summary>
Motivation: 现有系统将智能体逻辑与特定编程语言和部署模型紧密耦合，导致构建部署就绪的LLM智能体需要复杂的工具、数据源和控制流编排。

Method: 通过统一领域特定语言（DSL）表达智能体工作流的常见模式（数据序列化、过滤、RAG检索、API编排），将智能体开发从应用程序编程转变为配置管理。

Result: 在PayPal的真实电商工作流中，开发时间减少60%，部署速度提高3倍，复杂工作流仅需不到50行DSL代码（相比500+行命令式代码），编排开销低于100ms。

Conclusion: 声明式方法使非工程师能够安全修改智能体行为，同时支持A/B测试和跨语言/环境执行，显著提高了智能体工作流的开发效率和部署灵活性。

Abstract: Building deployment-ready LLM agents requires complex orchestration of tools, data sources, and control flow logic, yet existing systems tightly couple agent logic to specific programming languages and deployment models. We present a declarative system that separates agent workflow specification from implementation, enabling the same pipeline definition to execute across multiple backend languages (Java, Python, Go) and deployment environments (cloud-native, on-premises).
  Our key insight is that most agent workflows consist of common patterns -- data serialization, filtering, RAG retrieval, API orchestration -- that can be expressed through a unified DSL rather than imperative code. This approach transforms agent development from application programming to configuration, where adding new tools or fine-tuning agent behaviors requires only pipeline specification changes, not code deployment. Our system natively supports A/B testing of agent strategies, allowing multiple pipeline variants to run on the same backend infrastructure with automatic metric collection and comparison.
  We evaluate our approach on real-world e-commerce workflows at PayPal, processing millions of daily interactions. Our results demonstrate 60% reduction in development time, and 3x improvement in deployment velocity compared to imperative implementations. The language's declarative approach enables non-engineers to modify agent behaviors safely, while maintaining sub-100ms orchestration overhead. We show that complex workflows involving product search, personalization, and cart management can be expressed in under 50 lines of DSL compared to 500+ lines of imperative code.

</details>
