{"id": "2512.20214", "pdf": "https://arxiv.org/pdf/2512.20214", "abs": "https://arxiv.org/abs/2512.20214", "authors": ["Philipp Schr\u00f6er", "Darion Haase", "Joost-Pieter Katoen"], "title": "Error Localization, Certificates, and Hints for Probabilistic Program Verification via Slicing (Extended Version)", "categories": ["cs.PL"], "comment": null, "summary": "This paper focuses on effective user diagnostics generated during the deductive verification of probabilistic programs. Our key principle is based on providing slices for (1) error reporting, (2) proof simplification, and (3) preserving successful verification results. By formally defining these different notions on HeyVL, an existing quantitative intermediate verification language (IVL), our concepts (and implementation) can be used to obtain diagnostics for a range of probabilistic programming languages. Slicing for error reporting is a novel notion of error localization for quantitative assertions. We demonstrate slicing-based diagnostics on a variety of proof rules such as quantitative versions of the specification statement and invariant-based loop rules, and formally prove the correctness of specialized error messages and verification hints.\n  We implemented our user diagnostics into the deductive verifier Caesar. Our novel implementation -- called \\emph{Brutus} -- can search for slices which do or do not verify, corresponding to each of the three diagnostic notions. For error reporting (1), it exploits a binary search-based algorithm that minimizes error-witnessing slices. To solve for slices that verify (2 and 3), we empirically compare different algorithms based on unsatisfiable cores, minimal unsatisfiable subset enumeration, and a direct SMT encoding of the slicing problem. Our empirical evaluation of Brutus on existing and new benchmarks shows that we can find slices that are both small and informative.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u5207\u7247\u6280\u672f\u7684\u6982\u7387\u7a0b\u5e8f\u6f14\u7ece\u9a8c\u8bc1\u7528\u6237\u8bca\u65ad\u65b9\u6cd5\uff0c\u5305\u62ec\u9519\u8bef\u62a5\u544a\u3001\u8bc1\u660e\u7b80\u5316\u548c\u9a8c\u8bc1\u7ed3\u679c\u4fdd\u7559\u4e09\u79cd\u8bca\u65ad\u6982\u5ff5\uff0c\u5e76\u5728Caesar\u9a8c\u8bc1\u5668\u4e2d\u5b9e\u73b0\u4e3aBrutus\u5de5\u5177\u3002", "motivation": "\u6982\u7387\u7a0b\u5e8f\u9a8c\u8bc1\u4e2d\u7f3a\u4e4f\u6709\u6548\u7684\u7528\u6237\u8bca\u65ad\u5de5\u5177\uff0c\u96be\u4ee5\u5b9a\u4f4d\u9519\u8bef\u3001\u7b80\u5316\u8bc1\u660e\u8fc7\u7a0b\u5e76\u4fdd\u7559\u6210\u529f\u9a8c\u8bc1\u7ed3\u679c\uff0c\u9700\u8981\u7cfb\u7edf\u5316\u7684\u8bca\u65ad\u65b9\u6cd5\u6765\u63d0\u9ad8\u9a8c\u8bc1\u6548\u7387\u548c\u7528\u6237\u4f53\u9a8c\u3002", "method": "\u57fa\u4e8eHeyVL\u5b9a\u91cf\u4e2d\u95f4\u9a8c\u8bc1\u8bed\u8a00\uff0c\u5f62\u5f0f\u5316\u5b9a\u4e49\u4e09\u79cd\u8bca\u65ad\u5207\u7247\u6982\u5ff5\uff1a\u9519\u8bef\u62a5\u544a\u5207\u7247\u3001\u8bc1\u660e\u7b80\u5316\u5207\u7247\u548c\u9a8c\u8bc1\u7ed3\u679c\u4fdd\u7559\u5207\u7247\u3002\u5728Caesar\u9a8c\u8bc1\u5668\u4e2d\u5b9e\u73b0Brutus\u5de5\u5177\uff0c\u91c7\u7528\u4e8c\u5206\u641c\u7d22\u7b97\u6cd5\u6700\u5c0f\u5316\u9519\u8bef\u89c1\u8bc1\u5207\u7247\uff0c\u5e76\u6bd4\u8f83\u57fa\u4e8e\u4e0d\u53ef\u6ee1\u8db3\u6838\u3001\u6700\u5c0f\u4e0d\u53ef\u6ee1\u8db3\u5b50\u96c6\u679a\u4e3e\u548c\u76f4\u63a5SMT\u7f16\u7801\u7684\u591a\u79cd\u7b97\u6cd5\u3002", "result": "Brutus\u5de5\u5177\u80fd\u591f\u5728\u73b0\u6709\u548c\u65b0\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u627e\u5230\u65e2\u5c0f\u53c8\u4fe1\u606f\u4e30\u5bcc\u7684\u5207\u7247\uff0c\u6709\u6548\u652f\u6301\u5b9a\u91cf\u65ad\u8a00\u9519\u8bef\u5b9a\u4f4d\u3001\u8bc1\u660e\u89c4\u5219\u7b80\u5316\uff0c\u5e76\u4fdd\u6301\u9a8c\u8bc1\u7ed3\u679c\u6b63\u786e\u6027\u3002", "conclusion": "\u57fa\u4e8e\u5207\u7247\u7684\u7528\u6237\u8bca\u65ad\u65b9\u6cd5\u4e3a\u6982\u7387\u7a0b\u5e8f\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u6709\u6548\u7684\u9519\u8bef\u5b9a\u4f4d\u548c\u8bc1\u660e\u7b80\u5316\u5de5\u5177\uff0c\u5f62\u5f0f\u5316\u5b9a\u4e49\u548c\u5b9e\u73b0\u9a8c\u8bc1\u4e86\u8be5\u65b9\u6cd5\u7684\u53ef\u884c\u6027\u548c\u5b9e\u7528\u6027\u3002"}}
{"id": "2512.19769", "pdf": "https://arxiv.org/pdf/2512.19769", "abs": "https://arxiv.org/abs/2512.19769", "authors": ["Ivan Daunis"], "title": "A Declarative Language for Building And Orchestrating LLM-Powered Agent Workflows", "categories": ["cs.SE", "cs.AI", "cs.PL"], "comment": null, "summary": "Building deployment-ready LLM agents requires complex orchestration of tools, data sources, and control flow logic, yet existing systems tightly couple agent logic to specific programming languages and deployment models. We present a declarative system that separates agent workflow specification from implementation, enabling the same pipeline definition to execute across multiple backend languages (Java, Python, Go) and deployment environments (cloud-native, on-premises).\n  Our key insight is that most agent workflows consist of common patterns -- data serialization, filtering, RAG retrieval, API orchestration -- that can be expressed through a unified DSL rather than imperative code. This approach transforms agent development from application programming to configuration, where adding new tools or fine-tuning agent behaviors requires only pipeline specification changes, not code deployment. Our system natively supports A/B testing of agent strategies, allowing multiple pipeline variants to run on the same backend infrastructure with automatic metric collection and comparison.\n  We evaluate our approach on real-world e-commerce workflows at PayPal, processing millions of daily interactions. Our results demonstrate 60% reduction in development time, and 3x improvement in deployment velocity compared to imperative implementations. The language's declarative approach enables non-engineers to modify agent behaviors safely, while maintaining sub-100ms orchestration overhead. We show that complex workflows involving product search, personalization, and cart management can be expressed in under 50 lines of DSL compared to 500+ lines of imperative code.", "AI": {"tldr": "\u63d0\u51fa\u4e00\u4e2a\u58f0\u660e\u5f0f\u7cfb\u7edf\uff0c\u5c06\u667a\u80fd\u4f53\u5de5\u4f5c\u6d41\u89c4\u8303\u4e0e\u5b9e\u73b0\u5206\u79bb\uff0c\u4f7f\u540c\u4e00\u7ba1\u9053\u5b9a\u4e49\u80fd\u5728\u591a\u79cd\u540e\u7aef\u8bed\u8a00\u548c\u90e8\u7f72\u73af\u5883\u4e2d\u6267\u884c\uff0c\u663e\u8457\u964d\u4f4e\u5f00\u53d1\u65f6\u95f4\u548c\u90e8\u7f72\u901f\u5ea6\u3002", "motivation": "\u73b0\u6709\u7cfb\u7edf\u5c06\u667a\u80fd\u4f53\u903b\u8f91\u4e0e\u7279\u5b9a\u7f16\u7a0b\u8bed\u8a00\u548c\u90e8\u7f72\u6a21\u578b\u7d27\u5bc6\u8026\u5408\uff0c\u5bfc\u81f4\u6784\u5efa\u90e8\u7f72\u5c31\u7eea\u7684LLM\u667a\u80fd\u4f53\u9700\u8981\u590d\u6742\u7684\u5de5\u5177\u3001\u6570\u636e\u6e90\u548c\u63a7\u5236\u6d41\u7f16\u6392\u3002", "method": "\u901a\u8fc7\u7edf\u4e00\u9886\u57df\u7279\u5b9a\u8bed\u8a00\uff08DSL\uff09\u8868\u8fbe\u667a\u80fd\u4f53\u5de5\u4f5c\u6d41\u7684\u5e38\u89c1\u6a21\u5f0f\uff08\u6570\u636e\u5e8f\u5217\u5316\u3001\u8fc7\u6ee4\u3001RAG\u68c0\u7d22\u3001API\u7f16\u6392\uff09\uff0c\u5c06\u667a\u80fd\u4f53\u5f00\u53d1\u4ece\u5e94\u7528\u7a0b\u5e8f\u7f16\u7a0b\u8f6c\u53d8\u4e3a\u914d\u7f6e\u7ba1\u7406\u3002", "result": "\u5728PayPal\u7684\u771f\u5b9e\u7535\u5546\u5de5\u4f5c\u6d41\u4e2d\uff0c\u5f00\u53d1\u65f6\u95f4\u51cf\u5c1160%\uff0c\u90e8\u7f72\u901f\u5ea6\u63d0\u9ad83\u500d\uff0c\u590d\u6742\u5de5\u4f5c\u6d41\u4ec5\u9700\u4e0d\u523050\u884cDSL\u4ee3\u7801\uff08\u76f8\u6bd4500+\u884c\u547d\u4ee4\u5f0f\u4ee3\u7801\uff09\uff0c\u7f16\u6392\u5f00\u9500\u4f4e\u4e8e100ms\u3002", "conclusion": "\u58f0\u660e\u5f0f\u65b9\u6cd5\u4f7f\u975e\u5de5\u7a0b\u5e08\u80fd\u591f\u5b89\u5168\u4fee\u6539\u667a\u80fd\u4f53\u884c\u4e3a\uff0c\u540c\u65f6\u652f\u6301A/B\u6d4b\u8bd5\u548c\u8de8\u8bed\u8a00/\u73af\u5883\u6267\u884c\uff0c\u663e\u8457\u63d0\u9ad8\u4e86\u667a\u80fd\u4f53\u5de5\u4f5c\u6d41\u7684\u5f00\u53d1\u6548\u7387\u548c\u90e8\u7f72\u7075\u6d3b\u6027\u3002"}}
{"id": "2512.20396", "pdf": "https://arxiv.org/pdf/2512.20396", "abs": "https://arxiv.org/abs/2512.20396", "authors": ["Narges Khakpour", "Nicolas Berthier"], "title": "Symmaries: Automatic Inference of Formal Security Summaries for Java Programs", "categories": ["cs.CR", "cs.FL", "cs.PL", "cs.SE"], "comment": null, "summary": "We introduce a scalable, modular, and sound approach for automatically constructing formal security specifications for Java bytecode programs in the form of method summaries. A summary provides an abstract representation of a method's security behavior, consisting of the conditions under which the method can be securely invoked, together with specifications of information flows and aliasing updates. Such summaries can be consumed by static code analysis tools and also help developers understand the behavior of code segments, such as libraries, in order to evaluate their security implications when reused in applications. Our approach is implemented in a tool called Symmaries, which automates the generation of security summaries. We applied Symmaries to Java API libraries to extract their security specifications and to large real-world applications to evaluate its scalability. Our results show that the tool successfully scales to analyze applications with hundreds of thousands of lines of code, and that Symmaries achieves a promising precision depending on the heap model used. We prove the soundness of our approach in terms of guaranteeing termination-insensitive non-interference.", "AI": {"tldr": "Symmaries\u5de5\u5177\u901a\u8fc7\u81ea\u52a8\u751f\u6210Java\u5b57\u8282\u7801\u7a0b\u5e8f\u7684\u5f62\u5f0f\u5316\u5b89\u5168\u89c4\u7ea6\uff08\u65b9\u6cd5\u6458\u8981\uff09\uff0c\u4e3a\u9759\u6001\u4ee3\u7801\u5206\u6790\u63d0\u4f9b\u53ef\u6269\u5c55\u3001\u6a21\u5757\u5316\u4e14\u53ef\u9760\u7684\u5b89\u5168\u884c\u4e3a\u62bd\u8c61\u8868\u793a\u3002", "motivation": "\u9700\u8981\u81ea\u52a8\u5316\u6784\u5efaJava\u7a0b\u5e8f\u7684\u5f62\u5f0f\u5316\u5b89\u5168\u89c4\u7ea6\uff0c\u4ee5\u5e2e\u52a9\u9759\u6001\u5206\u6790\u5de5\u5177\u548c\u5f00\u53d1\u8005\u7406\u89e3\u4ee3\u7801\uff08\u7279\u522b\u662f\u5e93\u4ee3\u7801\uff09\u7684\u5b89\u5168\u884c\u4e3a\uff0c\u8bc4\u4f30\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u91cd\u7528\u65f6\u7684\u5b89\u5168\u5f71\u54cd\u3002", "method": "\u63d0\u51fa\u53ef\u6269\u5c55\u3001\u6a21\u5757\u5316\u4e14\u53ef\u9760\u7684\u65b9\u6cd5\uff0c\u81ea\u52a8\u6784\u5efaJava\u5b57\u8282\u7801\u7a0b\u5e8f\u7684\u5b89\u5168\u89c4\u7ea6\u4f5c\u4e3a\u65b9\u6cd5\u6458\u8981\u3002\u6458\u8981\u5305\u542b\u5b89\u5168\u8c03\u7528\u6761\u4ef6\u3001\u4fe1\u606f\u6d41\u548c\u522b\u540d\u66f4\u65b0\u89c4\u7ea6\u3002\u5b9e\u73b0\u4e3aSymmaries\u5de5\u5177\u3002", "result": "Symmaries\u6210\u529f\u5e94\u7528\u4e8eJava API\u5e93\u63d0\u53d6\u5b89\u5168\u89c4\u7ea6\uff0c\u5e76\u80fd\u6269\u5c55\u5230\u5206\u6790\u6570\u5341\u4e07\u884c\u4ee3\u7801\u7684\u5927\u578b\u5b9e\u9645\u5e94\u7528\u3002\u5de5\u5177\u7cbe\u5ea6\u53d6\u51b3\u4e8e\u5806\u6a21\u578b\uff0c\u8bc1\u660e\u4e86\u7ec8\u6b62\u4e0d\u654f\u611f\u975e\u5e72\u6270\u6027\u7684\u53ef\u9760\u6027\u3002", "conclusion": "Symmaries\u63d0\u4f9b\u4e86\u4e00\u79cd\u81ea\u52a8\u5316\u751f\u6210Java\u7a0b\u5e8f\u5b89\u5168\u89c4\u7ea6\u7684\u6709\u6548\u65b9\u6cd5\uff0c\u5177\u6709\u53ef\u6269\u5c55\u6027\u548c\u53ef\u9760\u6027\uff0c\u4e3a\u9759\u6001\u5b89\u5168\u5206\u6790\u548c\u4ee3\u7801\u7406\u89e3\u63d0\u4f9b\u4e86\u5b9e\u7528\u5de5\u5177\u3002"}}
