<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 4]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Enforcing Temporal Constraints for LLM Agents](https://arxiv.org/abs/2512.23738)
*Adharsh Kamath,Sishen Zhang,Calvin Xu,Shubham Ugare,Gagandeep Singh,Sasa Misailovic*

Main category: cs.PL

TL;DR: Agent-C：一个为LLM智能体提供运行时安全保障的框架，确保智能体遵守时序安全策略，通过形式化规范、SMT求解和约束生成技术实现100%安全合规。


<details>
  <summary>Details</summary>
Motivation: 当前基于LLM的智能体被部署在安全关键应用中，但现有的防护系统无法防止违反时序安全策略的行为。现有方法依赖不精确的自然语言指令或事后监控，无法提供形式化保证。例如，智能体可能在用户认证前访问敏感数据，或在未经授权的情况下处理退款，这些都需要对动作序列进行推理。

Method: Agent-C框架包含：1）用于表达时序属性的领域特定语言；2）将规范转换为一阶逻辑；3）在token生成过程中使用SMT求解检测不合规的智能体动作；4）当LLM试图生成不合规的工具调用时，利用约束生成技术确保每个动作都符合规范，并为不合规动作生成合规替代方案。

Result: 在零售客服和机票预订系统两个真实应用中评估，Agent-C实现了完美安全（100%合规，0%伤害），同时相比最先进的防护系统和无限制智能体提高了任务效用。对于Claude Sonnet 4.5，合规率从77.4%提升到100%，效用从71.8%提升到75.2%；对于GPT-5，合规率从83.7%提升到100%，效用从66.1%提升到70.6%。

Conclusion: Agent-C为可靠的智能体推理设定了新的最先进前沿，通过形式化方法和运行时保证，确保LLM智能体在安全关键应用中遵守时序安全策略，同时提高任务性能。

Abstract: LLM-based agents are deployed in safety-critical applications, yet current guardrail systems fail to prevent violations of temporal safety policies, requirements that govern the ordering and sequencing of agent actions. For instance, agents may access sensitive data before authenticating users or process refunds to unauthorized payment methods, violations that require reasoning about sequences of action rather than an individual action. Existing guardrails rely on imprecise natural language instructions or post-hoc monitoring, and provide no formal guarantees that agents will satisfy temporal constraints. We present Agent-C, a novel framework that provides run-time guarantees ensuring LLM agents adhere to formal temporal safety properties. Agent-C introduces a domain-specific language for expressing temporal properties (e.g., authenticate before accessing data), translates specifications to first-order logic, and uses SMT solving to detect non-compliant agent actions during token generation. When the LLM attempts to generate a non-compliant tool call, Agent-C leverages constrained generation techniques to ensure that every action generated by the LLM complies with the specification, and to generate a compliant alternative to a non-compliant agent action. We evaluate Agent-C across two real-world applications: retail customer service and airline ticket reservation system, and multiple language models (open and closed-source). Our results demonstrate that Agent-C achieves perfect safety (100% conformance, 0% harm), while improving task utility compared to state-of-the-art guardrails and unrestricted agents. On SoTA closed-source models, Agent-C improves conformance (77.4% to 100% for Claude Sonnet 4.5 and 83.7% to 100% for GPT-5), while simultaneously increasing utility (71.8% to 75.2% and 66.1% to 70.6%, respectively), representing a new SoTA frontier for reliable agentic reasoning.

</details>


### [2] [Towards representation agnostic probabilistic programming](https://arxiv.org/abs/2512.23740)
*Ole Fenske,Maximilian Popko,Sebastian Bader,Thomas Kirste*

Main category: cs.PL

TL;DR: 提出一种因子抽象层，作为概率编程中不同表示形式的通用接口，支持混合离散-连续模型的统一推理框架


<details>
  <summary>Details</summary>
Motivation: 现有概率编程语言将模型表示与特定推理算法紧密耦合，限制了新表示形式的实验和混合离散-连续模型的开发

Method: 引入包含五种基本操作的因子抽象层，作为操作因子的通用接口，支持不同表示形式（离散表、高斯分布、基于样本的方法等）在统一框架内混合使用

Result: 实现了表示无关的概率编程，能够在复杂混合模型中进行实际推理，解决了现有工具无法充分表达的问题

Conclusion: 因子抽象层为概率编程提供了灵活的基础设施，支持多种表示形式的自由组合，推动了混合离散-连续模型推理的发展

Abstract: Current probabilistic programming languages and tools tightly couple model representations with specific inference algorithms, preventing experimentation with novel representations or mixed discrete-continuous models. We introduce a factor abstraction with five fundamental operations that serve as a universal interface for manipulating factors regardless of their underlying representation. This enables representation-agnostic probabilistic programming where users can freely mix different representations (e.g. discrete tables, Gaussians distributions, sample-based approaches) within a single unified framework, allowing practical inference in complex hybrid models that current toolkits cannot adequately express.

</details>


### [3] [VGC: A High-Performance Zone-Based Garbage Collector Architecture for Python with Partitioning and Parallel Execution](https://arxiv.org/abs/2512.23768)
*Abdulla M*

Main category: cs.PL

TL;DR: VGC提出了一种新颖的双层垃圾收集框架，通过主动层（运行时并发标记清除）和被动层（编译时静态分配优化）相结合，显著减少暂停时间（达30%）和内存使用（达25%），适用于从嵌入式设备到高性能并行架构的多样化系统。


<details>
  <summary>Details</summary>
Motivation: 传统垃圾收集器在不同系统（从资源受限的嵌入式设备到高性能并行架构）上难以同时实现高效、低开销的内存管理。需要一种能够适应多样化环境、减少暂停时间、降低内存碎片化的解决方案。

Method: 采用双层架构：1）Active VGC（主动层）- 运行时使用并发标记清除策略管理动态对象，针对并行工作负载优化；2）Passive VGC（被动层）- 编译时通过预测性内存映射优化静态对象分配，将对象对齐到缓存边界以减少碎片化。

Result: 相比分代收集器，在多线程基准测试中暂停时间减少达30%；通过缓存边界对齐减少内存碎片，总内存使用减少达25%；提供可预测的内存访问模式，提升现代并行应用的扩展性。

Conclusion: VGC通过整合编译时和运行时优化，为内存密集型系统提供了一个鲁棒且适应性强的解决方案，能够跨越低级和高级编程环境，在多样化系统中实现高效内存管理。

Abstract: The Virtual Garbage Collector (VGC) introduces a novel memory management framework designed to optimize performance across diverse systems, ranging from resource constrained embedded devices to high performance parallel architectures. Unlike conventional garbage collectors, VGC employs a dual layer architecture consisting of Active VGC and Passive VGC to enable efficient, low overhead memory management. Active VGC dynamically manages runtime objects using a concurrent mark and sweep strategy tailored for parallel workloads, reducing pause times by up to 30 percent compared to generational collectors in multithreaded benchmarks. Passive VGC operates at compile time and optimizes static object allocation through predictive memory mapping, minimizing fragmentation by aligning objects to cache boundaries. This separation of responsibilities ensures predictable memory access patterns, reduces total memory usage by up to 25 percent, and improves scalability for modern parallel applications. By integrating compile time and runtime optimizations, VGC provides a robust and adaptable solution for memory intensive systems across both low level and high level programming environments.

</details>


### [4] [State Space Estimation for DPOR-based Model Checkers](https://arxiv.org/abs/2512.23996)
*A. R. Balasubramanian,Mohammad Hossein Khoshechin Jorshari,Rupak Majumdar,Umang Mathur,Minjian Zhang*

Main category: cs.PL

TL;DR: 提出首个多项式时间无偏估计器，用于计算并发程序的Mazurkiewicz迹等价类数量，解决模型检查中资源分配的关键问题。


<details>
  <summary>Details</summary>
Motivation: 并发程序的迹等价类数量估计对基于枚举的模型检查至关重要，它决定了模型检查的运行时间和搜索空间覆盖率。然而，精确计数是#P-难问题，且难以近似，需要高效的无偏估计方法。

Method: 将无状态最优DPOR算法转换为无偏估计器，将其探索视为有界深度和宽度的树，叶子节点是最大Mazurkiewicz迹。应用Knuth经典估计器，并通过随机枚举控制方差，维护每层部分路径的小种群。

Result: 在JMC模型检查器中实现，在共享内存基准测试中，即使状态空间有10^5-10^6个类，也能在数百次试验内获得稳定估计（通常在20%误差带内）。

Conclusion: 提出了首个可证明的多项式时间无偏估计器，用于计数迹等价类，解决了模型检查资源分配中的重要问题，并能通过加权所有探索图来估计模型检查成本。

Abstract: We study the estimation problem for concurrent programs: given a bounded program $P$, estimate the number of Mazurkiewicz trace-equivalence classes induced by its interleavings. This quantity informs two practical questions for enumeration-based model checking: how long a model checking run is likely to take, and what fraction of the search space has been covered so far. We first show the counting problem is #P-hard even for restricted programs and, unless $P=NP$, inapproximable within any subexponential factor, ruling out efficient exact or randomized approximation algorithms. We give a Monte Carlo approach to obtain a poly-time unbiased estimator: we convert a stateless optimal DPOR algorithm into an unbiased estimator by viewing its exploration as a bounded-depth, bounded-width tree whose leaves are the maximal Mazurkiewicz traces. A classical estimator by Knuth, when run on this tree, yields an unbiased estimate. To control the variance, we apply stochastic enumeration by maintaining a small population of partial paths per depth whose evolution is coupled. We have implemented our estimator in the JMC model checker and evaluated it on shared-memory benchmarks. With modest budgets, our estimator yields stable estimates, typically within a 20% band, within a few hundred trials, even when the state space has $10^5$--$10^6$ classes. We also show how the same machinery estimates model-checking cost by weighting all explored graphs, not only complete traces. Our algorithms provide the first provable poly-time unbiased estimators for counting traces, a problem of considerable importance when allocating model checking resources.

</details>
