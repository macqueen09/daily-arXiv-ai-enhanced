<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 4]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Enforcing Temporal Constraints for LLM Agents](https://arxiv.org/abs/2512.23738)
*Adharsh Kamath,Sishen Zhang,Calvin Xu,Shubham Ugare,Gagandeep Singh,Sasa Misailovic*

Main category: cs.PL

TL;DR: Agent-C：一个为LLM智能体提供运行时安全保障的框架，确保智能体遵守时序安全策略，实现100%合规性和0%危害


<details>
  <summary>Details</summary>
Motivation: 当前的安全护栏系统无法防止智能体违反时序安全策略（如用户认证前访问敏感数据），现有方法依赖不精确的自然语言指令或事后监控，缺乏形式化保证

Method: 引入领域特定语言表达时序属性，将规范转换为一阶逻辑，使用SMT求解在token生成时检测不合规动作，利用约束生成技术确保所有动作合规

Result: 在零售客服和机票预订系统中实现完美安全（100%合规，0%危害），同时提升任务效用，将Claude Sonnet 4.5合规率从77.4%提升至100%，GPT-5从83.7%提升至100%

Conclusion: Agent-C为LLM智能体提供了形式化的运行时安全保障，解决了时序安全策略的合规问题，代表了可靠智能推理的新前沿

Abstract: LLM-based agents are deployed in safety-critical applications, yet current guardrail systems fail to prevent violations of temporal safety policies, requirements that govern the ordering and sequencing of agent actions. For instance, agents may access sensitive data before authenticating users or process refunds to unauthorized payment methods, violations that require reasoning about sequences of action rather than an individual action. Existing guardrails rely on imprecise natural language instructions or post-hoc monitoring, and provide no formal guarantees that agents will satisfy temporal constraints. We present Agent-C, a novel framework that provides run-time guarantees ensuring LLM agents adhere to formal temporal safety properties. Agent-C introduces a domain-specific language for expressing temporal properties (e.g., authenticate before accessing data), translates specifications to first-order logic, and uses SMT solving to detect non-compliant agent actions during token generation. When the LLM attempts to generate a non-compliant tool call, Agent-C leverages constrained generation techniques to ensure that every action generated by the LLM complies with the specification, and to generate a compliant alternative to a non-compliant agent action. We evaluate Agent-C across two real-world applications: retail customer service and airline ticket reservation system, and multiple language models (open and closed-source). Our results demonstrate that Agent-C achieves perfect safety (100% conformance, 0% harm), while improving task utility compared to state-of-the-art guardrails and unrestricted agents. On SoTA closed-source models, Agent-C improves conformance (77.4% to 100% for Claude Sonnet 4.5 and 83.7% to 100% for GPT-5), while simultaneously increasing utility (71.8% to 75.2% and 66.1% to 70.6%, respectively), representing a new SoTA frontier for reliable agentic reasoning.

</details>


### [2] [Towards representation agnostic probabilistic programming](https://arxiv.org/abs/2512.23740)
*Ole Fenske,Maximilian Popko,Sebastian Bader,Thomas Kirste*

Main category: cs.PL

TL;DR: 提出一种因子抽象接口，实现表示无关的概率编程，允许在统一框架中混合不同表示形式


<details>
  <summary>Details</summary>
Motivation: 当前概率编程语言将模型表示与特定推理算法紧密耦合，限制了新表示形式或混合离散-连续模型的实验

Method: 引入包含五种基本操作的因子抽象，作为操作因子的通用接口，无论其底层表示形式如何

Result: 实现表示无关的概率编程，用户可以在统一框架中自由混合不同表示形式，支持当前工具无法充分表达的复杂混合模型

Conclusion: 因子抽象为概率编程提供了通用接口，解决了表示与算法耦合问题，使复杂混合模型的实用推理成为可能

Abstract: Current probabilistic programming languages and tools tightly couple model representations with specific inference algorithms, preventing experimentation with novel representations or mixed discrete-continuous models. We introduce a factor abstraction with five fundamental operations that serve as a universal interface for manipulating factors regardless of their underlying representation. This enables representation-agnostic probabilistic programming where users can freely mix different representations (e.g. discrete tables, Gaussians distributions, sample-based approaches) within a single unified framework, allowing practical inference in complex hybrid models that current toolkits cannot adequately express.

</details>


### [3] [VGC: A High-Performance Zone-Based Garbage Collector Architecture for Python with Partitioning and Parallel Execution](https://arxiv.org/abs/2512.23768)
*Abdulla M*

Main category: cs.PL

TL;DR: VGC提出了一种新颖的双层垃圾回收框架，通过分离编译时和运行时内存管理，优化了从嵌入式设备到并行架构的多种系统性能。


<details>
  <summary>Details</summary>
Motivation: 传统垃圾回收器在资源受限设备和并行架构上存在性能瓶颈，需要一种能够适应多样化系统、减少暂停时间和内存碎片的高效内存管理方案。

Method: 采用双层架构：Active VGC使用并发标记清扫策略动态管理运行时对象；Passive VGC在编译时通过预测性内存映射优化静态对象分配，将对象对齐到缓存边界。

Result: 与分代收集器相比，多线程基准测试中暂停时间减少30%；内存碎片最小化，总内存使用减少25%；为现代并行应用提供可预测的内存访问模式和更好的可扩展性。

Conclusion: VGC通过整合编译时和运行时优化，为从低级到高级编程环境的内存密集型系统提供了稳健且适应性强的内存管理解决方案。

Abstract: The Virtual Garbage Collector (VGC) introduces a novel memory management framework designed to optimize performance across diverse systems, ranging from resource constrained embedded devices to high performance parallel architectures. Unlike conventional garbage collectors, VGC employs a dual layer architecture consisting of Active VGC and Passive VGC to enable efficient, low overhead memory management. Active VGC dynamically manages runtime objects using a concurrent mark and sweep strategy tailored for parallel workloads, reducing pause times by up to 30 percent compared to generational collectors in multithreaded benchmarks. Passive VGC operates at compile time and optimizes static object allocation through predictive memory mapping, minimizing fragmentation by aligning objects to cache boundaries. This separation of responsibilities ensures predictable memory access patterns, reduces total memory usage by up to 25 percent, and improves scalability for modern parallel applications. By integrating compile time and runtime optimizations, VGC provides a robust and adaptable solution for memory intensive systems across both low level and high level programming environments.

</details>


### [4] [State Space Estimation for DPOR-based Model Checkers](https://arxiv.org/abs/2512.23996)
*A. R. Balasubramanian,Mohammad Hossein Khoshechin Jorshari,Rupak Majumdar,Umang Mathur,Minjian Zhang*

Main category: cs.PL

TL;DR: 提出首个可证明的多项式时间无偏估计器，用于计算并发程序的Mazurkiewicz迹等价类数量，解决模型检查中资源分配的关键问题。


<details>
  <summary>Details</summary>
Motivation: 在基于枚举的模型检查中，需要估计并发程序的迹等价类数量，以预测模型检查的运行时间和评估搜索空间覆盖程度。现有方法面临#P-hard计算复杂度和近似困难。

Method: 1) 证明计数问题是#P-hard且难以近似；2) 将无状态最优DPOR算法转换为无偏估计器，将其探索视为有界深度和宽度的树；3) 应用Knuth经典估计器；4) 使用随机枚举控制方差，维护每层部分路径的小种群。

Result: 在JMC模型检查器中实现，在共享内存基准测试中，即使状态空间有10^5-10^6个类，通过几百次试验即可获得稳定估计（通常在20%误差范围内）。

Conclusion: 首次提供了可证明的多项式时间无偏估计器，用于计数迹等价类，解决了模型检查资源分配中的重要问题，并展示了如何扩展相同机制来估计模型检查成本。

Abstract: We study the estimation problem for concurrent programs: given a bounded program $P$, estimate the number of Mazurkiewicz trace-equivalence classes induced by its interleavings. This quantity informs two practical questions for enumeration-based model checking: how long a model checking run is likely to take, and what fraction of the search space has been covered so far. We first show the counting problem is #P-hard even for restricted programs and, unless $P=NP$, inapproximable within any subexponential factor, ruling out efficient exact or randomized approximation algorithms. We give a Monte Carlo approach to obtain a poly-time unbiased estimator: we convert a stateless optimal DPOR algorithm into an unbiased estimator by viewing its exploration as a bounded-depth, bounded-width tree whose leaves are the maximal Mazurkiewicz traces. A classical estimator by Knuth, when run on this tree, yields an unbiased estimate. To control the variance, we apply stochastic enumeration by maintaining a small population of partial paths per depth whose evolution is coupled. We have implemented our estimator in the JMC model checker and evaluated it on shared-memory benchmarks. With modest budgets, our estimator yields stable estimates, typically within a 20% band, within a few hundred trials, even when the state space has $10^5$--$10^6$ classes. We also show how the same machinery estimates model-checking cost by weighting all explored graphs, not only complete traces. Our algorithms provide the first provable poly-time unbiased estimators for counting traces, a problem of considerable importance when allocating model checking resources.

</details>
