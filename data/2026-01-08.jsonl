{"id": "2601.03708", "pdf": "https://arxiv.org/pdf/2601.03708", "abs": "https://arxiv.org/abs/2601.03708", "authors": ["Qingyun Zou", "Jiahao Cui", "Nuo Chen", "Bingsheng He", "Weng-Fai Wong"], "title": "MHRC-Bench: A Multilingual Hardware Repository-Level Code Completion benchmark", "categories": ["cs.PL", "cs.AI"], "comment": null, "summary": "Large language models (LLMs) have achieved strong performance on code completion tasks in general-purpose programming languages. However, existing repository-level code completion benchmarks focus almost exclusively on software code and largely overlook hardware description languages. In this work, we present \\textbf{MHRC-Bench}, consisting of \\textbf{MHRC-Bench-Train} and \\textbf{MHRC-Bench-Eval}, the first benchmark designed for multilingual hardware code completion at the repository level. Our benchmark targets completion tasks and covers three major hardware design coding styles. Each completion target is annotated with code-structure-level and hardware-oriented semantic labels derived from concrete syntax tree analysis. We conduct a comprehensive evaluation of models on MHRC-Bench-Eval. Comprehensive evaluation results and analysis demonstrate the effectiveness of MHRC-Bench."}
{"id": "2601.03768", "pdf": "https://arxiv.org/pdf/2601.03768", "abs": "https://arxiv.org/abs/2601.03768", "authors": ["Yichen Xu", "Martin Odersky"], "title": "Agentic Proof Automation: A Case Study", "categories": ["cs.PL"], "comment": null, "summary": "Proof engineering is notoriously labor-intensive: proofs that are straightforward on paper often require lengthy scripts in theorem provers. Recent advances in large language models (LLMs) create new opportunities for proof automation: modern LLMs not only generate proof scripts, but also support agentic behavior, exploring codebases and iteratively refining their outputs against prover feedback. These advances enable an emerging scheme where LLM-based agents undertake most proof engineering under human guidance. Humans provide mathematical insight (definitions, theorems, proof strategies); agents handle the mechanical work of proof development. We call this scheme agentic proof automation. We present this scheme through a case study: mechanizing the semantic type soundness of a sophisticated formal system, System Capless, in Lean 4, comprising over 14,000 lines of code. Using off-the-shelf LLM agents with a single lightweight proof-checking tool, the agents completed 189 proof engineering tasks with an 87% success rate, only 16% requiring human intervention. The case study demonstrates that agents are capable proof engineers that substantially boost productivity, though they fall short in creative reasoning and still require human guidance in certain cases. We release an interactive explorer where readers can examine all agent interactions; the mechanization is open-sourced for experiments and extensions."}
{"id": "2601.03836", "pdf": "https://arxiv.org/pdf/2601.03836", "abs": "https://arxiv.org/abs/2601.03836", "authors": ["Ivan Perez", "Angel Herranz"], "title": "Logic Programming with Extensible Types", "categories": ["cs.PL", "cs.LO"], "comment": "In Proceedings ICLP 2025, arXiv:2601.00047", "summary": "Logic programming languages present clear advantages in terms of declarativeness and conciseness. However, the ideas of logic programming have been met with resistance in other programming communities, and have not generally been adopted by other paradigms and languages. This paper proposes a novel way to incorporate logic programming in an existing codebase in a typed functional programming language. Our approach integrates with the host language without sacrificing static typing, and leverages strengths of typed functional programming such as polymorphism and higher-order. We do so by combining three ideas. First, we use the extensible types technique to allow values of the host language to contain logic variables. Second, we implement a unification algorithm that works for any data structure that supports certain operations.Third, we introduce a domain-specific language to define and query predicates. We demonstrate our proposal via a series of examples, and provide aids to make the notation convenient for users, showing that the proposed approach is not just technically possible but also practical. Our ideas have been implemented in the language Haskell with very good results."}
{"id": "2601.03854", "pdf": "https://arxiv.org/pdf/2601.03854", "abs": "https://arxiv.org/abs/2601.03854", "authors": ["Ziyi Yang", "George Pîrlea", "Ilya Sergey"], "title": "Inductive First-Order Formula Synthesis by ASP: A Case Study in Invariant Inference", "categories": ["cs.PL", "cs.LO"], "comment": "In Proceedings ICLP 2025, arXiv:2601.00047", "summary": "We present a framework for synthesising formulas in first-order logic (FOL) from examples, which unifies and advances state-of-the-art approaches for inference of transition system invariants. To do so, we study and categorise the existing methodologies, encoding techniques in their formula synthesis via answer set programming (ASP). Based on the derived categorisation, we propose orthogonal slices, a new technique for formula enumeration that partitions the search space into manageable chunks, enabling two approaches for incremental candidate pruning. Using a combination of existing techniques for first-order (FO) invariant synthesis and the orthogonal slices implemented in our framework FORCE, we significantly accelerate a state-of-the-art algorithm for distributed system invariant inference. We also show that our approach facilitates composition of different invariant inference frameworks, allowing for novel optimisations."}
{"id": "2601.03897", "pdf": "https://arxiv.org/pdf/2601.03897", "abs": "https://arxiv.org/abs/2601.03897", "authors": ["Ziad Ismaili Alaoui", "Detlef Plump"], "title": "Implementing Binary Search Trees in GP 2 (Extended Abstract)", "categories": ["cs.PL", "cs.DS"], "comment": "In Proceedings GCM 2025, arXiv:2601.03249", "summary": "We present an approach to implement binary search trees in the rule-based graph programming language GP 2. Our implementation uses GP 2's rooted graph transformation rules to be fast and supports insertion, deletion and query operations. We argue that the worst-case runtime for each of the operations is O(n) for a tree with n nodes. In addition, we expect that, on average, the operations run in time O(log(n)). Hence the implementation would match the time complexity of binary search trees implementations in imperative languages."}
{"id": "2601.04085", "pdf": "https://arxiv.org/pdf/2601.04085", "abs": "https://arxiv.org/abs/2601.04085", "authors": ["Jingwen Xu", "Yiyang Lu", "Changze Lv", "Zisu Huang", "Zhengkang Guo", "Zhengyuan Wang", "Muzhao Tian", "Xuanjing Huang", "Xiaoqing Zheng"], "title": "CSSG: Measuring Code Similarity with Semantic Graphs", "categories": ["cs.PL", "cs.AI"], "comment": null, "summary": "Existing code similarity metrics, such as BLEU, CodeBLEU, and TSED, largely rely on surface-level string overlap or abstract syntax tree structures, and often fail to capture deeper semantic relationships between programs.We propose CSSG (Code Similarity using Semantic Graphs), a novel metric that leverages program dependence graphs to explicitly model control dependencies and variable interactions, providing a semantics-aware representation of code.Experiments on the CodeContests+ dataset show that CSSG consistently outperforms existing metrics in distinguishing more similar code from less similar code under both monolingual and cross-lingual settings, demonstrating that dependency-aware graph representations offer a more effective alternative to surface-level or syntax-based similarity measures."}
{"id": "2601.03848", "pdf": "https://arxiv.org/pdf/2601.03848", "abs": "https://arxiv.org/abs/2601.03848", "authors": ["Jens Otten", "Torsten Schaub"], "title": "Implementing the First-Order Logic of Here and There", "categories": ["cs.LO", "cs.AI", "cs.PL"], "comment": "In Proceedings ICLP 2025, arXiv:2601.00047", "summary": "We present automated theorem provers for the first-order logic of here and there (HT). They are based on a native sequent calculus for the logic of HT and an axiomatic embedding of the logic of HT into intuitionistic logic. The analytic proof search in the sequent calculus is optimized by using free variables and skolemization. The embedding is used in combination with sequent, tableau and connection calculi for intuitionistic first-order logic. All provers are evaluated on a large benchmark set of first-order formulas, providing a foundation for the development of more efficient HT provers."}
{"id": "2601.03849", "pdf": "https://arxiv.org/pdf/2601.03849", "abs": "https://arxiv.org/abs/2601.03849", "authors": ["Fred Mesnard", "Thierry Marianne", "Étienne Payet"], "title": "Automated Theorem Proving for Prolog Verification", "categories": ["cs.LO", "cs.PL"], "comment": "In Proceedings ICLP 2025, arXiv:2601.00047", "summary": "LPTP (Logic Program Theorem Prover) is an interactive natural-deduction-based theorem  prover for pure Prolog programs with negation as failure, unification with the occurs check, and a restricted but extensible set of built-in predicates. With LPTP, one can formally prove termination  and partial correctness of such Prolog programs. LPTP was designed in the mid-1990's by Robert F. Staerk.  It is written in ISO-Prolog and comes with an Emacs user-interface. \n  From a theoretical point of view, in his publications about LPTP, Staerk associates a set of first-order axioms IND(P) to the considered Prolog program P.  IND(P) contains the Clark's equality theory for P,  definitions of success, failure and termination for each user-defined logic procedure in P,  axioms relating these three points of view, and an axiom schema for  proving inductive properties. LPTP is thus a dedicated proof editor where these axioms are hard-wired. \n  We propose to translate these axioms as first-order formulas (FOFs), and apply automated theorem provers to  check the property of interest. Using  FOF  as an intermediary language, we experiment the use of automated theorem  provers for Prolog program verification. We evaluate the approach over  a benchmark of about 400 properties of Prolog  programs from the library available with LPTP. Both the  compiler which generates a set of FOF files from a given input  Prolog program together with its properties and the benchmark are publicly available."}
