<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 6]
- [cs.LO](#cs.LO) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [MHRC-Bench: A Multilingual Hardware Repository-Level Code Completion benchmark](https://arxiv.org/abs/2601.03708)
*Qingyun Zou,Jiahao Cui,Nuo Chen,Bingsheng He,Weng-Fai Wong*

Main category: cs.PL

TL;DR: MHRC-Bench是首个针对硬件描述语言的多语言仓库级代码补全基准，包含训练和评估两部分，覆盖三种主要硬件设计编码风格，并提供代码结构和硬件语义标注。


<details>
  <summary>Details</summary>
Motivation: 现有仓库级代码补全基准主要关注软件代码，忽视了硬件描述语言。需要专门针对硬件代码的基准来评估LLM在硬件设计领域的补全能力。

Method: 创建MHRC-Bench基准，包含MHRC-Bench-Train和MHRC-Bench-Eval两部分。基准针对三种主要硬件设计编码风格，通过具体语法树分析为每个补全目标标注代码结构级和硬件导向的语义标签。

Result: 在MHRC-Bench-Eval上对模型进行了全面评估，结果和分析证明了MHRC-Bench的有效性。

Conclusion: MHRC-Bench填补了硬件描述语言仓库级代码补全基准的空白，为评估和改进LLM在硬件设计领域的代码补全能力提供了重要工具。

Abstract: Large language models (LLMs) have achieved strong performance on code completion tasks in general-purpose programming languages. However, existing repository-level code completion benchmarks focus almost exclusively on software code and largely overlook hardware description languages. In this work, we present \textbf{MHRC-Bench}, consisting of \textbf{MHRC-Bench-Train} and \textbf{MHRC-Bench-Eval}, the first benchmark designed for multilingual hardware code completion at the repository level. Our benchmark targets completion tasks and covers three major hardware design coding styles. Each completion target is annotated with code-structure-level and hardware-oriented semantic labels derived from concrete syntax tree analysis. We conduct a comprehensive evaluation of models on MHRC-Bench-Eval. Comprehensive evaluation results and analysis demonstrate the effectiveness of MHRC-Bench.

</details>


### [2] [Agentic Proof Automation: A Case Study](https://arxiv.org/abs/2601.03768)
*Yichen Xu,Martin Odersky*

Main category: cs.PL

TL;DR: 本文提出"代理式证明自动化"方案，利用大语言模型代理在人类指导下完成证明工程任务，通过System Capless在Lean 4中的形式化案例研究，展示了87%的成功率和显著的生产力提升。


<details>
  <summary>Details</summary>
Motivation: 传统证明工程劳动密集，纸上简单的证明在定理证明器中需要冗长脚本。大语言模型的发展为证明自动化提供了新机会，能够生成证明脚本并支持代理行为，探索代码库并根据证明器反馈迭代优化输出。

Method: 提出"代理式证明自动化"方案：人类提供数学洞察（定义、定理、证明策略），LLM代理处理证明开发的机械工作。使用现成的LLM代理配合轻量级证明检查工具，在Lean 4中形式化System Capless系统，完成189个证明工程任务。

Result: 代理完成了189个证明工程任务，成功率达87%，仅16%需要人工干预。案例研究表明代理能够显著提升生产力，但在创造性推理方面仍有不足，某些情况下仍需人类指导。

Conclusion: 代理式证明自动化是可行的方案，代理能够胜任证明工程工作并大幅提高生产力，但在创造性推理方面仍有局限，需要人类指导。研究发布了交互式探索器和开源的形式化代码供实验和扩展。

Abstract: Proof engineering is notoriously labor-intensive: proofs that are straightforward on paper often require lengthy scripts in theorem provers. Recent advances in large language models (LLMs) create new opportunities for proof automation: modern LLMs not only generate proof scripts, but also support agentic behavior, exploring codebases and iteratively refining their outputs against prover feedback. These advances enable an emerging scheme where LLM-based agents undertake most proof engineering under human guidance. Humans provide mathematical insight (definitions, theorems, proof strategies); agents handle the mechanical work of proof development. We call this scheme agentic proof automation. We present this scheme through a case study: mechanizing the semantic type soundness of a sophisticated formal system, System Capless, in Lean 4, comprising over 14,000 lines of code. Using off-the-shelf LLM agents with a single lightweight proof-checking tool, the agents completed 189 proof engineering tasks with an 87% success rate, only 16% requiring human intervention. The case study demonstrates that agents are capable proof engineers that substantially boost productivity, though they fall short in creative reasoning and still require human guidance in certain cases. We release an interactive explorer where readers can examine all agent interactions; the mechanization is open-sourced for experiments and extensions.

</details>


### [3] [Logic Programming with Extensible Types](https://arxiv.org/abs/2601.03836)
*Ivan Perez,Angel Herranz*

Main category: cs.PL

TL;DR: 该论文提出了一种在类型化函数式编程语言中集成逻辑编程的新方法，通过扩展类型、通用统一算法和领域特定语言实现，已在Haskell中成功实现。


<details>
  <summary>Details</summary>
Motivation: 逻辑编程语言在声明性和简洁性方面具有优势，但其思想在其他编程社区中遇到阻力，尚未被其他范式和语言广泛采用。作者希望找到一种方法将逻辑编程集成到现有类型化函数式编程代码库中。

Method: 结合三个核心思想：1) 使用可扩展类型技术，允许宿主语言的值包含逻辑变量；2) 实现适用于任何支持特定操作的数据结构的统一算法；3) 引入领域特定语言来定义和查询谓词。

Result: 通过一系列示例展示了该方法的可行性，提供了使符号表示对用户更方便的辅助工具，证明该方法不仅在技术上可行，而且实用。已在Haskell语言中实现并取得良好效果。

Conclusion: 提出了一种新颖的方法，可以在不牺牲静态类型的情况下将逻辑编程集成到类型化函数式编程语言中，充分利用多态性和高阶函数等优势，实现了技术可行性和实用性的平衡。

Abstract: Logic programming languages present clear advantages in terms of declarativeness and conciseness. However, the ideas of logic programming have been met with resistance in other programming communities, and have not generally been adopted by other paradigms and languages. This paper proposes a novel way to incorporate logic programming in an existing codebase in a typed functional programming language. Our approach integrates with the host language without sacrificing static typing, and leverages strengths of typed functional programming such as polymorphism and higher-order. We do so by combining three ideas. First, we use the extensible types technique to allow values of the host language to contain logic variables. Second, we implement a unification algorithm that works for any data structure that supports certain operations.Third, we introduce a domain-specific language to define and query predicates. We demonstrate our proposal via a series of examples, and provide aids to make the notation convenient for users, showing that the proposed approach is not just technically possible but also practical. Our ideas have been implemented in the language Haskell with very good results.

</details>


### [4] [Inductive First-Order Formula Synthesis by ASP: A Case Study in Invariant Inference](https://arxiv.org/abs/2601.03854)
*Ziyi Yang,George Pîrlea,Ilya Sergey*

Main category: cs.PL

TL;DR: 提出一个基于一阶逻辑公式合成的框架FORCE，通过正交切片技术加速分布式系统不变式推理


<details>
  <summary>Details</summary>
Motivation: 统一和推进现有的过渡系统不变式推理方法，解决一阶逻辑公式合成中的搜索空间管理问题

Method: 1) 研究和分类现有方法，通过ASP编码公式合成；2) 提出正交切片技术，将搜索空间划分为可管理的块；3) 实现增量候选剪枝；4) 在FORCE框架中结合现有FO不变式合成技术

Result: 显著加速了最先进的分布式系统不变式推理算法，并促进了不同不变式推理框架的组合，实现了新的优化

Conclusion: 提出的FORCE框架通过正交切片技术有效管理搜索空间，加速了不变式推理，并为框架组合提供了新途径

Abstract: We present a framework for synthesising formulas in first-order logic (FOL) from examples, which unifies and advances state-of-the-art approaches for inference of transition system invariants. To do so, we study and categorise the existing methodologies, encoding techniques in their formula synthesis via answer set programming (ASP). Based on the derived categorisation, we propose orthogonal slices, a new technique for formula enumeration that partitions the search space into manageable chunks, enabling two approaches for incremental candidate pruning. Using a combination of existing techniques for first-order (FO) invariant synthesis and the orthogonal slices implemented in our framework FORCE, we significantly accelerate a state-of-the-art algorithm for distributed system invariant inference. We also show that our approach facilitates composition of different invariant inference frameworks, allowing for novel optimisations.

</details>


### [5] [Implementing Binary Search Trees in GP 2 (Extended Abstract)](https://arxiv.org/abs/2601.03897)
*Ziad Ismaili Alaoui,Detlef Plump*

Main category: cs.PL

TL;DR: 在GP 2图编程语言中实现二叉搜索树，支持插入、删除和查询操作，最坏情况时间复杂度O(n)，平均期望时间复杂度O(log n)


<details>
  <summary>Details</summary>
Motivation: 探索在规则基础的图编程语言GP 2中实现经典数据结构，验证图变换规则能否达到与命令式语言相似的时间复杂度

Method: 使用GP 2的有根图变换规则实现二叉搜索树，通过图模式匹配和重写规则来执行插入、删除和查询操作

Result: 成功在GP 2中实现了二叉搜索树，最坏情况时间复杂度为O(n)，平均期望时间复杂度为O(log n)，与命令式语言实现的时间复杂度相匹配

Conclusion: 图编程语言GP 2能够有效实现经典数据结构，其图变换规则可以达到与命令式语言相似的时间复杂度，证明了GP 2在算法实现方面的实用性

Abstract: We present an approach to implement binary search trees in the rule-based graph programming language GP 2. Our implementation uses GP 2's rooted graph transformation rules to be fast and supports insertion, deletion and query operations. We argue that the worst-case runtime for each of the operations is O(n) for a tree with n nodes. In addition, we expect that, on average, the operations run in time O(log(n)). Hence the implementation would match the time complexity of binary search trees implementations in imperative languages.

</details>


### [6] [CSSG: Measuring Code Similarity with Semantic Graphs](https://arxiv.org/abs/2601.04085)
*Jingwen Xu,Yiyang Lu,Changze Lv,Zisu Huang,Zhengkang Guo,Zhengyuan Wang,Muzhao Tian,Xuanjing Huang,Xiaoqing Zheng*

Main category: cs.PL

TL;DR: 提出CSSG代码相似度度量方法，使用程序依赖图建模控制依赖和变量交互，相比传统基于字符串重叠或语法树的度量能更好捕捉代码深层语义关系。


<details>
  <summary>Details</summary>
Motivation: 现有代码相似度度量（如BLEU、CodeBLEU、TSED）主要依赖表层字符串重叠或抽象语法树结构，往往无法捕捉程序间的深层语义关系。

Method: 提出CSSG（基于语义图的代码相似度）度量方法，利用程序依赖图显式建模控制依赖和变量交互，提供语义感知的代码表示。

Result: 在CodeContests+数据集上的实验表明，CSSG在单语言和跨语言设置下均优于现有度量方法，能更好地区分相似度高低不同的代码。

Conclusion: 依赖感知的图表示相比表层或基于语法的相似度度量提供了更有效的替代方案，能更好地捕捉代码的语义相似性。

Abstract: Existing code similarity metrics, such as BLEU, CodeBLEU, and TSED, largely rely on surface-level string overlap or abstract syntax tree structures, and often fail to capture deeper semantic relationships between programs.We propose CSSG (Code Similarity using Semantic Graphs), a novel metric that leverages program dependence graphs to explicitly model control dependencies and variable interactions, providing a semantics-aware representation of code.Experiments on the CodeContests+ dataset show that CSSG consistently outperforms existing metrics in distinguishing more similar code from less similar code under both monolingual and cross-lingual settings, demonstrating that dependency-aware graph representations offer a more effective alternative to surface-level or syntax-based similarity measures.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [7] [Implementing the First-Order Logic of Here and There](https://arxiv.org/abs/2601.03848)
*Jens Otten,Torsten Schaub*

Main category: cs.LO

TL;DR: 开发了基于原生序列演算和直觉逻辑嵌入的HT一阶逻辑自动定理证明器，通过自由变量和Skolem化优化，并在大规模基准集上评估


<details>
  <summary>Details</summary>
Motivation: 为HT逻辑（here and there logic）开发高效的自动定理证明器，为更高效的HT证明器开发奠定基础

Method: 1. 基于HT逻辑的原生序列演算；2. 将HT逻辑嵌入到直觉逻辑的axiomatic embedding；3. 使用自由变量和Skolem化优化分析证明搜索；4. 结合直觉逻辑的序列、表格和连接演算

Result: 开发了多个HT逻辑自动定理证明器，并在大规模一阶公式基准集上进行了评估

Conclusion: 为HT逻辑自动定理证明提供了有效方法，为开发更高效的HT证明器奠定了基础

Abstract: We present automated theorem provers for the first-order logic of here and there (HT). They are based on a native sequent calculus for the logic of HT and an axiomatic embedding of the logic of HT into intuitionistic logic. The analytic proof search in the sequent calculus is optimized by using free variables and skolemization. The embedding is used in combination with sequent, tableau and connection calculi for intuitionistic first-order logic. All provers are evaluated on a large benchmark set of first-order formulas, providing a foundation for the development of more efficient HT provers.

</details>


### [8] [Automated Theorem Proving for Prolog Verification](https://arxiv.org/abs/2601.03849)
*Fred Mesnard,Thierry Marianne,Étienne Payet*

Main category: cs.LO

TL;DR: LPTP是一个用于Prolog程序验证的交互式定理证明器，本文提出将其公理转化为一阶公式，使用自动定理证明器进行验证，并在约400个属性上进行了评估。


<details>
  <summary>Details</summary>
Motivation: LPTP虽然能验证Prolog程序的终止性和部分正确性，但它是交互式的，需要人工参与。本文希望通过将LPTP的公理转化为一阶公式，利用自动定理证明器实现完全自动化的Prolog程序验证。

Method: 将LPTP的公理IND(P)（包含Clark等式理论、成功/失败/终止定义、关系公理和归纳公理模式）翻译为一阶公式，然后应用自动定理证明器来验证目标属性。开发了编译器从Prolog程序及其属性生成FOF文件。

Result: 在LPTP库中的约400个Prolog程序属性上进行了评估，验证了该方法的可行性。编译器和基准测试集已公开可用。

Conclusion: 通过将LPTP公理转化为一阶公式，可以有效地利用自动定理证明器进行Prolog程序验证，实现了从交互式到自动化的转变，为Prolog程序验证提供了新的实用工具。

Abstract: LPTP (Logic Program Theorem Prover) is an interactive natural-deduction-based theorem  prover for pure Prolog programs with negation as failure, unification with the occurs check, and a restricted but extensible set of built-in predicates. With LPTP, one can formally prove termination  and partial correctness of such Prolog programs. LPTP was designed in the mid-1990's by Robert F. Staerk.  It is written in ISO-Prolog and comes with an Emacs user-interface. 
  From a theoretical point of view, in his publications about LPTP, Staerk associates a set of first-order axioms IND(P) to the considered Prolog program P.  IND(P) contains the Clark's equality theory for P,  definitions of success, failure and termination for each user-defined logic procedure in P,  axioms relating these three points of view, and an axiom schema for  proving inductive properties. LPTP is thus a dedicated proof editor where these axioms are hard-wired. 
  We propose to translate these axioms as first-order formulas (FOFs), and apply automated theorem provers to  check the property of interest. Using  FOF  as an intermediary language, we experiment the use of automated theorem  provers for Prolog program verification. We evaluate the approach over  a benchmark of about 400 properties of Prolog  programs from the library available with LPTP. Both the  compiler which generates a set of FOF files from a given input  Prolog program together with its properties and the benchmark are publicly available.

</details>
