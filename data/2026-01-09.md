<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]
- [cs.DC](#cs.DC) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Scalable Floating-Point Satisfiability via Staged Optimization](https://arxiv.org/abs/2601.04492)
*Yuanzhuo Zhang,Zhoulai Fu,Binoy Ravindran*

Main category: cs.PL

TL;DR: StageSAT：一种新的浮点可满足性求解方法，通过三阶段优化将SMT求解与数值优化结合，无需位级推理，在精度和速度上超越现有方法。


<details>
  <summary>Details</summary>
Motivation: 现有浮点可满足性求解方法存在局限性：传统SMT求解器需要复杂的位级推理，而数值优化方法在精度和可靠性方面不足。需要一种既能处理复杂算术运算，又能保证正确性的高效方法。

Method: 采用三阶段优化策略：1）快速投影辅助下降引导搜索到可行区域；2）位级精度的ULP²优化；3）n-ULP格点细化。通过正交投影引入部分单调下降特性，将复杂算术视为黑盒，仅使用运行时评估。

Result: 在SMT-COMP'25基准测试中，StageSAT比现有优化方法更具可扩展性和准确性，在相同时间预算下解决了更多公式，对可满足实例的召回率达到99.4%，误报率为0%，比传统位精确SMT和数值求解器快5-10倍。

Conclusion: 分阶段优化显著提高了浮点可满足性求解的性能和正确性，证明了将SMT求解与数值优化结合的有效性，为处理复杂浮点约束提供了可靠且高效的解决方案。

Abstract: This work introduces StageSAT, a new approach to solving floating-point satisfiability that bridges SMT solving with numerical optimization. StageSAT reframes a floating-point formula as a series of optimization problems in three stages of increasing precision. It begins with a fast, projection-aided descent objective to guide the search toward a feasible region, proceeding to bit-level accuracy with ULP$^2$ optimization and a final $n$-ULP lattice refinement.
  By construction, the final stage uses a representing function that is zero if and only if a candidate satisfies all constraints. Thus, when optimization drives the objective to zero, the resulting assignment is a valid solution, providing a built-in guarantee of soundness.
  To improve search, StageSAT introduces a partial monotone descent property on linear constraints via orthogonal projection, preventing the optimizer from stalling on flat or misleading landscapes. Critically, this solver requires no heavy bit-level reasoning or specialized abstractions; it treats complex arithmetic as a black-box, using runtime evaluations to navigate the input space.
  We implement StageSAT and evaluate it on extensive benchmarks, including SMT-COMP'25 suites and difficult cases from prior work. StageSAT proved more scalable and accurate than state-of-the-art optimization-based alternatives. It solved strictly more formulas than any competing solver under the same time budget, finding most satisfiable instances without producing spurious models. This amounts to 99.4% recall on satisfiable cases with 0% false SAT, exceeding the reliability of prior optimization-based solvers. StageSAT also delivered significant speedups (often 5--10$\times$) over traditional bit-precise SMT and numeric solvers. These results demonstrate that staged optimization significantly improves performance and correctness of floating-point satisfiability solving.

</details>


### [2] [Lenses for Partially-Specified States (Extended Version)](https://arxiv.org/abs/2601.04573)
*Kazutaka Matsuda,Minh Nguyen,Meng Wang*

Main category: cs.PL

TL;DR: 提出了部分状态透镜（partial-state lenses），通过允许源状态和视图状态部分指定来精确表示用户更新意图，支持多视图更新合并，并提供组合推理框架。


<details>
  <summary>Details</summary>
Motivation: 在双向转换中，当多个视图共享同一源数据时，一个视图的更新可能影响其他视图，难以在保持用户更新的同时维持对应关系，特别是在多个视图同时更改时。在组合框架中确保这些属性更具挑战性。

Method: 提出部分状态透镜，允许源状态和视图状态部分指定以精确表示用户更新意图。这些意图是部分有序的，为合并来自多个视图的更新意图提供了清晰的语义，并提供了与这种合并兼容的更新保持的细化概念。

Result: 形式化了部分状态透镜，以及支持组合推理并确保更新保持的部分指定感知的良好行为属性。通过示例展示了所提出系统的实用性。

Conclusion: 部分状态透镜为解决多视图双向转换中的更新合并问题提供了形式化框架，支持组合推理并确保更新意图的精确表示和保持。

Abstract: A bidirectional transformation is a pair of transformations satisfying certain well-behavedness properties: one maps source data into view data, and the other translates changes on the view back to the source. However, when multiple views share a source, an update on one view may affect the others, making it hard to maintain correspondence while preserving the user's update, especially when multiple views are changed at once. Ensuring these properties within a compositional framework is even more challenging. In this paper, we propose partial-state lenses, which allow source and view states to be partially specified to precisely represent the user's update intentions. These intentions are partially ordered, providing clear semantics for merging intentions of updates coming from multiple views and a refined notion of update preservation compatible with this merging. We formalize partial-state lenses, together with partial-specifiedness-aware well-behavedness that supports compositional reasoning and ensures update preservation. In addition, we demonstrate the utility of the proposed system through examples.

</details>


### [3] [The Squirrel Parser: A Linear-Time PEG Packrat Parser Capable of Left Recursion and Optimal Error Recovery](https://arxiv.org/abs/2601.05012)
*Luke A. D. Hutchison*

Main category: cs.PL

TL;DR: Squirrel Parser：一种能直接处理所有形式左递归、具有最优错误恢复能力且保持线性时间复杂度的PEG packrat解析器


<details>
  <summary>Details</summary>
Motivation: 传统递归下降解析器处理左递归需要语法重写或复杂算法扩展，缺乏同时支持左递归和最优错误恢复的高效解析器

Method: 基于第一原理推导最小算法：通过每位置状态跟踪进行循环检测，使用O(1)每左递归循环通信从后代到祖先递归帧，通过迭代扩展进行不动点搜索。错误恢复基于4个公理和12个约束，使用约束满足机制搜索所有可能性空间

Result: 实现了能直接处理所有形式左递归、具有最优错误恢复能力、即使在任意数量错误情况下也能保持输入长度线性时间复杂度的解析器

Conclusion: Squirrel Parser通过理论推导和约束满足方法，实现了同时支持左递归和最优错误恢复的高效解析器，具有理论保证的性能最优性和鲁棒性

Abstract: We present the squirrel parser, a PEG packrat parser that directly handles all forms of left recursion with optimal error recovery, while maintaining linear time complexity in the length of the input even in the presence of an arbitrary number of errors. Traditional approaches to handling left recursion in a recursive descent parser require grammar rewriting or complex algorithmic extensions. We derive a minimal algorithm from first principles: cycle detection via per-position state tracking and $O(1)$-per-LR-cycle communication from descendant to ancestor recursion frames, and fixed-point search via iterative expansion. For error recovery, we derived a set of four axioms and twelve constraints that must be imposed upon an optimal error recovery design to ensure completeness, correctness, optimality of performance, and intuitiveness of behavior. We utilized a constraint satisfaction mechanism to search the space of all possibilities, arriving at a provably optimal and robust error recovery strategy that maintains perfect performance linearity.

</details>


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [4] [Sharded Elimination and Combining for Highly-Efficient Concurrent Stacks](https://arxiv.org/abs/2601.04523)
*Ajay Singh,Nikos Metaxakis,Panagiota Fatourou*

Main category: cs.DC

TL;DR: 提出一种基于分片和fetch&increment的阻塞线性化栈实现，性能比现有并发栈提升高达2倍


<details>
  <summary>Details</summary>
Motivation: 现有并发栈在高并发场景下性能不足，需要设计新的实现来减少竞争、提高并行性

Method: 结合分片技术、fetch&increment操作、新颖的消除机制和组合方法，有效混合这些技术以获得高性能

Result: 在大多数工作负载下性能比现有并发栈提升高达2倍，特别在多线程系统和高竞争场景中表现优异

Conclusion: 提出的阻塞线性化栈实现通过创新的消除和组合机制，显著提升了并发栈的性能和可扩展性

Abstract: We present a new blocking linearizable stack implementation which utilizes sharding and fetch&increment to achieve significantly better performance than all existing concurrent stacks. The proposed implementation is based on a novel elimination mechanism and a new combining approach that are efficiently blended to gain high performance. Our implementation results in enhanced parallelism and low contention when accessing the shared stack. Experiments show that the proposed stack implementation outperforms all existing concurrent stacks by up to 2X in most workloads. It is particularly efficient in systems supporting a large number of threads and in high contention scenarios.

</details>
