<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]
- [cs.DC](#cs.DC) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Scalable Floating-Point Satisfiability via Staged Optimization](https://arxiv.org/abs/2601.04492)
*Yuanzhuo Zhang,Zhoulai Fu,Binoy Ravindran*

Main category: cs.PL

TL;DR: StageSAT：一种将SMT求解与数值优化结合的三阶段浮点可满足性求解方法，通过渐进精度优化实现高效求解


<details>
  <summary>Details</summary>
Motivation: 现有浮点可满足性求解方法存在性能瓶颈，传统SMT求解器需要复杂的比特级推理，而数值优化方法又缺乏精度保证。需要一种既能保持精度又能提高效率的新方法。

Method: 采用三阶段渐进精度优化：1）快速投影辅助下降引导搜索到可行区域；2）比特级精度的ULP²优化；3）n-ULP格点细化。通过正交投影引入部分单调下降特性，将复杂算术视为黑盒处理。

Result: 在SMT-COMP'25基准测试中，StageSAT比现有优化方法更可扩展和准确，在相同时间预算下解决了更多公式，对可满足实例的召回率达到99.4%且零误报，速度比传统比特精确SMT和数值求解器快5-10倍。

Conclusion: 分阶段优化显著提高了浮点可满足性求解的性能和正确性，证明了将SMT求解与数值优化结合的有效性，为浮点推理提供了新的解决方案。

Abstract: This work introduces StageSAT, a new approach to solving floating-point satisfiability that bridges SMT solving with numerical optimization. StageSAT reframes a floating-point formula as a series of optimization problems in three stages of increasing precision. It begins with a fast, projection-aided descent objective to guide the search toward a feasible region, proceeding to bit-level accuracy with ULP$^2$ optimization and a final $n$-ULP lattice refinement.
  By construction, the final stage uses a representing function that is zero if and only if a candidate satisfies all constraints. Thus, when optimization drives the objective to zero, the resulting assignment is a valid solution, providing a built-in guarantee of soundness.
  To improve search, StageSAT introduces a partial monotone descent property on linear constraints via orthogonal projection, preventing the optimizer from stalling on flat or misleading landscapes. Critically, this solver requires no heavy bit-level reasoning or specialized abstractions; it treats complex arithmetic as a black-box, using runtime evaluations to navigate the input space.
  We implement StageSAT and evaluate it on extensive benchmarks, including SMT-COMP'25 suites and difficult cases from prior work. StageSAT proved more scalable and accurate than state-of-the-art optimization-based alternatives. It solved strictly more formulas than any competing solver under the same time budget, finding most satisfiable instances without producing spurious models. This amounts to 99.4% recall on satisfiable cases with 0% false SAT, exceeding the reliability of prior optimization-based solvers. StageSAT also delivered significant speedups (often 5--10$\times$) over traditional bit-precise SMT and numeric solvers. These results demonstrate that staged optimization significantly improves performance and correctness of floating-point satisfiability solving.

</details>


### [2] [Lenses for Partially-Specified States (Extended Version)](https://arxiv.org/abs/2601.04573)
*Kazutaka Matsuda,Minh Nguyen,Meng Wang*

Main category: cs.PL

TL;DR: 提出部分状态透镜（partial-state lenses）来解决多视图双向变换中的更新冲突问题，通过部分指定状态来精确表示用户更新意图，并提供合并机制和更新保持保证。


<details>
  <summary>Details</summary>
Motivation: 在多视图共享同一源数据的双向变换中，一个视图的更新会影响其他视图，难以同时保持对应关系和用户更新意图，尤其是在多个视图同时更改时。在组合框架中确保这些属性更具挑战性。

Method: 提出部分状态透镜，允许源和视图状态部分指定以精确表示用户更新意图。这些意图具有偏序关系，为合并来自多个视图的更新意图提供了清晰语义，并提供了与此合并兼容的细化更新保持概念。

Result: 形式化了部分状态透镜及其部分指定感知的良好行为属性，支持组合推理并确保更新保持。通过示例展示了所提系统的实用性。

Conclusion: 部分状态透镜为解决多视图双向变换中的更新冲突问题提供了系统化方法，通过精确表示和合并用户意图，在组合框架中实现了可靠的更新保持。

Abstract: A bidirectional transformation is a pair of transformations satisfying certain well-behavedness properties: one maps source data into view data, and the other translates changes on the view back to the source. However, when multiple views share a source, an update on one view may affect the others, making it hard to maintain correspondence while preserving the user's update, especially when multiple views are changed at once. Ensuring these properties within a compositional framework is even more challenging. In this paper, we propose partial-state lenses, which allow source and view states to be partially specified to precisely represent the user's update intentions. These intentions are partially ordered, providing clear semantics for merging intentions of updates coming from multiple views and a refined notion of update preservation compatible with this merging. We formalize partial-state lenses, together with partial-specifiedness-aware well-behavedness that supports compositional reasoning and ensures update preservation. In addition, we demonstrate the utility of the proposed system through examples.

</details>


### [3] [The Squirrel Parser: A Linear-Time PEG Packrat Parser Capable of Left Recursion and Optimal Error Recovery](https://arxiv.org/abs/2601.05012)
*Luke A. D. Hutchison*

Main category: cs.PL

TL;DR: 提出Squirrel解析器：一个PEG packrat解析器，能直接处理所有形式的左递归并具有最优错误恢复能力，同时保持线性时间复杂度。


<details>
  <summary>Details</summary>
Motivation: 传统递归下降解析器处理左递归需要语法重写或复杂算法扩展，现有方法存在局限性，需要更直接、高效的解决方案。

Method: 基于基本原理推导最小算法：通过每位置状态跟踪进行循环检测，后代到祖先递归帧的O(1)通信，以及通过迭代扩展进行固定点搜索。错误恢复方面，提出四个公理和十二个约束，使用约束满足机制搜索所有可能性空间。

Result: 开发出Squirrel解析器，能直接处理所有形式的左递归，具有最优错误恢复能力，即使在任意数量错误存在时也能保持线性时间复杂度。

Conclusion: Squirrel解析器提供了一个理论上最优且鲁棒的解决方案，在保持完美性能线性的同时，解决了左递归处理和错误恢复的关键问题。

Abstract: We present the squirrel parser, a PEG packrat parser that directly handles all forms of left recursion with optimal error recovery, while maintaining linear time complexity in the length of the input even in the presence of an arbitrary number of errors. Traditional approaches to handling left recursion in a recursive descent parser require grammar rewriting or complex algorithmic extensions. We derive a minimal algorithm from first principles: cycle detection via per-position state tracking and $O(1)$-per-LR-cycle communication from descendant to ancestor recursion frames, and fixed-point search via iterative expansion. For error recovery, we derived a set of four axioms and twelve constraints that must be imposed upon an optimal error recovery design to ensure completeness, correctness, optimality of performance, and intuitiveness of behavior. We utilized a constraint satisfaction mechanism to search the space of all possibilities, arriving at a provably optimal and robust error recovery strategy that maintains perfect performance linearity.

</details>


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [4] [Sharded Elimination and Combining for Highly-Efficient Concurrent Stacks](https://arxiv.org/abs/2601.04523)
*Ajay Singh,Nikos Metaxakis,Panagiota Fatourou*

Main category: cs.DC

TL;DR: 提出一种基于分片和fetch&increment的新型阻塞线性化栈实现，性能比现有并发栈提升高达2倍


<details>
  <summary>Details</summary>
Motivation: 现有并发栈在高并发场景下性能不足，需要设计更高效的栈实现来应对多线程和高争用环境

Method: 结合分片技术、fetch&increment操作、新颖的消除机制和组合方法，实现低争用和高并行度的栈访问

Result: 在大多数工作负载下性能比现有并发栈提升高达2倍，特别在大规模线程系统和高争用场景中表现优异

Conclusion: 提出的栈实现通过创新的消除机制和组合方法，显著提升了并发栈的性能，特别适用于高并发环境

Abstract: We present a new blocking linearizable stack implementation which utilizes sharding and fetch&increment to achieve significantly better performance than all existing concurrent stacks. The proposed implementation is based on a novel elimination mechanism and a new combining approach that are efficiently blended to gain high performance. Our implementation results in enhanced parallelism and low contention when accessing the shared stack. Experiments show that the proposed stack implementation outperforms all existing concurrent stacks by up to 2X in most workloads. It is particularly efficient in systems supporting a large number of threads and in high contention scenarios.

</details>
