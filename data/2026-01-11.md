<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]
- [cs.DC](#cs.DC) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Scalable Floating-Point Satisfiability via Staged Optimization](https://arxiv.org/abs/2601.04492)
*Yuanzhuo Zhang,Zhoulai Fu,Binoy Ravindran*

Main category: cs.PL

TL;DR: StageSAT：一种新的浮点可满足性求解方法，通过三阶段优化将SMT求解与数值优化结合，显著提升性能和正确性


<details>
  <summary>Details</summary>
Motivation: 传统浮点SMT求解器需要复杂的位级推理和专门抽象，计算成本高。现有基于优化的方法在精度和可靠性方面存在不足，需要一种既能保证正确性又能高效处理复杂算术的方法。

Method: 1. 将浮点公式重构为三个精度递增的优化问题阶段
2. 第一阶段：快速投影辅助下降目标引导搜索到可行区域
3. 第二阶段：位级精度的ULP²优化
4. 第三阶段：n-ULP格点细化，使用表示函数确保解的正确性
5. 引入线性约束的部分单调下降特性防止优化器停滞
6. 将复杂算术视为黑盒，仅使用运行时评估

Result: 1. 在SMT-COMP'25测试集和先前工作的困难案例上表现优异
2. 比最先进的基于优化的替代方案更具可扩展性和准确性
3. 在相同时间预算下解决了更多公式
4. 可满足案例的召回率达到99.4%，假SAT率为0%
5. 相比传统位精确SMT和数值求解器获得5-10倍加速

Conclusion: 分阶段优化方法显著提升了浮点可满足性求解的性能和正确性，为浮点SMT求解提供了新的有效途径，无需复杂的位级推理即可保证解的正确性。

Abstract: This work introduces StageSAT, a new approach to solving floating-point satisfiability that bridges SMT solving with numerical optimization. StageSAT reframes a floating-point formula as a series of optimization problems in three stages of increasing precision. It begins with a fast, projection-aided descent objective to guide the search toward a feasible region, proceeding to bit-level accuracy with ULP$^2$ optimization and a final $n$-ULP lattice refinement.
  By construction, the final stage uses a representing function that is zero if and only if a candidate satisfies all constraints. Thus, when optimization drives the objective to zero, the resulting assignment is a valid solution, providing a built-in guarantee of soundness.
  To improve search, StageSAT introduces a partial monotone descent property on linear constraints via orthogonal projection, preventing the optimizer from stalling on flat or misleading landscapes. Critically, this solver requires no heavy bit-level reasoning or specialized abstractions; it treats complex arithmetic as a black-box, using runtime evaluations to navigate the input space.
  We implement StageSAT and evaluate it on extensive benchmarks, including SMT-COMP'25 suites and difficult cases from prior work. StageSAT proved more scalable and accurate than state-of-the-art optimization-based alternatives. It solved strictly more formulas than any competing solver under the same time budget, finding most satisfiable instances without producing spurious models. This amounts to 99.4% recall on satisfiable cases with 0% false SAT, exceeding the reliability of prior optimization-based solvers. StageSAT also delivered significant speedups (often 5--10$\times$) over traditional bit-precise SMT and numeric solvers. These results demonstrate that staged optimization significantly improves performance and correctness of floating-point satisfiability solving.

</details>


### [2] [Lenses for Partially-Specified States (Extended Version)](https://arxiv.org/abs/2601.04573)
*Kazutaka Matsuda,Minh Nguyen,Meng Wang*

Main category: cs.PL

TL;DR: 提出部分状态透镜，通过部分指定源状态和视图状态来精确表示用户更新意图，支持多视图更新合并，并提供组合推理的良构性保证。


<details>
  <summary>Details</summary>
Motivation: 双向变换中，当多个视图共享同一源数据时，一个视图的更新会影响其他视图，难以在保持用户更新的同时维持对应关系，特别是在多个视图同时更改时。在组合框架中确保这些属性更具挑战性。

Method: 提出部分状态透镜，允许部分指定源状态和视图状态以精确表示用户更新意图。这些意图采用偏序关系，为合并来自多个视图的更新意图提供清晰语义，并定义与这种合并兼容的更新保持概念。

Result: 形式化了部分状态透镜及其支持组合推理的部分指定感知良构性，确保更新保持。通过示例展示了所提出系统的实用性。

Conclusion: 部分状态透镜为解决多视图双向变换中的更新合并和保持问题提供了有效的形式化框架，支持组合推理并确保更新意图的精确表示和保持。

Abstract: A bidirectional transformation is a pair of transformations satisfying certain well-behavedness properties: one maps source data into view data, and the other translates changes on the view back to the source. However, when multiple views share a source, an update on one view may affect the others, making it hard to maintain correspondence while preserving the user's update, especially when multiple views are changed at once. Ensuring these properties within a compositional framework is even more challenging. In this paper, we propose partial-state lenses, which allow source and view states to be partially specified to precisely represent the user's update intentions. These intentions are partially ordered, providing clear semantics for merging intentions of updates coming from multiple views and a refined notion of update preservation compatible with this merging. We formalize partial-state lenses, together with partial-specifiedness-aware well-behavedness that supports compositional reasoning and ensures update preservation. In addition, we demonstrate the utility of the proposed system through examples.

</details>


### [3] [The Squirrel Parser: A Linear-Time PEG Packrat Parser Capable of Left Recursion and Optimal Error Recovery](https://arxiv.org/abs/2601.05012)
*Luke A. D. Hutchison*

Main category: cs.PL

TL;DR: 提出松鼠解析器，一种PEG packrat解析器，能直接处理所有形式的左递归并具有最优错误恢复能力，同时保持线性时间复杂度。


<details>
  <summary>Details</summary>
Motivation: 传统递归下降解析器处理左递归需要语法重写或复杂算法扩展，缺乏既能处理左递归又能保持线性时间复杂度的直接方法。

Method: 基于第一原理推导最小算法：通过每位置状态跟踪进行循环检测，后代到祖先递归帧的O(1)通信，以及通过迭代扩展进行定点搜索。错误恢复方面，推导了4个公理和12个约束，使用约束满足机制搜索所有可能性空间。

Result: 开发出能直接处理所有形式左递归的解析器，即使在任意数量错误情况下也能保持输入长度的线性时间复杂度，并具有可证明最优且鲁棒的错误恢复策略。

Conclusion: 松鼠解析器在保持线性时间复杂度的同时，实现了对左递归的直接处理和对错误恢复的最优设计，为解析器设计提供了新的理论框架和实践方案。

Abstract: We present the squirrel parser, a PEG packrat parser that directly handles all forms of left recursion with optimal error recovery, while maintaining linear time complexity in the length of the input even in the presence of an arbitrary number of errors. Traditional approaches to handling left recursion in a recursive descent parser require grammar rewriting or complex algorithmic extensions. We derive a minimal algorithm from first principles: cycle detection via per-position state tracking and $O(1)$-per-LR-cycle communication from descendant to ancestor recursion frames, and fixed-point search via iterative expansion. For error recovery, we derived a set of four axioms and twelve constraints that must be imposed upon an optimal error recovery design to ensure completeness, correctness, optimality of performance, and intuitiveness of behavior. We utilized a constraint satisfaction mechanism to search the space of all possibilities, arriving at a provably optimal and robust error recovery strategy that maintains perfect performance linearity.

</details>


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [4] [Sharded Elimination and Combining for Highly-Efficient Concurrent Stacks](https://arxiv.org/abs/2601.04523)
*Ajay Singh,Nikos Metaxakis,Panagiota Fatourou*

Main category: cs.DC

TL;DR: 提出一种基于分片和fetch&increment的新型阻塞线性化栈实现，性能比现有并发栈提升高达2倍


<details>
  <summary>Details</summary>
Motivation: 现有并发栈在高并发场景下性能不足，特别是在多线程系统和高争用情况下需要更好的并行性和更低争用

Method: 采用分片技术结合fetch&increment操作，结合新颖的消除机制和组合方法，有效混合以获得高性能

Result: 实验显示该实现比所有现有并发栈性能提升高达2倍，在多线程系统和高争用场景下特别高效

Conclusion: 提出的栈实现通过创新的消除机制和组合方法，显著提升了并发栈的性能，特别是在高并发环境中

Abstract: We present a new blocking linearizable stack implementation which utilizes sharding and fetch&increment to achieve significantly better performance than all existing concurrent stacks. The proposed implementation is based on a novel elimination mechanism and a new combining approach that are efficiently blended to gain high performance. Our implementation results in enhanced parallelism and low contention when accessing the shared stack. Experiments show that the proposed stack implementation outperforms all existing concurrent stacks by up to 2X in most workloads. It is particularly efficient in systems supporting a large number of threads and in high contention scenarios.

</details>
