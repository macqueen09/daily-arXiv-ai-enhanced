<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.LO](#cs.LO) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Formalization and Implementation of Safe Destination Passing in Pure Functional Programming Settings](https://arxiv.org/abs/2601.08529)
*Thomas Bagrel*

Main category: cs.PL

TL;DR: 该论文提出了一个带有目的地的λ演算系统{λ_d}，通过模态类型系统结合线性类型和年龄系统来安全管理作用域，实现了比现有系统更灵活的目的地传递编程，并在Haskell中实现了原型。


<details>
  <summary>Details</summary>
Motivation: 目的地传递风格编程允许通过传递可写内存单元地址来控制内存管理，在纯函数式编程中能够实现传统不可变数据结构无法表达的程序。然而现有系统在目的地传递的灵活性和安全性方面存在限制。

Method: 1. 开发核心λ演算{λ_d}，采用模态类型系统结合线性类型和年龄系统来管理作用域，确保目的地传递的安全性；2. 在Coq中形式化证明类型安全性；3. 将核心演算适配到Haskell中，通过类型系统限制保持安全性；4. 进一步优化实现以恢复灵活性。

Result: 1. 成功设计了比现有系统更灵活的{λ_d}演算；2. 在Coq中形式化证明了类型安全性；3. 在Haskell中实现了原型系统；4. 在遍历大型数据结构（如列表、数据树）时显示出有前景的性能结果。

Conclusion: 目的地传递风格编程在纯函数式语言中具有实际应用价值，通过精心设计的类型系统可以在保持安全性的同时提供灵活性。虽然Haskell的类型系统限制需要一些折衷，但原型实现证明了该方法的可行性，特别是在处理大型数据结构时具有优势。

Abstract: Destination-passing style programming introduces destinations, which represent the address of a write-once memory cell. These destinations can be passed as function parameters, allowing the caller to control memory management: the callee simply fills the cell instead of allocating space for a return value. While typically used in systems programming, destination passing also has applications in pure functional programming, where it enables programs that were previously unexpressible using usual immutable data structures.
  In this thesis, we develop a core λ-calculus with destinations, {λ_d}. Our new calculus is more expressive than similar existing systems, with destination passing designed to be as flexible as possible. This is achieved through a modal type system combining linear types with a system of ages to manage scopes, in order to make destination-passing safe. Type safety of our core calculus was proved formally with the Coq proof assistant.
  Then, we see how this core calculus can be adapted into an existing pure functional language, Haskell, whose type system is less powerful than our custom theoretical one. Retaining safety comes at the cost of removing some flexibility in the handling of destinations. We later refine the implementation to recover much of this flexibility, at the cost of increased user complexity.
  The prototype implementation in Haskell shows encouraging results for adopting destination-passing style programming when traversing or mapping over large data structures such as lists or data trees.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [2] [S4 modal sequent calculus as intermediate logic and intermediate language](https://arxiv.org/abs/2601.08071)
*Jean Caspar,Guillaume Munch-Maccagnoni*

Main category: cs.LO

TL;DR: 本文提出延续式中间语言对应中间逻辑的观点，CPS中间语言中的二阶延续对应带有模态类型限制的经典模态逻辑S4，这构成中间逻辑，并引入极化序列演算和操作机器模型研究S4模态片段的栈化性质。


<details>
  <summary>Details</summary>
Motivation: 中间语言作为编译器中间表示的基础，需要既能表达丰富的程序变换进行优化和编译，又能保持程序高效编译的特性（如延续的"栈化"性质）。中间逻辑是介于直觉逻辑和经典逻辑之间的逻辑。本文探讨延续式中间语言与中间逻辑之间的对应关系。

Method: 提出CPS中间语言中的二阶延续对应带有模态类型限制的经典模态逻辑S4。引入三类型极化序列演算用于S4，并构建分离堆和栈的操作机器模型。使用该模型研究S4模态片段的栈化性质。

Result: 通过Gödel-McKinsey-Tarski定理（该定理指出S4的模态片段具有直觉性质），证明了CPS中间语言中的二阶延续确实对应中间逻辑。构建的模型能够分离堆和栈，为研究栈化性质提供了理论基础。

Conclusion: 延续式中间语言确实对应中间逻辑，特别是CPS中间语言中的二阶延续对应带有模态类型限制的经典模态逻辑S4。这种对应关系为编译器中间表示的设计提供了逻辑基础，同时保持程序的高效编译特性。

Abstract: In this short paper, we advocate for the idea that continuation-based intermediate languages correspond to intermediate logics. The goal of intermediate languages is to serve as a basis for compiler intermediate representations, allowing to represent expressive program transformations for optimisation and compilation, while preserving the properties that make programs compilable efficiently in the first place, such as the "stackability" of continuations. Intermediate logics are logics between intuitionistic and classical logic in terms of provability. Second-class continuations used in CPS-based intermediate languages correspond to a classical modal logic S4 with the added restriction that implications may only return modal types. This indeed corresponds to an intermediate logic, owing to the Gödel-McKinsey-Tarski theorem which states the intuitionistic nature of the modal fragment of S4. We introduce a three-kinded polarised sequent calculus for S4, together with an operational machine model that separates a heap from a stack. With this model we study a stackability property for the modal fragment of S4.

</details>
