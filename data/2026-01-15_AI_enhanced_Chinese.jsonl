{"id": "2601.09217", "pdf": "https://arxiv.org/pdf/2601.09217", "abs": "https://arxiv.org/abs/2601.09217", "authors": ["Izumi Tanaka", "Ken Sakayori", "Shinya Takamaeda-Yamazaki", "Naoki Kobayashi"], "title": "Relational Hoare Logic for High-Level Synthesis of Hardware Accelerators", "categories": ["cs.PL", "cs.AR"], "comment": "An extended version of the paper to appear in Proceedings of ESOP 2026", "summary": "High-level synthesis (HLS) is a powerful tool for developing efficient hardware accelerators that rely on specialized memory systems to achieve sufficient on-chip data reuse and off-chip bandwidth utilization. However, even with HLS, designing such systems still requires careful manual tuning, as automatic optimizations provided by existing tools are highly sensitive to programming style and often lack transparency. To address these issues, we present a formal translation framework based on relational Hoare logic, which enables robust and transparent transformations. Our method recognizes complex memory access patterns in na\u00efve HLS programs and automatically transforms them by inserting on-chip buffers to enforce linear access to off-chip memory, and by replacing non-sequential processing with stream processing, while preserving program semantics. Experiments using our prototype translator, combined with an off-the-shelf HLS compiler and a real FPGA board, have demonstrated significant performance improvements.", "AI": {"tldr": "\u63d0\u51fa\u57fa\u4e8e\u5173\u7cfb\u970d\u5c14\u903b\u8f91\u7684\u5f62\u5f0f\u5316\u7ffb\u8bd1\u6846\u67b6\uff0c\u81ea\u52a8\u8bc6\u522bHLS\u7a0b\u5e8f\u4e2d\u7684\u590d\u6742\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u901a\u8fc7\u63d2\u5165\u7247\u4e0a\u7f13\u51b2\u548c\u6d41\u5904\u7406\u4f18\u5316\uff0c\u663e\u8457\u63d0\u5347\u6027\u80fd\u3002", "motivation": "\u73b0\u6709HLS\u5de5\u5177\u7684\u5185\u5b58\u7cfb\u7edf\u81ea\u52a8\u4f18\u5316\u5bf9\u7f16\u7a0b\u98ce\u683c\u654f\u611f\u4e14\u7f3a\u4e4f\u900f\u660e\u5ea6\uff0c\u9700\u8981\u5927\u91cf\u624b\u52a8\u8c03\u4f18\uff0c\u8fd9\u963b\u788d\u4e86\u9ad8\u6548\u786c\u4ef6\u52a0\u901f\u5668\u7684\u5f00\u53d1\u3002", "method": "\u57fa\u4e8e\u5173\u7cfb\u970d\u5c14\u903b\u8f91\u7684\u5f62\u5f0f\u5316\u7ffb\u8bd1\u6846\u67b6\uff0c\u81ea\u52a8\u8bc6\u522b\u6734\u7d20HLS\u7a0b\u5e8f\u4e2d\u7684\u590d\u6742\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u901a\u8fc7\u63d2\u5165\u7247\u4e0a\u7f13\u51b2\u5f3a\u5236\u7ebf\u6027\u8bbf\u95ee\u5916\u90e8\u5185\u5b58\uff0c\u5e76\u7528\u6d41\u5904\u7406\u66ff\u6362\u975e\u987a\u5e8f\u5904\u7406\uff0c\u540c\u65f6\u4fdd\u6301\u7a0b\u5e8f\u8bed\u4e49\u3002", "result": "\u539f\u578b\u7ffb\u8bd1\u5668\u7ed3\u5408\u5546\u7528HLS\u7f16\u8bd1\u5668\u548c\u771f\u5b9eFPGA\u677f\u8fdb\u884c\u5b9e\u9a8c\uff0c\u5c55\u793a\u4e86\u663e\u8457\u7684\u6027\u80fd\u63d0\u5347\u3002", "conclusion": "\u63d0\u51fa\u7684\u5f62\u5f0f\u5316\u6846\u67b6\u80fd\u591f\u5b9e\u73b0\u7a33\u5065\u900f\u660e\u7684\u7a0b\u5e8f\u8f6c\u6362\uff0c\u6709\u6548\u89e3\u51b3HLS\u5185\u5b58\u7cfb\u7edf\u8bbe\u8ba1\u4e2d\u7684\u624b\u52a8\u8c03\u4f18\u95ee\u9898\uff0c\u663e\u8457\u63d0\u5347\u786c\u4ef6\u52a0\u901f\u5668\u6027\u80fd\u3002"}}
{"id": "2601.09583", "pdf": "https://arxiv.org/pdf/2601.09583", "abs": "https://arxiv.org/abs/2601.09583", "authors": ["Berke Ates", "Philipp Schaad", "Timo Schneider", "Alexandru Calotoiu", "Torsten Hoefler"], "title": "MLIR-Forge: A Modular Framework for Language Smiths", "categories": ["cs.PL"], "comment": null, "summary": "Optimizing compilers are essential for the efficient and correct execution of software across various scientific fields. Domain-specific languages (DSL) typically use higher level intermediate representations (IR) in their compiler pipelines for domain-specific optimizations. As these IRs add to complexity, it is crucial to test them thoroughly. Random program generators have proven to be an effective tool to test compilers through differential and fuzz testing. However, developing specialized program generators for compiler IRs is not straightforward and demands considerable resources. We introduce MLIR-Forge, a novel random program generator framework that leverages the flexibility of MLIR, aiming to simplify the creation of specialized program generators. MLIR-Forge achieves this by splitting the generation process into fundamental building blocks that are language specific, and reusable program creation logic that constructs random programs from these building blocks. This hides complexity and furthermore, even the language specific components can be defined using a set of common tools. We demonstrate MLIR-Forge's capabilities by generating MLIR with built-in dialects, WebAssembly, and a data-centric program representation, DaCe -- requiring less than a week of development time in total for each of them. Using the generated programs we conduct differential testing and find 9 MLIR, 15 WebAssembly, and 774 DaCe groups of bugs with the corresponding program generators, after running them until the rate of new bugs stagnates.", "AI": {"tldr": "MLIR-Forge\u662f\u4e00\u4e2a\u57fa\u4e8eMLIR\u7684\u968f\u673a\u7a0b\u5e8f\u751f\u6210\u5668\u6846\u67b6\uff0c\u901a\u8fc7\u5c06\u751f\u6210\u8fc7\u7a0b\u5206\u89e3\u4e3a\u8bed\u8a00\u7279\u5b9a\u7684\u57fa\u7840\u6784\u5efa\u5757\u548c\u53ef\u91cd\u7528\u7684\u7a0b\u5e8f\u521b\u5efa\u903b\u8f91\uff0c\u7b80\u5316\u4e86\u7f16\u8bd1\u5668IR\u4e13\u7528\u6d4b\u8bd5\u5de5\u5177\u7684\u5f00\u53d1\u3002", "motivation": "\u9886\u57df\u7279\u5b9a\u8bed\u8a00\uff08DSL\uff09\u4f7f\u7528\u9ad8\u7ea7\u4e2d\u95f4\u8868\u793a\uff08IR\uff09\u8fdb\u884c\u4f18\u5316\uff0c\u4f46\u6d4b\u8bd5\u8fd9\u4e9bIR\u5f88\u590d\u6742\u3002\u867d\u7136\u968f\u673a\u7a0b\u5e8f\u751f\u6210\u5668\u662f\u6709\u6548\u7684\u7f16\u8bd1\u5668\u6d4b\u8bd5\u5de5\u5177\uff0c\u4f46\u4e3a\u7279\u5b9a\u7f16\u8bd1\u5668IR\u5f00\u53d1\u4e13\u7528\u751f\u6210\u5668\u65e2\u56f0\u96be\u53c8\u8017\u65f6\u3002", "method": "\u63d0\u51faMLIR-Forge\u6846\u67b6\uff0c\u5c06\u7a0b\u5e8f\u751f\u6210\u8fc7\u7a0b\u5206\u89e3\u4e3a\uff1a1\uff09\u8bed\u8a00\u7279\u5b9a\u7684\u57fa\u7840\u6784\u5efa\u5757\uff1b2\uff09\u53ef\u91cd\u7528\u7684\u7a0b\u5e8f\u521b\u5efa\u903b\u8f91\uff0c\u4ece\u8fd9\u4e9b\u6784\u5efa\u5757\u6784\u5efa\u968f\u673a\u7a0b\u5e8f\u3002\u8be5\u6846\u67b6\u9690\u85cf\u590d\u6742\u6027\uff0c\u8bed\u8a00\u7279\u5b9a\u7ec4\u4ef6\u53ef\u4ee5\u4f7f\u7528\u901a\u7528\u5de5\u5177\u96c6\u5b9a\u4e49\u3002", "result": "\u6210\u529f\u4e3aMLIR\u5185\u7f6e\u65b9\u8a00\u3001WebAssembly\u548c\u6570\u636e\u4e2d\u5fc3\u7a0b\u5e8f\u8868\u793aDaCe\u751f\u6210\u4e86\u7a0b\u5e8f\uff0c\u6bcf\u4e2a\u4ec5\u9700\u4e0d\u5230\u4e00\u5468\u5f00\u53d1\u65f6\u95f4\u3002\u901a\u8fc7\u5dee\u5206\u6d4b\u8bd5\u53d1\u73b0\u4e86\u5927\u91cfbug\uff1a9\u4e2aMLIR bug\u300115\u4e2aWebAssembly bug\u548c774\u4e2aDaCe bug\u7ec4\u3002", "conclusion": "MLIR-Forge\u663e\u8457\u7b80\u5316\u4e86\u4e3a\u7f16\u8bd1\u5668IR\u521b\u5efa\u4e13\u7528\u968f\u673a\u7a0b\u5e8f\u751f\u6210\u5668\u7684\u8fc7\u7a0b\uff0c\u80fd\u591f\u9ad8\u6548\u53d1\u73b0\u7f16\u8bd1\u5668\u5b9e\u73b0\u4e2d\u7684\u9519\u8bef\uff0c\u8bc1\u660e\u4e86\u5176\u5728\u7f16\u8bd1\u5668\u6d4b\u8bd5\u4e2d\u7684\u5b9e\u7528\u4ef7\u503c\u3002"}}
