<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [From Dynamic to Lexical: A Comparative Exploration of Scoping Rules in SAS and R](https://arxiv.org/abs/2601.09808)
*Chen Ling,Yachen Wang*

Main category: cs.PL

TL;DR: 该论文比较了SAS的动态作用域和R的词法作用域机制，分析了两种语言在变量访问规则上的核心差异及其对代码行为的影响，并提供了调试和优化策略。


<details>
  <summary>Details</summary>
Motivation: 变量作用域规则对代码效率和结构至关重要，但SAS和R采用完全不同的作用域机制（动态vs词法），理解这些差异对于在这两种语言中编写高效、可靠的代码非常重要。

Method: 通过对比分析SAS的动态作用域（基于符号表，运行时动态搜索宏层）和R的词法作用域（基于环境，根据函数定义结构解析变量），提供具体示例说明差异，并介绍两种语言中检查变量（SAS符号表和R环境）的方法。

Result: 论文展示了两种作用域策略如何影响代码行为，提供了实用的调试和优化技术，包括变量检查方法和作用域控制策略，增强了代码的精确性和可靠性。

Conclusion: 理解SAS和R的作用域差异对优化变量管理至关重要，这有助于提升程序员在这两种语言中的编程实践，提高代码质量和调试效率。

Abstract: Variable scoping dictates how and where variables are accessible within programming languages, playing a crucial role in code efficiency and organization. This paper examines the distinct scoping rules in SAS and R, focusing on SAS's dynamic scoping and R's lexical scoping. In SAS, dynamic scoping utilizes symbol tables, resolving variables at runtime by dynamically searching through active macro layers. R, in contrast, employs lexical scoping, using environments to resolve variables based on the structure in which functions are defined. Illustrative examples highlight the differences between these scoping strategies, showcasing their impact on code behavior. Additionally, the paper outlines methods for inspecting variables in SAS's symbol tables and R's environments, offering practical insights for debugging and optimization. Strategies for controlling variable scope in both languages are discussed, enhancing code precision and reliability. This exploration equips programmers with critical understanding to optimize variable management, improving their programming practices in SAS and R.

</details>


### [2] [Lazy Evaluation: A Comparative Analysis of SAS MACROs and R Functions](https://arxiv.org/abs/2601.09839)
*Chen Ling,Yachen Wang*

Main category: cs.PL

TL;DR: 本文比较了SAS MACROs和R函数中的惰性求值机制，分析了两者在实现原理、内存管理和求值策略上的差异及其对编程效率的影响。


<details>
  <summary>Details</summary>
Motivation: 随着制药行业从SAS向R的转型日益普遍，理解两种语言中惰性求值的技术差异对于优化代码效率至关重要。目前SAS中的惰性求值应用尚未得到充分探索。

Method: 通过比较分析SAS MACROs和R函数的惰性求值机制：R使用Promise数据结构实现按需调用，而SAS通过符号表实现按名调用。论文通过示例说明这些差异如何影响编程结果。

Result: R的惰性求值使用Promise数据结构延迟求值，仅在需要时才占用内存；SAS则通过符号表存储参数，采用不同的内存管理策略。这些差异显著影响R函数和SAS MACROs的执行结果。

Conclusion: 理解SAS和R中惰性求值机制的差异有助于程序员优化代码，提高编程效率。随着制药行业向R的转型，掌握这些技术能够增强在两种语言中的编程能力和性能表现。

Abstract: Lazy evaluation is a powerful technique that can optimize code execution by deferring evaluations until their results are required, thus enhancing efficiency. In most modern programming languages, like R, lazy evaluation is commonly applied to function arguments. However, the application of lazy evaluation in SAS has not been extensively explored. This paper focuses on the mechanisms of lazy evaluation in SAS MACROs and R functions, offering a comparative analysis of the underlying principles that drive these processes.
  R's lazy evaluation is driven by a data structure called Promise, which postpones evaluation and does not occupy memory until the value is needed, utilizing a call-by-need strategy. SAS, on the other hand, achieves lazy evaluation through its symbol tables, employing memory to store parameters, and operates on a call-by-name basis. These discrepancies in lazy evaluation strategies can notably impact the results of R functions and SAS MACROs. By examining these distinct approaches, the paper illuminates the impact of lazy evaluation on programming efficiency, supported by illustrative examples. As the shift from SAS to R becomes increasingly prevalent in the pharmaceutical industry, understanding these techniques enables programmers to optimize their code for greater efficacy. This exploration serves as a guide to enhance programming capabilities and performance in both languages.

</details>


### [3] [Outrunning Big KATs: Efficient Decision Procedures for Variants of GKAT](https://arxiv.org/abs/2601.09986)
*Cheng Zhang,Qiancheng Fu,Hang Ji,Ines Santacruz Del Valle,Alexandra Silva,Marco Gaboardi*

Main category: cs.PL

TL;DR: 本文提出了几种高效的GKAT自动机迹等价判定程序，采用基于SAT求解器的符号技术，并在CF-GKAT系统中实现，性能比现有实现有数量级提升。


<details>
  <summary>Details</summary>
Motivation: GKAT（广义Kleene代数测试）自动机的迹等价判定在程序验证和控制流分析中很重要，但现有方法效率有限，需要更高效的决策程序来支持实际应用。

Method: 开发了基于SAT求解器的符号化在线决策程序，为CF-GKAT设计了符号导数，并在Rust中实现算法，通过随机生成基准和真实控制流转换进行评估。

Result: 相比现有的KAT和CF-GKAT实现，获得了数量级的性能提升，并在实验中发现了行业标准反编译器Ghidra中的一个bug，证明了系统的实际可行性。

Conclusion: 提出的符号化决策程序显著提高了GKAT自动机迹等价判定的效率，在CF-GKAT中的成功应用展示了其实际价值，能够发现真实软件工具中的缺陷。

Abstract: This paper presents several efficient decision procedures for trace equivalence of GKAT automata, which make use of on-the-fly symbolic techniques via SAT solvers. To demonstrate applicability of our algorithms, we designed symbolic derivatives for CF-GKAT, a practical system based on GKAT designed to validate control-flow transformations. We implemented the algorithms in Rust and evaluated them on both randomly generated benchmarks and real-world control-flow transformations. Indeed, we observed order-of-magnitude performance improvements against existing implementations for both KAT and CF-GKAT. Notably, our experiments also revealed a bug in Ghidra, an industry-standard decompiler, highlighting the practical viability of these systems.

</details>
