{"id": "2601.09808", "pdf": "https://arxiv.org/pdf/2601.09808", "abs": "https://arxiv.org/abs/2601.09808", "authors": ["Chen Ling", "Yachen Wang"], "title": "From Dynamic to Lexical: A Comparative Exploration of Scoping Rules in SAS and R", "categories": ["cs.PL"], "comment": "This paper was originally published in the SESUG 2025 Conference Proceedings. Cary, NC", "summary": "Variable scoping dictates how and where variables are accessible within programming languages, playing a crucial role in code efficiency and organization. This paper examines the distinct scoping rules in SAS and R, focusing on SAS's dynamic scoping and R's lexical scoping. In SAS, dynamic scoping utilizes symbol tables, resolving variables at runtime by dynamically searching through active macro layers. R, in contrast, employs lexical scoping, using environments to resolve variables based on the structure in which functions are defined. Illustrative examples highlight the differences between these scoping strategies, showcasing their impact on code behavior. Additionally, the paper outlines methods for inspecting variables in SAS's symbol tables and R's environments, offering practical insights for debugging and optimization. Strategies for controlling variable scope in both languages are discussed, enhancing code precision and reliability. This exploration equips programmers with critical understanding to optimize variable management, improving their programming practices in SAS and R.", "AI": {"tldr": "\u8be5\u8bba\u6587\u6bd4\u8f83\u4e86SAS\u7684\u52a8\u6001\u4f5c\u7528\u57df\u548cR\u7684\u8bcd\u6cd5\u4f5c\u7528\u57df\u673a\u5236\uff0c\u5206\u6790\u4e86\u4e24\u79cd\u8bed\u8a00\u5728\u53d8\u91cf\u8bbf\u95ee\u89c4\u5219\u4e0a\u7684\u6838\u5fc3\u5dee\u5f02\u53ca\u5176\u5bf9\u4ee3\u7801\u884c\u4e3a\u7684\u5f71\u54cd\uff0c\u5e76\u63d0\u4f9b\u4e86\u8c03\u8bd5\u548c\u4f18\u5316\u7b56\u7565\u3002", "motivation": "\u53d8\u91cf\u4f5c\u7528\u57df\u89c4\u5219\u5bf9\u4ee3\u7801\u6548\u7387\u548c\u7ed3\u6784\u81f3\u5173\u91cd\u8981\uff0c\u4f46SAS\u548cR\u91c7\u7528\u5b8c\u5168\u4e0d\u540c\u7684\u4f5c\u7528\u57df\u673a\u5236\uff08\u52a8\u6001vs\u8bcd\u6cd5\uff09\uff0c\u7406\u89e3\u8fd9\u4e9b\u5dee\u5f02\u5bf9\u4e8e\u5728\u8fd9\u4e24\u79cd\u8bed\u8a00\u4e2d\u7f16\u5199\u9ad8\u6548\u3001\u53ef\u9760\u7684\u4ee3\u7801\u975e\u5e38\u91cd\u8981\u3002", "method": "\u901a\u8fc7\u5bf9\u6bd4\u5206\u6790SAS\u7684\u52a8\u6001\u4f5c\u7528\u57df\uff08\u57fa\u4e8e\u7b26\u53f7\u8868\uff0c\u8fd0\u884c\u65f6\u52a8\u6001\u641c\u7d22\u5b8f\u5c42\uff09\u548cR\u7684\u8bcd\u6cd5\u4f5c\u7528\u57df\uff08\u57fa\u4e8e\u73af\u5883\uff0c\u6839\u636e\u51fd\u6570\u5b9a\u4e49\u7ed3\u6784\u89e3\u6790\u53d8\u91cf\uff09\uff0c\u63d0\u4f9b\u5177\u4f53\u793a\u4f8b\u8bf4\u660e\u5dee\u5f02\uff0c\u5e76\u4ecb\u7ecd\u4e24\u79cd\u8bed\u8a00\u4e2d\u68c0\u67e5\u53d8\u91cf\uff08SAS\u7b26\u53f7\u8868\u548cR\u73af\u5883\uff09\u7684\u65b9\u6cd5\u3002", "result": "\u8bba\u6587\u5c55\u793a\u4e86\u4e24\u79cd\u4f5c\u7528\u57df\u7b56\u7565\u5982\u4f55\u5f71\u54cd\u4ee3\u7801\u884c\u4e3a\uff0c\u63d0\u4f9b\u4e86\u5b9e\u7528\u7684\u8c03\u8bd5\u548c\u4f18\u5316\u6280\u672f\uff0c\u5305\u62ec\u53d8\u91cf\u68c0\u67e5\u65b9\u6cd5\u548c\u4f5c\u7528\u57df\u63a7\u5236\u7b56\u7565\uff0c\u589e\u5f3a\u4e86\u4ee3\u7801\u7684\u7cbe\u786e\u6027\u548c\u53ef\u9760\u6027\u3002", "conclusion": "\u7406\u89e3SAS\u548cR\u7684\u4f5c\u7528\u57df\u5dee\u5f02\u5bf9\u4f18\u5316\u53d8\u91cf\u7ba1\u7406\u81f3\u5173\u91cd\u8981\uff0c\u8fd9\u6709\u52a9\u4e8e\u63d0\u5347\u7a0b\u5e8f\u5458\u5728\u8fd9\u4e24\u79cd\u8bed\u8a00\u4e2d\u7684\u7f16\u7a0b\u5b9e\u8df5\uff0c\u63d0\u9ad8\u4ee3\u7801\u8d28\u91cf\u548c\u8c03\u8bd5\u6548\u7387\u3002"}}
{"id": "2601.09839", "pdf": "https://arxiv.org/pdf/2601.09839", "abs": "https://arxiv.org/abs/2601.09839", "authors": ["Chen Ling", "Yachen Wang"], "title": "Lazy Evaluation: A Comparative Analysis of SAS MACROs and R Functions", "categories": ["cs.PL"], "comment": "This paper was originally published in SESUG 2025 Conference Proceedings. Cary, NC: SouthEast SAS Users Group", "summary": "Lazy evaluation is a powerful technique that can optimize code execution by deferring evaluations until their results are required, thus enhancing efficiency. In most modern programming languages, like R, lazy evaluation is commonly applied to function arguments. However, the application of lazy evaluation in SAS has not been extensively explored. This paper focuses on the mechanisms of lazy evaluation in SAS MACROs and R functions, offering a comparative analysis of the underlying principles that drive these processes.\n  R's lazy evaluation is driven by a data structure called Promise, which postpones evaluation and does not occupy memory until the value is needed, utilizing a call-by-need strategy. SAS, on the other hand, achieves lazy evaluation through its symbol tables, employing memory to store parameters, and operates on a call-by-name basis. These discrepancies in lazy evaluation strategies can notably impact the results of R functions and SAS MACROs. By examining these distinct approaches, the paper illuminates the impact of lazy evaluation on programming efficiency, supported by illustrative examples. As the shift from SAS to R becomes increasingly prevalent in the pharmaceutical industry, understanding these techniques enables programmers to optimize their code for greater efficacy. This exploration serves as a guide to enhance programming capabilities and performance in both languages.", "AI": {"tldr": "\u672c\u6587\u6bd4\u8f83\u4e86SAS MACROs\u548cR\u51fd\u6570\u4e2d\u7684\u60f0\u6027\u6c42\u503c\u673a\u5236\uff0c\u5206\u6790\u4e86\u4e24\u8005\u5728\u5b9e\u73b0\u539f\u7406\u3001\u5185\u5b58\u7ba1\u7406\u548c\u6c42\u503c\u7b56\u7565\u4e0a\u7684\u5dee\u5f02\u53ca\u5176\u5bf9\u7f16\u7a0b\u6548\u7387\u7684\u5f71\u54cd\u3002", "motivation": "\u968f\u7740\u5236\u836f\u884c\u4e1a\u4eceSAS\u5411R\u7684\u8f6c\u578b\u65e5\u76ca\u666e\u904d\uff0c\u7406\u89e3\u4e24\u79cd\u8bed\u8a00\u4e2d\u60f0\u6027\u6c42\u503c\u7684\u6280\u672f\u5dee\u5f02\u5bf9\u4e8e\u4f18\u5316\u4ee3\u7801\u6548\u7387\u81f3\u5173\u91cd\u8981\u3002\u76ee\u524dSAS\u4e2d\u7684\u60f0\u6027\u6c42\u503c\u5e94\u7528\u5c1a\u672a\u5f97\u5230\u5145\u5206\u63a2\u7d22\u3002", "method": "\u901a\u8fc7\u6bd4\u8f83\u5206\u6790SAS MACROs\u548cR\u51fd\u6570\u7684\u60f0\u6027\u6c42\u503c\u673a\u5236\uff1aR\u4f7f\u7528Promise\u6570\u636e\u7ed3\u6784\u5b9e\u73b0\u6309\u9700\u8c03\u7528\uff0c\u800cSAS\u901a\u8fc7\u7b26\u53f7\u8868\u5b9e\u73b0\u6309\u540d\u8c03\u7528\u3002\u8bba\u6587\u901a\u8fc7\u793a\u4f8b\u8bf4\u660e\u8fd9\u4e9b\u5dee\u5f02\u5982\u4f55\u5f71\u54cd\u7f16\u7a0b\u7ed3\u679c\u3002", "result": "R\u7684\u60f0\u6027\u6c42\u503c\u4f7f\u7528Promise\u6570\u636e\u7ed3\u6784\u5ef6\u8fdf\u6c42\u503c\uff0c\u4ec5\u5728\u9700\u8981\u65f6\u624d\u5360\u7528\u5185\u5b58\uff1bSAS\u5219\u901a\u8fc7\u7b26\u53f7\u8868\u5b58\u50a8\u53c2\u6570\uff0c\u91c7\u7528\u4e0d\u540c\u7684\u5185\u5b58\u7ba1\u7406\u7b56\u7565\u3002\u8fd9\u4e9b\u5dee\u5f02\u663e\u8457\u5f71\u54cdR\u51fd\u6570\u548cSAS MACROs\u7684\u6267\u884c\u7ed3\u679c\u3002", "conclusion": "\u7406\u89e3SAS\u548cR\u4e2d\u60f0\u6027\u6c42\u503c\u673a\u5236\u7684\u5dee\u5f02\u6709\u52a9\u4e8e\u7a0b\u5e8f\u5458\u4f18\u5316\u4ee3\u7801\uff0c\u63d0\u9ad8\u7f16\u7a0b\u6548\u7387\u3002\u968f\u7740\u5236\u836f\u884c\u4e1a\u5411R\u7684\u8f6c\u578b\uff0c\u638c\u63e1\u8fd9\u4e9b\u6280\u672f\u80fd\u591f\u589e\u5f3a\u5728\u4e24\u79cd\u8bed\u8a00\u4e2d\u7684\u7f16\u7a0b\u80fd\u529b\u548c\u6027\u80fd\u8868\u73b0\u3002"}}
{"id": "2601.09986", "pdf": "https://arxiv.org/pdf/2601.09986", "abs": "https://arxiv.org/abs/2601.09986", "authors": ["Cheng Zhang", "Qiancheng Fu", "Hang Ji", "Ines Santacruz Del Valle", "Alexandra Silva", "Marco Gaboardi"], "title": "Outrunning Big KATs: Efficient Decision Procedures for Variants of GKAT", "categories": ["cs.PL", "cs.LO"], "comment": "Conditionally Accepted at ESOP 2026", "summary": "This paper presents several efficient decision procedures for trace equivalence of GKAT automata, which make use of on-the-fly symbolic techniques via SAT solvers. To demonstrate applicability of our algorithms, we designed symbolic derivatives for CF-GKAT, a practical system based on GKAT designed to validate control-flow transformations. We implemented the algorithms in Rust and evaluated them on both randomly generated benchmarks and real-world control-flow transformations. Indeed, we observed order-of-magnitude performance improvements against existing implementations for both KAT and CF-GKAT. Notably, our experiments also revealed a bug in Ghidra, an industry-standard decompiler, highlighting the practical viability of these systems.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u51e0\u79cd\u9ad8\u6548\u7684GKAT\u81ea\u52a8\u673a\u8ff9\u7b49\u4ef7\u5224\u5b9a\u7a0b\u5e8f\uff0c\u91c7\u7528\u57fa\u4e8eSAT\u6c42\u89e3\u5668\u7684\u7b26\u53f7\u6280\u672f\uff0c\u5e76\u5728CF-GKAT\u7cfb\u7edf\u4e2d\u5b9e\u73b0\uff0c\u6027\u80fd\u6bd4\u73b0\u6709\u5b9e\u73b0\u6709\u6570\u91cf\u7ea7\u63d0\u5347\u3002", "motivation": "GKAT\uff08\u5e7f\u4e49Kleene\u4ee3\u6570\u6d4b\u8bd5\uff09\u81ea\u52a8\u673a\u7684\u8ff9\u7b49\u4ef7\u5224\u5b9a\u5728\u7a0b\u5e8f\u9a8c\u8bc1\u548c\u63a7\u5236\u6d41\u5206\u6790\u4e2d\u5f88\u91cd\u8981\uff0c\u4f46\u73b0\u6709\u65b9\u6cd5\u6548\u7387\u6709\u9650\uff0c\u9700\u8981\u66f4\u9ad8\u6548\u7684\u51b3\u7b56\u7a0b\u5e8f\u6765\u652f\u6301\u5b9e\u9645\u5e94\u7528\u3002", "method": "\u5f00\u53d1\u4e86\u57fa\u4e8eSAT\u6c42\u89e3\u5668\u7684\u7b26\u53f7\u5316\u5728\u7ebf\u51b3\u7b56\u7a0b\u5e8f\uff0c\u4e3aCF-GKAT\u8bbe\u8ba1\u4e86\u7b26\u53f7\u5bfc\u6570\uff0c\u5e76\u5728Rust\u4e2d\u5b9e\u73b0\u7b97\u6cd5\uff0c\u901a\u8fc7\u968f\u673a\u751f\u6210\u57fa\u51c6\u548c\u771f\u5b9e\u63a7\u5236\u6d41\u8f6c\u6362\u8fdb\u884c\u8bc4\u4f30\u3002", "result": "\u76f8\u6bd4\u73b0\u6709\u7684KAT\u548cCF-GKAT\u5b9e\u73b0\uff0c\u83b7\u5f97\u4e86\u6570\u91cf\u7ea7\u7684\u6027\u80fd\u63d0\u5347\uff0c\u5e76\u5728\u5b9e\u9a8c\u4e2d\u53d1\u73b0\u4e86\u884c\u4e1a\u6807\u51c6\u53cd\u7f16\u8bd1\u5668Ghidra\u4e2d\u7684\u4e00\u4e2abug\uff0c\u8bc1\u660e\u4e86\u7cfb\u7edf\u7684\u5b9e\u9645\u53ef\u884c\u6027\u3002", "conclusion": "\u63d0\u51fa\u7684\u7b26\u53f7\u5316\u51b3\u7b56\u7a0b\u5e8f\u663e\u8457\u63d0\u9ad8\u4e86GKAT\u81ea\u52a8\u673a\u8ff9\u7b49\u4ef7\u5224\u5b9a\u7684\u6548\u7387\uff0c\u5728CF-GKAT\u4e2d\u7684\u6210\u529f\u5e94\u7528\u5c55\u793a\u4e86\u5176\u5b9e\u9645\u4ef7\u503c\uff0c\u80fd\u591f\u53d1\u73b0\u771f\u5b9e\u8f6f\u4ef6\u5de5\u5177\u4e2d\u7684\u7f3a\u9677\u3002"}}
