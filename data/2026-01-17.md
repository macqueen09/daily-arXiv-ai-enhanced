<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [From Dynamic to Lexical: A Comparative Exploration of Scoping Rules in SAS and R](https://arxiv.org/abs/2601.09808)
*Chen Ling,Yachen Wang*

Main category: cs.PL

TL;DR: 本文对比了SAS的动态作用域和R的词法作用域机制，分析了它们在变量解析、代码行为、调试优化方面的差异，并提供了实用的变量管理策略。


<details>
  <summary>Details</summary>
Motivation: 变量作用域对编程语言的效率和代码组织至关重要。SAS和R作为两种广泛使用的统计编程语言，采用不同的作用域规则（SAS动态作用域 vs R词法作用域），理解这些差异对于编写高效、可靠的代码非常重要。

Method: 通过对比分析SAS的动态作用域（使用符号表，运行时动态搜索宏层）和R的词法作用域（使用环境，基于函数定义结构解析变量）。提供具体示例展示两种作用域策略的差异，并介绍在SAS中检查符号表和在R中检查环境的方法，以及控制变量作用域的策略。

Result: SAS的动态作用域在运行时解析变量，通过搜索活动宏层确定变量值；R的词法作用域在定义时确定变量环境，基于函数定义结构解析变量。两种机制对代码行为有显著影响，需要不同的调试和优化方法。

Conclusion: 理解SAS和R的作用域差异对优化变量管理至关重要。掌握两种语言的变量检查方法和作用域控制策略，可以提高代码的精确性和可靠性，改善在SAS和R中的编程实践。

Abstract: Variable scoping dictates how and where variables are accessible within programming languages, playing a crucial role in code efficiency and organization. This paper examines the distinct scoping rules in SAS and R, focusing on SAS's dynamic scoping and R's lexical scoping. In SAS, dynamic scoping utilizes symbol tables, resolving variables at runtime by dynamically searching through active macro layers. R, in contrast, employs lexical scoping, using environments to resolve variables based on the structure in which functions are defined. Illustrative examples highlight the differences between these scoping strategies, showcasing their impact on code behavior. Additionally, the paper outlines methods for inspecting variables in SAS's symbol tables and R's environments, offering practical insights for debugging and optimization. Strategies for controlling variable scope in both languages are discussed, enhancing code precision and reliability. This exploration equips programmers with critical understanding to optimize variable management, improving their programming practices in SAS and R.

</details>


### [2] [Lazy Evaluation: A Comparative Analysis of SAS MACROs and R Functions](https://arxiv.org/abs/2601.09839)
*Chen Ling,Yachen Wang*

Main category: cs.PL

TL;DR: 本文比较了SAS MACRO和R函数中的惰性求值机制，分析了两者在实现原理、内存管理和求值策略上的差异，为从SAS转向R的程序员提供优化代码的指导。


<details>
  <summary>Details</summary>
Motivation: 随着制药行业从SAS向R的转型日益普遍，理解两种语言中惰性求值的不同实现机制对于程序员优化代码效率至关重要。虽然R中的惰性求值已被广泛研究，但SAS中的相关应用尚未得到充分探索。

Method: 通过比较分析SAS MACRO和R函数的惰性求值机制：R使用Promise数据结构实现按需调用策略，延迟求值且不占用内存；SAS通过符号表实现按名调用策略，使用内存存储参数。论文通过示例说明这些差异如何影响编程结果。

Result: 研究发现两种语言在惰性求值策略上的显著差异：R的Promise机制更节省内存，而SAS的符号表方法需要预先分配内存。这些差异直接影响R函数和SAS MACRO的执行结果和效率。

Conclusion: 理解SAS和R中惰性求值的不同实现机制有助于程序员在两种语言间迁移时优化代码性能。本文为增强两种语言的编程能力和性能提供了实用指导，特别是在制药行业的技术转型背景下。

Abstract: Lazy evaluation is a powerful technique that can optimize code execution by deferring evaluations until their results are required, thus enhancing efficiency. In most modern programming languages, like R, lazy evaluation is commonly applied to function arguments. However, the application of lazy evaluation in SAS has not been extensively explored. This paper focuses on the mechanisms of lazy evaluation in SAS MACROs and R functions, offering a comparative analysis of the underlying principles that drive these processes.
  R's lazy evaluation is driven by a data structure called Promise, which postpones evaluation and does not occupy memory until the value is needed, utilizing a call-by-need strategy. SAS, on the other hand, achieves lazy evaluation through its symbol tables, employing memory to store parameters, and operates on a call-by-name basis. These discrepancies in lazy evaluation strategies can notably impact the results of R functions and SAS MACROs. By examining these distinct approaches, the paper illuminates the impact of lazy evaluation on programming efficiency, supported by illustrative examples. As the shift from SAS to R becomes increasingly prevalent in the pharmaceutical industry, understanding these techniques enables programmers to optimize their code for greater efficacy. This exploration serves as a guide to enhance programming capabilities and performance in both languages.

</details>


### [3] [Outrunning Big KATs: Efficient Decision Procedures for Variants of GKAT](https://arxiv.org/abs/2601.09986)
*Cheng Zhang,Qiancheng Fu,Hang Ji,Ines Santacruz Del Valle,Alexandra Silva,Marco Gaboardi*

Main category: cs.PL

TL;DR: 本文提出了几种高效的GKAT自动机迹等价决策过程，利用SAT求解器实现符号化技术，并在CF-GKAT系统中应用，相比现有实现获得数量级性能提升，还发现了Ghidra反编译器的bug。


<details>
  <summary>Details</summary>
Motivation: 需要为GKAT自动机开发高效的迹等价决策过程，以验证控制流转换的正确性，现有实现性能不足。

Method: 设计了基于SAT求解器的符号化在线决策算法，为CF-GKAT系统开发了符号导数方法，并在Rust中实现。

Result: 在随机生成基准测试和真实控制流转换上评估，相比KAT和CF-GKAT现有实现获得数量级性能提升，并发现了Ghidra反编译器的bug。

Conclusion: 提出的符号化决策过程显著提升了GKAT自动机迹等价的验证效率，证明了在实际控制流验证中的实用价值。

Abstract: This paper presents several efficient decision procedures for trace equivalence of GKAT automata, which make use of on-the-fly symbolic techniques via SAT solvers. To demonstrate applicability of our algorithms, we designed symbolic derivatives for CF-GKAT, a practical system based on GKAT designed to validate control-flow transformations. We implemented the algorithms in Rust and evaluated them on both randomly generated benchmarks and real-world control-flow transformations. Indeed, we observed order-of-magnitude performance improvements against existing implementations for both KAT and CF-GKAT. Notably, our experiments also revealed a bug in Ghidra, an industry-standard decompiler, highlighting the practical viability of these systems.

</details>
