<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [From Dynamic to Lexical: A Comparative Exploration of Scoping Rules in SAS and R](https://arxiv.org/abs/2601.09808)
*Chen Ling,Yachen Wang*

Main category: cs.PL

TL;DR: 本文对比了SAS的动态作用域和R的词法作用域机制，分析了两种语言在变量作用域规则上的核心差异及其对代码行为的影响。


<details>
  <summary>Details</summary>
Motivation: 变量作用域规则对代码效率和结构至关重要，但SAS和R采用完全不同的作用域机制（动态作用域vs词法作用域），理解这些差异对于优化变量管理和提高编程实践质量非常重要。

Method: 通过对比分析SAS的动态作用域（使用符号表，运行时动态搜索宏层）和R的词法作用域（使用环境，基于函数定义结构解析变量），提供具体示例展示差异，并介绍两种语言中检查和控制变量作用域的方法。

Result: 展示了两种作用域策略在代码行为上的显著差异，提供了实用的调试和优化方法，包括如何检查SAS符号表和R环境中的变量，以及控制变量作用域的策略。

Conclusion: 深入理解SAS和R的作用域机制差异，能够帮助程序员更好地管理变量、提高代码精确性和可靠性，从而优化在两种语言中的编程实践。

Abstract: Variable scoping dictates how and where variables are accessible within programming languages, playing a crucial role in code efficiency and organization. This paper examines the distinct scoping rules in SAS and R, focusing on SAS's dynamic scoping and R's lexical scoping. In SAS, dynamic scoping utilizes symbol tables, resolving variables at runtime by dynamically searching through active macro layers. R, in contrast, employs lexical scoping, using environments to resolve variables based on the structure in which functions are defined. Illustrative examples highlight the differences between these scoping strategies, showcasing their impact on code behavior. Additionally, the paper outlines methods for inspecting variables in SAS's symbol tables and R's environments, offering practical insights for debugging and optimization. Strategies for controlling variable scope in both languages are discussed, enhancing code precision and reliability. This exploration equips programmers with critical understanding to optimize variable management, improving their programming practices in SAS and R.

</details>


### [2] [Lazy Evaluation: A Comparative Analysis of SAS MACROs and R Functions](https://arxiv.org/abs/2601.09839)
*Chen Ling,Yachen Wang*

Main category: cs.PL

TL;DR: 比较SAS MACROs和R函数中惰性求值的实现机制差异及其对编程效率的影响


<details>
  <summary>Details</summary>
Motivation: 随着制药行业从SAS向R转型的趋势日益明显，理解两种语言中惰性求值的技术差异对程序员优化代码、提高效率至关重要。目前SAS中的惰性求值应用尚未得到充分探索。

Method: 通过比较分析SAS MACROs和R函数中惰性求值的底层原理：R使用Promise数据结构实现按需调用策略，SAS通过符号表实现按名调用策略。

Result: 两种语言在惰性求值策略上的差异显著影响R函数和SAS MACROs的执行结果，这些差异对编程效率有重要影响。

Conclusion: 理解SAS和R中惰性求值的技术差异有助于程序员在两种语言中优化代码，提高编程能力和性能，为行业转型提供指导。

Abstract: Lazy evaluation is a powerful technique that can optimize code execution by deferring evaluations until their results are required, thus enhancing efficiency. In most modern programming languages, like R, lazy evaluation is commonly applied to function arguments. However, the application of lazy evaluation in SAS has not been extensively explored. This paper focuses on the mechanisms of lazy evaluation in SAS MACROs and R functions, offering a comparative analysis of the underlying principles that drive these processes.
  R's lazy evaluation is driven by a data structure called Promise, which postpones evaluation and does not occupy memory until the value is needed, utilizing a call-by-need strategy. SAS, on the other hand, achieves lazy evaluation through its symbol tables, employing memory to store parameters, and operates on a call-by-name basis. These discrepancies in lazy evaluation strategies can notably impact the results of R functions and SAS MACROs. By examining these distinct approaches, the paper illuminates the impact of lazy evaluation on programming efficiency, supported by illustrative examples. As the shift from SAS to R becomes increasingly prevalent in the pharmaceutical industry, understanding these techniques enables programmers to optimize their code for greater efficacy. This exploration serves as a guide to enhance programming capabilities and performance in both languages.

</details>


### [3] [Outrunning Big KATs: Efficient Decision Procedures for Variants of GKAT](https://arxiv.org/abs/2601.09986)
*Cheng Zhang,Qiancheng Fu,Hang Ji,Ines Santacruz Del Valle,Alexandra Silva,Marco Gaboardi*

Main category: cs.PL

TL;DR: 本文提出了几种高效的GKAT自动机迹等价决策过程，利用SAT求解器实现即时符号化技术，并在CF-GKAT系统中应用，相比现有实现获得数量级性能提升。


<details>
  <summary>Details</summary>
Motivation: 需要开发高效的GKAT自动机迹等价决策算法，以验证控制流转换的正确性，并提高实际应用中的性能。

Method: 1. 设计基于SAT求解器的即时符号化决策过程；2. 为CF-GKAT系统设计符号导数；3. 在Rust中实现算法；4. 使用随机生成基准和真实控制流转换进行评估。

Result: 1. 相比现有KAT和CF-GKAT实现获得数量级性能提升；2. 在实验中发现了行业标准反编译器Ghidra的bug；3. 证明了系统的实际可行性。

Conclusion: 提出的决策过程高效实用，能够显著提升GKAT自动机迹等价验证的性能，并在实际应用中验证了控制流转换的正确性，具有重要的工程价值。

Abstract: This paper presents several efficient decision procedures for trace equivalence of GKAT automata, which make use of on-the-fly symbolic techniques via SAT solvers. To demonstrate applicability of our algorithms, we designed symbolic derivatives for CF-GKAT, a practical system based on GKAT designed to validate control-flow transformations. We implemented the algorithms in Rust and evaluated them on both randomly generated benchmarks and real-world control-flow transformations. Indeed, we observed order-of-magnitude performance improvements against existing implementations for both KAT and CF-GKAT. Notably, our experiments also revealed a bug in Ghidra, an industry-standard decompiler, highlighting the practical viability of these systems.

</details>
