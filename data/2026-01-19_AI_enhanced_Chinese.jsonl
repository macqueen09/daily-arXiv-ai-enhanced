{"id": "2601.11358", "pdf": "https://arxiv.org/pdf/2601.11358", "abs": "https://arxiv.org/abs/2601.11358", "authors": ["Bernd Finkbeiner", "Martin Fr\u00e4nzle", "Florian Kohn", "Paul Kr\u00f6ger"], "title": "Cutting Corners on Uncertainty: Zonotope Abstractions for Stream-based Runtime Monitoring", "categories": ["cs.PL"], "comment": null, "summary": "Stream-based monitoring assesses the health of safety-critical systems by transforming input streams of sensor measurements into output streams that determine a verdict. These inputs are often treated as accurate representations of the physical state, although real sensors introduce calibration and measurement errors. Such errors propagate through the monitor's computations and can distort the final verdict. Affine arithmetic with symbolic slack variables can track these errors precisely, but independent measurement noise introduces a fresh slack variable upon each measurement event, causing the monitor's state representation to grow without bound over time. Therefore, any bounded-memory monitoring algorithm must unify slack variables at runtime in a way that generates a sound approximation.\n  This paper introduces zonotopes as an abstract domain for online monitoring of RLola specifications. We demonstrate that zonotopes precisely capture the affine state of the monitor and that their over-approximation produces a sound bounded-memory monitor. We present a comparison of different zonotope over-approximation strategies in the context of runtime monitoring, evaluating their performance and false-positive rates.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63d0\u51fa\u4f7f\u7528zonotopes\u4f5c\u4e3a\u5728\u7ebf\u76d1\u63a7RLola\u89c4\u8303\u7684\u62bd\u8c61\u57df\uff0c\u80fd\u591f\u7cbe\u786e\u6355\u83b7\u76d1\u63a7\u5668\u7684\u4eff\u5c04\u72b6\u6001\uff0c\u5e76\u901a\u8fc7\u8fc7\u8fd1\u4f3c\u5b9e\u73b0\u6709\u754c\u5185\u5b58\u76d1\u63a7\u3002", "motivation": "\u6d41\u5f0f\u76d1\u63a7\u901a\u8fc7\u4f20\u611f\u5668\u6d4b\u91cf\u8f93\u5165\u6d41\u8bc4\u4f30\u5b89\u5168\u5173\u952e\u7cfb\u7edf\u7684\u5065\u5eb7\u72b6\u51b5\uff0c\u4f46\u5b9e\u9645\u4f20\u611f\u5668\u5b58\u5728\u6821\u51c6\u548c\u6d4b\u91cf\u8bef\u5dee\u3002\u8fd9\u4e9b\u8bef\u5dee\u901a\u8fc7\u76d1\u63a7\u8ba1\u7b97\u4f20\u64ad\u5e76\u53ef\u80fd\u626d\u66f2\u6700\u7ec8\u5224\u51b3\u3002\u867d\u7136\u4eff\u5c04\u7b97\u672f\u80fd\u7cbe\u786e\u8ddf\u8e2a\u8bef\u5dee\uff0c\u4f46\u72ec\u7acb\u6d4b\u91cf\u566a\u58f0\u4f1a\u5f15\u5165\u65b0\u7684\u677e\u5f1b\u53d8\u91cf\uff0c\u5bfc\u81f4\u76d1\u63a7\u72b6\u6001\u968f\u65f6\u95f4\u65e0\u9650\u589e\u957f\uff0c\u56e0\u6b64\u9700\u8981\u8bbe\u8ba1\u6709\u754c\u5185\u5b58\u76d1\u63a7\u7b97\u6cd5\u3002", "method": "\u5f15\u5165zonotopes\u4f5c\u4e3a\u5728\u7ebf\u76d1\u63a7RLola\u89c4\u8303\u7684\u62bd\u8c61\u57df\u3002zonotopes\u80fd\u7cbe\u786e\u6355\u83b7\u76d1\u63a7\u5668\u7684\u4eff\u5c04\u72b6\u6001\uff0c\u901a\u8fc7zonotope\u8fc7\u8fd1\u4f3c\u4ea7\u751f\u6709\u754c\u5185\u5b58\u76d1\u63a7\u5668\u3002\u6bd4\u8f83\u4e86\u4e0d\u540czonotope\u8fc7\u8fd1\u4f3c\u7b56\u7565\u5728\u8fd0\u884c\u65f6\u76d1\u63a7\u4e2d\u7684\u6027\u80fd\u3002", "result": "zonotopes\u80fd\u591f\u7cbe\u786e\u6355\u83b7\u76d1\u63a7\u5668\u7684\u4eff\u5c04\u72b6\u6001\uff0c\u5176\u8fc7\u8fd1\u4f3c\u80fd\u4ea7\u751f\u6709\u754c\u5185\u5b58\u76d1\u63a7\u5668\u3002\u901a\u8fc7\u6bd4\u8f83\u4e0d\u540czonotope\u8fc7\u8fd1\u4f3c\u7b56\u7565\uff0c\u8bc4\u4f30\u4e86\u5b83\u4eec\u5728\u8fd0\u884c\u65f6\u76d1\u63a7\u4e2d\u7684\u6027\u80fd\u548c\u8bef\u62a5\u7387\u3002", "conclusion": "zonotopes\u4f5c\u4e3a\u62bd\u8c61\u57df\u4e3a\u5728\u7ebf\u76d1\u63a7RLola\u89c4\u8303\u63d0\u4f9b\u4e86\u6709\u6548\u89e3\u51b3\u65b9\u6848\uff0c\u80fd\u591f\u5904\u7406\u4f20\u611f\u5668\u8bef\u5dee\u4f20\u64ad\u95ee\u9898\uff0c\u5e76\u901a\u8fc7\u8fc7\u8fd1\u4f3c\u5b9e\u73b0\u6709\u754c\u5185\u5b58\u76d1\u63a7\uff0c\u4e3a\u5b89\u5168\u5173\u952e\u7cfb\u7edf\u7684\u53ef\u9760\u76d1\u63a7\u63d0\u4f9b\u4e86\u7406\u8bba\u57fa\u7840\u3002"}}
{"id": "2601.11408", "pdf": "https://arxiv.org/pdf/2601.11408", "abs": "https://arxiv.org/abs/2601.11408", "authors": ["Qinlin Chen", "Nairen Zhang", "Jinpeng Wang", "Jiacai Cui", "Tian Tan", "Xiaoxing Ma", "Chang Xu", "Jian Lu", "Yue Li"], "title": "Qihe: A General-Purpose Static Analysis Framework for Verilog", "categories": ["cs.PL"], "comment": null, "summary": "In the past decades, static analysis has thrived in software, facilitating applications in bug detection, security, and program understanding. These advanced analyses are largely underpinned by general-purpose static analysis frameworks, which offer essential infrastructure to streamline their development. Conversely, hardware lacks such a framework, which overshadows the promising opportunities for sophisticated static analysis in hardware, hindering achievements akin to those witnessed in software. We thus introduce Qihe, the first general-purpose static analysis framework for Verilog -- a highly challenging endeavor given the absence of precedents in hardware. Qihe features an analysis-oriented front end, a Verilog-specific IR, and a suite of diverse fundamental analyses that capture essential hardware-specific characteristics -- such as bit-vector arithmetic, register synchronization, and digital component concurrency -- and enable the examination of intricate hardware data and control flows. These fundamental analyses are designed to support a wide array of hardware analysis clients. To validate Qihe's utility, we further developed a set of clients spanning bug detection, security, and program understanding. Our preliminary experimental results are highly promising; for example, Qihe uncovered 9 previously unknown bugs in popular real-world hardware projects (averaging 1.5K+ GitHub stars), all of which were confirmed by developers; moreover, Qihe successfully identified 18 bugs beyond the capabilities of existing static analyses for Verilog bug detection (i.e., linters), and detected 16 vulnerabilities in real-world hardware programs. By open-sourcing Qihe, which comprises over 100K lines of code, we aim to inspire further innovation and applications of sophisticated static analysis for hardware, aspiring to foster a similarly vibrant ecosystem that software analysis enjoys.", "AI": {"tldr": "Qihe\u662f\u9996\u4e2a\u9488\u5bf9Verilog\u7684\u901a\u7528\u9759\u6001\u5206\u6790\u6846\u67b6\uff0c\u586b\u8865\u4e86\u786c\u4ef6\u9886\u57df\u7f3a\u4e4f\u7c7b\u4f3c\u8f6f\u4ef6\u9759\u6001\u5206\u6790\u6846\u67b6\u7684\u7a7a\u767d\uff0c\u652f\u6301\u786c\u4ef6\u7279\u5b9a\u7279\u6027\u5206\u6790\u5e76\u5df2\u53d1\u73b0\u591a\u4e2a\u771f\u5b9e\u786c\u4ef6\u9879\u76ee\u4e2d\u7684bug\u548c\u6f0f\u6d1e\u3002", "motivation": "\u786c\u4ef6\u9886\u57df\u7f3a\u4e4f\u901a\u7528\u9759\u6001\u5206\u6790\u6846\u67b6\uff0c\u963b\u788d\u4e86\u786c\u4ef6\u9759\u6001\u5206\u6790\u7684\u53d1\u5c55\u3002\u8f6f\u4ef6\u9886\u57df\u5df2\u6709\u6210\u719f\u7684\u9759\u6001\u5206\u6790\u6846\u67b6\u652f\u6301\u5404\u79cd\u5e94\u7528\uff0c\u800c\u786c\u4ef6\u9886\u57df\u6ca1\u6709\u7c7b\u4f3c\u57fa\u7840\u8bbe\u65bd\uff0c\u9650\u5236\u4e86\u786c\u4ef6bug\u68c0\u6d4b\u3001\u5b89\u5168\u5206\u6790\u548c\u7a0b\u5e8f\u7406\u89e3\u7b49\u5e94\u7528\u7684\u53d1\u5c55\u3002", "method": "Qihe\u6846\u67b6\u5305\u542b\u4e09\u4e2a\u6838\u5fc3\u7ec4\u4ef6\uff1a1\uff09\u9762\u5411\u5206\u6790\u7684\u524d\u7aef\uff0c2\uff09Verilog\u7279\u5b9a\u7684\u4e2d\u95f4\u8868\u793a\uff08IR\uff09\uff0c3\uff09\u4e00\u5957\u6355\u6349\u786c\u4ef6\u7279\u5b9a\u7279\u6027\u7684\u57fa\u7840\u5206\u6790\u7ec4\u4ef6\uff08\u5982\u4f4d\u5411\u91cf\u7b97\u672f\u3001\u5bc4\u5b58\u5668\u540c\u6b65\u3001\u6570\u5b57\u7ec4\u4ef6\u5e76\u53d1\u7b49\uff09\u3002\u8fd9\u4e9b\u57fa\u7840\u5206\u6790\u652f\u6301\u68c0\u67e5\u590d\u6742\u7684\u786c\u4ef6\u6570\u636e\u548c\u63a7\u5236\u6d41\u3002", "result": "\u5b9e\u9a8c\u7ed3\u679c\u663e\u793a\uff1a1\uff09\u5728\u6d41\u884c\u7684\u771f\u5b9e\u786c\u4ef6\u9879\u76ee\u4e2d\u53d1\u73b0\u4e869\u4e2a\u4e4b\u524d\u672a\u77e5\u7684bug\uff08\u5e73\u57471500+ GitHub\u661f\u6807\uff09\uff0c\u5168\u90e8\u5f97\u5230\u5f00\u53d1\u8005\u786e\u8ba4\uff1b2\uff09\u53d1\u73b0\u4e8618\u4e2a\u73b0\u6709Verilog\u9759\u6001\u5206\u6790\u5de5\u5177\uff08linters\uff09\u65e0\u6cd5\u68c0\u6d4b\u7684bug\uff1b3\uff09\u5728\u771f\u5b9e\u786c\u4ef6\u7a0b\u5e8f\u4e2d\u68c0\u6d4b\u523016\u4e2a\u5b89\u5168\u6f0f\u6d1e\u3002", "conclusion": "Qihe\u662f\u9996\u4e2a\u9488\u5bf9Verilog\u7684\u901a\u7528\u9759\u6001\u5206\u6790\u6846\u67b6\uff0c\u6210\u529f\u586b\u8865\u4e86\u786c\u4ef6\u9886\u57df\u7684\u7a7a\u767d\u3002\u901a\u8fc7\u5f00\u6e90\u5305\u542b10\u4e07\u884c\u4ee3\u7801\u7684\u6846\u67b6\uff0c\u65e8\u5728\u6fc0\u53d1\u786c\u4ef6\u9759\u6001\u5206\u6790\u7684\u521b\u65b0\u548c\u5e94\u7528\uff0c\u4fc3\u8fdb\u786c\u4ef6\u5206\u6790\u751f\u6001\u7cfb\u7edf\u7684\u53d1\u5c55\uff0c\u8fbe\u5230\u8f6f\u4ef6\u5206\u6790\u9886\u57df\u7684\u7e41\u8363\u7a0b\u5ea6\u3002"}}
