{"id": "2601.15167", "pdf": "https://arxiv.org/pdf/2601.15167", "abs": "https://arxiv.org/abs/2601.15167", "authors": ["Francesca Randone", "Romina Doz", "Mirco Tribastone", "Luca Bortolussi"], "title": "DeGAS: Gradient-Based Optimization of Probabilistic Programs without Sampling", "categories": ["cs.PL"], "comment": null, "summary": "We present DeGAS, a differentiable Gaussian approximate semantics for loopless probabilistic programs that enables sample-free, gradient-based optimization in models with both continuous and discrete components. DeGAS evaluates programs under a Gaussian-mixture semantics and replaces measure-zero predicates and discrete branches with a vanishing smoothing, yielding closed-form expressions for posterior and path probabilities. We prove differentiability of these quantities with respect to program parameters, enabling end-to-end optimization via standard automatic differentiation, without Monte Carlo estimators. On thirteen benchmark programs, DeGAS achieves accuracy and runtime competitive with variational inference and MCMC. Importantly, it reliably tackles optimization problems where sampling-based baselines fail to converge due to conditioning involving continuous variables.", "AI": {"tldr": "DeGAS\uff1a\u4e00\u79cd\u7528\u4e8e\u65e0\u5faa\u73af\u6982\u7387\u7a0b\u5e8f\u7684\u53ef\u5fae\u5206\u9ad8\u65af\u8fd1\u4f3c\u8bed\u4e49\uff0c\u652f\u6301\u514d\u91c7\u6837\u3001\u57fa\u4e8e\u68af\u5ea6\u7684\u4f18\u5316\uff0c\u9002\u7528\u4e8e\u8fde\u7eed\u548c\u79bb\u6563\u6df7\u5408\u6a21\u578b\u3002", "motivation": "\u4f20\u7edf\u57fa\u4e8e\u91c7\u6837\u7684\u6982\u7387\u7a0b\u5e8f\u4f18\u5316\u65b9\u6cd5\uff08\u5982MCMC\u3001\u53d8\u5206\u63a8\u65ad\uff09\u5728\u6d89\u53ca\u8fde\u7eed\u53d8\u91cf\u7684\u6761\u4ef6\u7ea6\u675f\u65f6\u53ef\u80fd\u6536\u655b\u56f0\u96be\uff0c\u4e14\u8499\u7279\u5361\u6d1b\u4f30\u8ba1\u5668\u5b58\u5728\u65b9\u5dee\u95ee\u9898\u3002\u9700\u8981\u4e00\u79cd\u514d\u91c7\u6837\u3001\u53ef\u5fae\u5206\u7684\u4f18\u5316\u65b9\u6cd5\u3002", "method": "\u91c7\u7528\u9ad8\u65af\u6df7\u5408\u8bed\u4e49\u8bc4\u4f30\u7a0b\u5e8f\uff0c\u5c06\u6d4b\u5ea6\u96f6\u8c13\u8bcd\u548c\u79bb\u6563\u5206\u652f\u66ff\u6362\u4e3a\u6e10\u8fd1\u5e73\u6ed1\uff0c\u5f97\u5230\u540e\u9a8c\u548c\u8def\u5f84\u6982\u7387\u7684\u95ed\u5f0f\u8868\u8fbe\u5f0f\u3002\u8bc1\u660e\u8fd9\u4e9b\u91cf\u5bf9\u7a0b\u5e8f\u53c2\u6570\u7684\u53ef\u5fae\u6027\uff0c\u901a\u8fc7\u6807\u51c6\u81ea\u52a8\u5fae\u5206\u5b9e\u73b0\u7aef\u5230\u7aef\u4f18\u5316\u3002", "result": "\u572813\u4e2a\u57fa\u51c6\u7a0b\u5e8f\u4e0a\uff0cDeGAS\u5728\u51c6\u786e\u6027\u548c\u8fd0\u884c\u65f6\u95f4\u4e0a\u4e0e\u53d8\u5206\u63a8\u65ad\u548cMCMC\u76f8\u5f53\u3002\u5728\u6d89\u53ca\u8fde\u7eed\u53d8\u91cf\u7684\u6761\u4ef6\u4f18\u5316\u95ee\u9898\u4e0a\uff0cDeGAS\u80fd\u53ef\u9760\u6536\u655b\uff0c\u800c\u57fa\u4e8e\u91c7\u6837\u7684\u57fa\u7ebf\u65b9\u6cd5\u5219\u5931\u8d25\u3002", "conclusion": "DeGAS\u4e3a\u6df7\u5408\u8fde\u7eed-\u79bb\u6563\u6982\u7387\u7a0b\u5e8f\u63d0\u4f9b\u4e86\u4e00\u79cd\u6709\u6548\u7684\u514d\u91c7\u6837\u3001\u53ef\u5fae\u5206\u4f18\u5316\u6846\u67b6\uff0c\u89e3\u51b3\u4e86\u4f20\u7edf\u91c7\u6837\u65b9\u6cd5\u5728\u6761\u4ef6\u4f18\u5316\u95ee\u9898\u4e0a\u7684\u6536\u655b\u56f0\u96be\u3002"}}
{"id": "2601.15180", "pdf": "https://arxiv.org/pdf/2601.15180", "abs": "https://arxiv.org/abs/2601.15180", "authors": ["Pedro \u00c2ngelo", "Atsushi Igarashi", "Yuito Murase", "Vasco T. Vasconcelos"], "title": "Contextual Metaprogramming for Session Types", "categories": ["cs.PL"], "comment": "36 pages, 14 figures, ESOP 2026", "summary": "We propose the integration of staged metaprogramming into a session-typed message passing functional language. We build on a model of contextual modal type theory with multi-level contexts, where contextual values, closing arbitrary terms over a series of variables, may be boxed and transmitted in messages. Once received, one such value may then be unboxed and locally applied before being run. To motivate this integration, we present examples of real-world use cases, for which our system would be suitable, such as servers preparing and shipping code on demand via session typed messages. We present a type system that distinguishes linear (used exactly once) from unrestricted (used an unbounded number of times) resources, and further define a type checker, suitable for a concrete implementation. We show type preservation, a progress result for sequential computations and absence of runtime errors for the concurrent runtime environment, as well as the correctness of the type checker.", "AI": {"tldr": "\u5c06\u5206\u9636\u6bb5\u5143\u7f16\u7a0b\u96c6\u6210\u5230\u4f1a\u8bdd\u7c7b\u578b\u7684\u6d88\u606f\u4f20\u9012\u51fd\u6570\u5f0f\u8bed\u8a00\u4e2d\uff0c\u901a\u8fc7\u4e0a\u4e0b\u6587\u6a21\u6001\u7c7b\u578b\u7406\u8bba\u548c\u591a\u7ea7\u4e0a\u4e0b\u6587\u652f\u6301\u4ee3\u7801\u4f20\u8f93\u548c\u6267\u884c", "motivation": "\u89e3\u51b3\u73b0\u5b9e\u4e16\u754c\u4e2d\u9700\u8981\u52a8\u6001\u51c6\u5907\u548c\u4f20\u8f93\u4ee3\u7801\u7684\u573a\u666f\uff0c\u5982\u670d\u52a1\u5668\u6309\u9700\u901a\u8fc7\u4f1a\u8bdd\u7c7b\u578b\u6d88\u606f\u51c6\u5907\u548c\u53d1\u9001\u4ee3\u7801\uff0c\u5b9e\u73b0\u7075\u6d3b\u7684\u7a0b\u5e8f\u751f\u6210\u548c\u5206\u53d1", "method": "\u57fa\u4e8e\u591a\u7ea7\u4e0a\u4e0b\u6587\u7684\u4e0a\u4e0b\u6587\u6a21\u6001\u7c7b\u578b\u7406\u8bba\u6a21\u578b\uff0c\u652f\u6301\u4e0a\u4e0b\u6587\u503c\u7684\u88c5\u7bb1\u548c\u6d88\u606f\u4f20\u8f93\uff0c\u533a\u5206\u7ebf\u6027\u8d44\u6e90\uff08\u4f7f\u7528\u4e00\u6b21\uff09\u548c\u65e0\u9650\u5236\u8d44\u6e90\uff08\u65e0\u9650\u6b21\u4f7f\u7528\uff09\uff0c\u8bbe\u8ba1\u7c7b\u578b\u7cfb\u7edf\u548c\u7c7b\u578b\u68c0\u67e5\u5668", "result": "\u5b9e\u73b0\u4e86\u7c7b\u578b\u4fdd\u6301\u6027\u3001\u987a\u5e8f\u8ba1\u7b97\u7684\u8fdb\u5c55\u7ed3\u679c\u3001\u5e76\u53d1\u8fd0\u884c\u65f6\u73af\u5883\u65e0\u8fd0\u884c\u65f6\u9519\u8bef\uff0c\u4ee5\u53ca\u7c7b\u578b\u68c0\u67e5\u5668\u7684\u6b63\u786e\u6027\u8bc1\u660e", "conclusion": "\u6210\u529f\u5c06\u5206\u9636\u6bb5\u5143\u7f16\u7a0b\u96c6\u6210\u5230\u4f1a\u8bdd\u7c7b\u578b\u6d88\u606f\u4f20\u9012\u8bed\u8a00\u4e2d\uff0c\u4e3a\u52a8\u6001\u4ee3\u7801\u4f20\u8f93\u548c\u6267\u884c\u63d0\u4f9b\u4e86\u7c7b\u578b\u5b89\u5168\u7684\u6846\u67b6\uff0c\u9002\u7528\u4e8e\u670d\u52a1\u5668\u6309\u9700\u5206\u53d1\u4ee3\u7801\u7b49\u5b9e\u9645\u5e94\u7528\u573a\u666f"}}
{"id": "2601.15188", "pdf": "https://arxiv.org/pdf/2601.15188", "abs": "https://arxiv.org/abs/2601.15188", "authors": ["Stephan Wallraven", "Tim K\u00f6hne", "Hartmut Westenberger", "Andreas Moser"], "title": "Benchmarking Large Language Models for ABAP Code Generation: An Empirical Study on Iterative Improvement by Compiler Feedback", "categories": ["cs.SE", "cs.AI", "cs.PL"], "comment": "20 pages, 10 figures, Author: Hartmut Westenberger (ORCID: 0009-0009-9063-8318)", "summary": "This work investigates the performance of Large Language Models (LLMs) in generating ABAP code. Despite successful applications of generative AI in many programming languages, there are hardly any systematic analyses of ABAP code generation to date. The aim of the study is to empirically analyze to what extent various LLMs can generate syntactically correct and functional ABAP code, how effectively they use compiler feedback for iterative improvement, and which task types pose special challenges. For this purpose, a benchmark with 180 tasks is conducted, consisting of adapted HumanEval tasks and practical SAP scenarios. The results show significant performance differences between the models: more powerful LLMs achieve success rates of around 75% after several iterations and benefit greatly from compiler feedback, while smaller models perform significantly weaker. Overall, the study highlights the high potential of powerful LLMs for ABAP development processes, especially in iterative error correction.", "AI": {"tldr": "LLMs\u5728\u751f\u6210ABAP\u4ee3\u7801\u65b9\u9762\u8868\u73b0\u51fa\u663e\u8457\u6027\u80fd\u5dee\u5f02\uff0c\u5f3a\u5927\u6a21\u578b\u901a\u8fc7\u8fed\u4ee3\u7f16\u8bd1\u53cd\u9988\u53ef\u8fbe75%\u6210\u529f\u7387\uff0c\u800c\u5c0f\u6a21\u578b\u8868\u73b0\u8f83\u5dee\u3002", "motivation": "\u5c3d\u7ba1\u751f\u6210\u5f0fAI\u5728\u8bb8\u591a\u7f16\u7a0b\u8bed\u8a00\u4e2d\u5e94\u7528\u6210\u529f\uff0c\u4f46ABAP\u4ee3\u7801\u751f\u6210\u7f3a\u4e4f\u7cfb\u7edf\u5206\u6790\u3002\u672c\u7814\u7a76\u65e8\u5728\u5b9e\u8bc1\u5206\u6790LLMs\u751f\u6210\u8bed\u6cd5\u6b63\u786e\u4e14\u529f\u80fd\u6b63\u5e38\u7684ABAP\u4ee3\u7801\u7684\u80fd\u529b\uff0c\u4ee5\u53ca\u5b83\u4eec\u5229\u7528\u7f16\u8bd1\u5668\u53cd\u9988\u8fdb\u884c\u8fed\u4ee3\u6539\u8fdb\u7684\u6548\u679c\u3002", "method": "\u4f7f\u7528\u5305\u542b180\u4e2a\u4efb\u52a1\u7684\u57fa\u51c6\u6d4b\u8bd5\uff0c\u5305\u62ec\u6539\u7f16\u7684HumanEval\u4efb\u52a1\u548c\u5b9e\u9645SAP\u573a\u666f\uff0c\u8bc4\u4f30\u5404\u79cdLLMs\u751f\u6210ABAP\u4ee3\u7801\u7684\u6027\u80fd\uff0c\u5e76\u5206\u6790\u5b83\u4eec\u5229\u7528\u7f16\u8bd1\u5668\u53cd\u9988\u8fdb\u884c\u8fed\u4ee3\u6539\u8fdb\u7684\u80fd\u529b\u3002", "result": "\u6a21\u578b\u95f4\u5b58\u5728\u663e\u8457\u6027\u80fd\u5dee\u5f02\uff1a\u66f4\u5f3a\u5927\u7684LLMs\u7ecf\u8fc7\u51e0\u6b21\u8fed\u4ee3\u540e\u6210\u529f\u7387\u53ef\u8fbe75%\u5de6\u53f3\uff0c\u5e76\u80fd\u4ece\u7f16\u8bd1\u5668\u53cd\u9988\u4e2d\u5927\u5e45\u53d7\u76ca\uff1b\u800c\u8f83\u5c0f\u7684\u6a21\u578b\u8868\u73b0\u660e\u663e\u8f83\u5f31\u3002\u4e0d\u540c\u4efb\u52a1\u7c7b\u578b\u5bf9\u6a21\u578b\u6784\u6210\u7279\u6b8a\u6311\u6218\u3002", "conclusion": "\u7814\u7a76\u8868\u660e\u5f3a\u5927\u7684LLMs\u5728ABAP\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u5177\u6709\u5de8\u5927\u6f5c\u529b\uff0c\u7279\u522b\u662f\u5728\u8fed\u4ee3\u9519\u8bef\u4fee\u6b63\u65b9\u9762\uff0c\u4e3aABAP\u5f00\u53d1\u6d41\u7a0b\u7684\u81ea\u52a8\u5316\u63d0\u4f9b\u4e86\u91cd\u8981\u89c1\u89e3\u3002"}}
