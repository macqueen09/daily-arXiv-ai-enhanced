{"id": "2601.15455", "pdf": "https://arxiv.org/pdf/2601.15455", "abs": "https://arxiv.org/abs/2601.15455", "authors": ["Patrycja Balik", "Szymon J\u0119dras", "Piotr Polesiuk"], "title": "Remarks on Algebraic Reconstruction of Types and Effects", "categories": ["cs.PL"], "comment": null, "summary": "In their 1991 paper \"Algebraic Reconstruction of Types and Effects,\" Pierre Jouvelot and David Gifford presented a type-and-effect reconstruction algorithm based on an algebraic structure of effects. Their work is considered a milestone in the development of type-and-effect systems, and has inspired numerous subsequent works in the area of static analysis. However, unlike the later research it spawned, the original algorithm considered a language with higher-rank polymorphism, a feature which is challenging to implement correctly. In this note, we identify subtle bugs related to variable binding in their approach to this feature. We revisit their type system and reconstruction algorithm, and describe the discovered issues.", "AI": {"tldr": "\u8be5\u8bba\u6587\u6307\u51faJouvelot\u548cGifford 1991\u5e74\u5f00\u521b\u6027\u7c7b\u578b\u4e0e\u6548\u5e94\u91cd\u5efa\u7b97\u6cd5\u4e2d\u5b58\u5728\u4e0e\u9ad8\u9636\u591a\u6001\u6027\u76f8\u5173\u7684\u53d8\u91cf\u7ed1\u5b9a\u7ec6\u5fae\u9519\u8bef\uff0c\u5e76\u91cd\u65b0\u5ba1\u89c6\u4e86\u5176\u7c7b\u578b\u7cfb\u7edf\u548c\u91cd\u5efa\u7b97\u6cd5\u3002", "motivation": "Jouvelot\u548cGifford 1991\u5e74\u7684\u8bba\u6587\"Algebraic Reconstruction of Types and Effects\"\u88ab\u8ba4\u4e3a\u662f\u7c7b\u578b\u4e0e\u6548\u5e94\u7cfb\u7edf\u53d1\u5c55\u7684\u91cc\u7a0b\u7891\uff0c\u542f\u53d1\u4e86\u540e\u7eed\u5927\u91cf\u9759\u6001\u5206\u6790\u7814\u7a76\u3002\u7136\u800c\uff0c\u4e0e\u540e\u7eed\u7814\u7a76\u4e0d\u540c\uff0c\u539f\u59cb\u7b97\u6cd5\u8003\u8651\u4e86\u5177\u6709\u9ad8\u9636\u591a\u6001\u6027\u7684\u8bed\u8a00\uff0c\u8fd9\u4e00\u7279\u6027\u96be\u4ee5\u6b63\u786e\u5b9e\u73b0\u3002\u4f5c\u8005\u53d1\u73b0\u8be5\u7b97\u6cd5\u5728\u5904\u7406\u8fd9\u4e00\u7279\u6027\u65f6\u5b58\u5728\u53d8\u91cf\u7ed1\u5b9a\u7684\u7ec6\u5fae\u9519\u8bef\u3002", "method": "\u91cd\u65b0\u5ba1\u89c6Jouvelot\u548cGifford\u7684\u7c7b\u578b\u7cfb\u7edf\u548c\u91cd\u5efa\u7b97\u6cd5\uff0c\u8bc6\u522b\u5e76\u63cf\u8ff0\u5176\u4e2d\u4e0e\u9ad8\u9636\u591a\u6001\u6027\u76f8\u5173\u7684\u53d8\u91cf\u7ed1\u5b9a\u95ee\u9898\u3002", "result": "\u53d1\u73b0\u4e86\u539f\u59cb\u7b97\u6cd5\u4e2d\u4e0e\u53d8\u91cf\u7ed1\u5b9a\u76f8\u5173\u7684\u7ec6\u5fae\u9519\u8bef\uff0c\u8fd9\u4e9b\u9519\u8bef\u6e90\u4e8e\u5bf9\u9ad8\u9636\u591a\u6001\u6027\u5904\u7406\u7684\u590d\u6742\u6027\u3002", "conclusion": "\u867d\u7136Jouvelot\u548cGifford\u7684\u7b97\u6cd5\u662f\u7c7b\u578b\u4e0e\u6548\u5e94\u7cfb\u7edf\u7684\u91cd\u8981\u91cc\u7a0b\u7891\uff0c\u4f46\u5728\u5904\u7406\u9ad8\u9636\u591a\u6001\u6027\u65f6\u5b58\u5728\u9700\u8981\u4fee\u6b63\u7684\u7ec6\u5fae\u9519\u8bef\uff0c\u8fd9\u4e9b\u53d1\u73b0\u6709\u52a9\u4e8e\u5b8c\u5584\u8be5\u9886\u57df\u7684\u7406\u8bba\u57fa\u7840\u3002"}}
{"id": "2601.16008", "pdf": "https://arxiv.org/pdf/2601.16008", "abs": "https://arxiv.org/abs/2601.16008", "authors": ["Federico Bruzzone", "Walter Cazzola", "Luca Favini"], "title": "Prioritizing Configuration Relevance via Compiler-Based Refined Feature Ranking", "categories": ["cs.PL"], "comment": "29 pages 4 figures", "summary": "Modern programming languages, most notably Rust, offer advanced linguistic constructs for building highly configurable software systems as aggregation of features -- identified by a configuration. However, they pose substantial challenges for program analysis, optimization, and testing, as the combinatorial explosion of configurations often makes exhaustive exploration infeasible. In this manuscript, we present the first compiler-based method for prioritizing configurations. Our approach consists of four main steps: 1. extracting a tailored intermediate representation from the Rust compiler, 2. constructing two complementary graph-based data structures, 3. using centrality measures to rank features, and 4. refining the ranking by considering the extent of code they impact. A fixed number of most relevant configurations are generated based on the achieved feature ranking. The validity of the generated configurations is guaranteed by using a SAT solver that takes a representation of this graph in conjunctive normal form. We formalized this approach and implemented it in a prototype, RustyEx, by instrumenting the Rust compiler. An empirical evaluation on higher-ranked open source Rust projects shows that RustyEx efficiently generates user-specified sets of configurations within bounded resources, while ensuring soundness by construction. The results demonstrate that centrality-guided configuration prioritization enables effective and practical exploration of large configuration spaces, paving the way for future research in configuration-aware analysis and optimization.", "AI": {"tldr": "\u63d0\u51fa\u9996\u4e2a\u57fa\u4e8e\u7f16\u8bd1\u5668\u7684Rust\u914d\u7f6e\u4f18\u5148\u7ea7\u6392\u5e8f\u65b9\u6cd5\uff0c\u901a\u8fc7\u4e2d\u95f4\u8868\u793a\u63d0\u53d6\u3001\u56fe\u6570\u636e\u7ed3\u6784\u6784\u5efa\u3001\u4e2d\u5fc3\u6027\u5ea6\u91cf\u548c\u4ee3\u7801\u5f71\u54cd\u5206\u6790\u6765\u751f\u6210\u6700\u76f8\u5173\u914d\u7f6e\uff0c\u786e\u4fdd\u914d\u7f6e\u6709\u6548\u6027\u3002", "motivation": "\u73b0\u4ee3\u7f16\u7a0b\u8bed\u8a00\uff08\u7279\u522b\u662fRust\uff09\u652f\u6301\u9ad8\u5ea6\u53ef\u914d\u7f6e\u7684\u8f6f\u4ef6\u7cfb\u7edf\uff0c\u4f46\u914d\u7f6e\u7ec4\u5408\u7206\u70b8\u7ed9\u7a0b\u5e8f\u5206\u6790\u3001\u4f18\u5316\u548c\u6d4b\u8bd5\u5e26\u6765\u5de8\u5927\u6311\u6218\uff0c\u4f7f\u5f97\u7a77\u4e3e\u63a2\u7d22\u4e0d\u53ef\u884c\u3002", "method": "1. \u4eceRust\u7f16\u8bd1\u5668\u63d0\u53d6\u5b9a\u5236\u4e2d\u95f4\u8868\u793a\uff1b2. \u6784\u5efa\u4e24\u79cd\u4e92\u8865\u7684\u56fe\u6570\u636e\u7ed3\u6784\uff1b3. \u4f7f\u7528\u4e2d\u5fc3\u6027\u5ea6\u91cf\u5bf9\u7279\u5f81\u6392\u5e8f\uff1b4. \u8003\u8651\u4ee3\u7801\u5f71\u54cd\u8303\u56f4\u7ec6\u5316\u6392\u5e8f\uff1b5. \u57fa\u4e8eSAT\u6c42\u89e3\u5668\u751f\u6210\u6709\u6548\u914d\u7f6e\u3002", "result": "\u5728\u5f00\u6e90Rust\u9879\u76ee\u4e2d\uff0cRustyEx\u539f\u578b\u80fd\u5728\u6709\u9650\u8d44\u6e90\u5185\u9ad8\u6548\u751f\u6210\u7528\u6237\u6307\u5b9a\u7684\u914d\u7f6e\u96c6\uff0c\u540c\u65f6\u786e\u4fdd\u6784\u9020\u7684\u6b63\u786e\u6027\uff0c\u8bc1\u660e\u4e2d\u5fc3\u6027\u5f15\u5bfc\u7684\u914d\u7f6e\u4f18\u5148\u7ea7\u6392\u5e8f\u662f\u6709\u6548\u5b9e\u7528\u7684\u3002", "conclusion": "\u4e2d\u5fc3\u6027\u5f15\u5bfc\u7684\u914d\u7f6e\u4f18\u5148\u7ea7\u6392\u5e8f\u5b9e\u73b0\u4e86\u5927\u578b\u914d\u7f6e\u7a7a\u95f4\u7684\u6709\u6548\u63a2\u7d22\uff0c\u4e3a\u914d\u7f6e\u611f\u77e5\u5206\u6790\u548c\u4f18\u5316\u7684\u672a\u6765\u7814\u7a76\u94fa\u5e73\u4e86\u9053\u8def\u3002"}}
{"id": "2601.15294", "pdf": "https://arxiv.org/pdf/2601.15294", "abs": "https://arxiv.org/abs/2601.15294", "authors": ["Elif Uskuplu", "Lawrence S. Moss", "Valeria de Paiva"], "title": "KnowTeX: Visualizing Mathematical Dependencies", "categories": ["cs.HC", "cs.IR", "cs.PL"], "comment": null, "summary": "Mathematical knowledge exists in many forms, ranging from informal textbooks and lecture notes to large formal proof libraries, yet moving between these representations remains difficult. Informal texts hide dependencies, while formal systems expose every detail in ways that are not always human-readable. Dependency graphs offer a middle ground by making visible the structure of results, definitions, and proofs. We present KnowTeX, a standalone, user-friendly tool that extends the ideas of Lean's Blueprints, enabling the visualization of conceptual dependencies directly from LaTeX sources. Using a simple \"uses\" command, KnowTeX extracts relationships among statements and generates previewable graphs in DOT and TikZ formats. Applied to mathematical texts, such graphs clarify core results, support education and formalization, and provide a resource for aligning informal and formal mathematical representations. We argue that dependency graphs should become a standard feature of mathematical writing, benefiting both human readers and automated systems.", "AI": {"tldr": "KnowTeX\u662f\u4e00\u4e2a\u4eceLaTeX\u6e90\u7801\u63d0\u53d6\u6570\u5b66\u9648\u8ff0\u4f9d\u8d56\u5173\u7cfb\u5e76\u751f\u6210\u53ef\u89c6\u5316\u4f9d\u8d56\u56fe\u7684\u5de5\u5177\uff0c\u4e3a\u6570\u5b66\u5199\u4f5c\u63d0\u4f9b\u4e2d\u95f4\u8868\u793a\u5f62\u5f0f\u3002", "motivation": "\u6570\u5b66\u77e5\u8bc6\u5b58\u5728\u591a\u79cd\u5f62\u5f0f\uff08\u4ece\u975e\u6b63\u5f0f\u6559\u6750\u5230\u5f62\u5f0f\u5316\u8bc1\u660e\u5e93\uff09\uff0c\u4f46\u8fd9\u4e9b\u8868\u793a\u4e4b\u95f4\u7684\u8f6c\u6362\u5f88\u56f0\u96be\u3002\u975e\u6b63\u5f0f\u6587\u672c\u9690\u85cf\u4f9d\u8d56\u5173\u7cfb\uff0c\u800c\u5f62\u5f0f\u5316\u7cfb\u7edf\u66b4\u9732\u8fc7\u591a\u7ec6\u8282\u4e14\u4e0d\u6613\u9605\u8bfb\u3002\u4f9d\u8d56\u56fe\u53ef\u4ee5\u63d0\u4f9b\u4e2d\u95f4\u8868\u793a\uff0c\u4f7f\u7ed3\u679c\u3001\u5b9a\u4e49\u548c\u8bc1\u660e\u7684\u7ed3\u6784\u53ef\u89c6\u5316\u3002", "method": "\u5f00\u53d1KnowTeX\u5de5\u5177\uff0c\u6269\u5c55Lean Blueprints\u7684\u601d\u60f3\uff0c\u76f4\u63a5\u4eceLaTeX\u6e90\u7801\u4e2d\u63d0\u53d6\u4f9d\u8d56\u5173\u7cfb\u3002\u901a\u8fc7\u7b80\u5355\u7684\"uses\"\u547d\u4ee4\u63d0\u53d6\u9648\u8ff0\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u5e76\u751f\u6210DOT\u548cTikZ\u683c\u5f0f\u7684\u53ef\u9884\u89c8\u4f9d\u8d56\u56fe\u3002", "result": "KnowTeX\u80fd\u591f\u5e94\u7528\u4e8e\u6570\u5b66\u6587\u672c\uff0c\u751f\u6210\u7684\u4f9d\u8d56\u56fe\u53ef\u4ee5\u6f84\u6e05\u6838\u5fc3\u7ed3\u679c\u3001\u652f\u6301\u6559\u80b2\u548c\u5f62\u5f0f\u5316\u5de5\u4f5c\uff0c\u5e76\u4e3a\u5bf9\u9f50\u975e\u6b63\u5f0f\u548c\u5f62\u5f0f\u5316\u6570\u5b66\u8868\u793a\u63d0\u4f9b\u8d44\u6e90\u3002", "conclusion": "\u4f9d\u8d56\u56fe\u5e94\u8be5\u6210\u4e3a\u6570\u5b66\u5199\u4f5c\u7684\u6807\u51c6\u529f\u80fd\uff0c\u65e2\u6709\u5229\u4e8e\u4eba\u7c7b\u8bfb\u8005\uff0c\u4e5f\u6709\u5229\u4e8e\u81ea\u52a8\u5316\u7cfb\u7edf\u3002KnowTeX\u4e3a\u5b9e\u73b0\u8fd9\u4e00\u76ee\u6807\u63d0\u4f9b\u4e86\u5b9e\u7528\u5de5\u5177\u3002"}}
{"id": "2601.15335", "pdf": "https://arxiv.org/pdf/2601.15335", "abs": "https://arxiv.org/abs/2601.15335", "authors": ["Yi Zhai", "Dian Shen", "Junzhou Luo", "Bin Yang"], "title": "ToolCaching: Towards Efficient Caching for LLM Tool-calling", "categories": ["cs.SE", "cs.AI", "cs.PL"], "comment": null, "summary": "Recent advances in Large Language Models (LLMs) have revolutionized web applications, enabling intelligent search, recommendation, and assistant services with natural language interfaces. Tool-calling extends LLMs with the ability to interact with external APIs, greatly enhancing their practical utility. While prior research has improved tool-calling performance by adopting traditional computer systems techniques, such as parallel and asynchronous execution, the challenge of redundant or repeated tool-calling requests remains largely unaddressed. Caching is a classic solution to this problem, but applying it to LLM tool-calling introduces new difficulties due to heterogeneous request semantics, dynamic workloads, and varying freshness requirements, which render conventional cache policies ineffective. To address these issues, we propose ToolCaching, an efficient feature-driven and adaptive caching framework for LLM tool-calling systems. ToolCaching systematically integrates semantic and system-level features to evaluate request cacheability and estimate caching value. At its core, the VAAC algorithm integrates bandit-based admission with value-driven, multi-factor eviction, jointly accounting for request frequency, recency, and caching value. Extensive experiments on synthetic and public tool-calling workloads demonstrate that ToolCaching with VAAC achieves up to 11% higher cache hit ratios and 34% lower latency compared to standard policies, effectively accelerating LLM tool-calling in practical applications.", "AI": {"tldr": "ToolCaching\uff1a\u9488\u5bf9LLM\u5de5\u5177\u8c03\u7528\u7cfb\u7edf\u7684\u7279\u5f81\u9a71\u52a8\u81ea\u9002\u5e94\u7f13\u5b58\u6846\u67b6\uff0c\u901a\u8fc7VAAC\u7b97\u6cd5\u63d0\u9ad8\u7f13\u5b58\u547d\u4e2d\u7387\u5e76\u964d\u4f4e\u5ef6\u8fdf", "motivation": "LLM\u5de5\u5177\u8c03\u7528\u7cfb\u7edf\u4e2d\u5b58\u5728\u5197\u4f59\u6216\u91cd\u590d\u7684\u5de5\u5177\u8c03\u7528\u8bf7\u6c42\u95ee\u9898\uff0c\u4f20\u7edf\u7f13\u5b58\u7b56\u7565\u56e0\u8bf7\u6c42\u8bed\u4e49\u5f02\u6784\u3001\u52a8\u6001\u5de5\u4f5c\u8d1f\u8f7d\u548c\u4e0d\u540c\u65b0\u9c9c\u5ea6\u8981\u6c42\u800c\u5931\u6548\uff0c\u9700\u8981\u4e13\u95e8\u89e3\u51b3\u65b9\u6848", "method": "\u63d0\u51faToolCaching\u6846\u67b6\uff0c\u96c6\u6210\u8bed\u4e49\u548c\u7cfb\u7edf\u7ea7\u7279\u5f81\u8bc4\u4f30\u8bf7\u6c42\u53ef\u7f13\u5b58\u6027\u548c\u7f13\u5b58\u4ef7\u503c\uff1b\u6838\u5fc3VAAC\u7b97\u6cd5\u7ed3\u5408\u57fa\u4e8ebandit\u7684\u51c6\u5165\u548c\u57fa\u4e8e\u4ef7\u503c\u7684\u591a\u56e0\u7d20\u6dd8\u6c70\u7b56\u7565", "result": "\u5728\u5408\u6210\u548c\u516c\u5f00\u5de5\u5177\u8c03\u7528\u5de5\u4f5c\u8d1f\u8f7d\u4e0a\uff0cToolCaching\u76f8\u6bd4\u6807\u51c6\u7b56\u7565\u5b9e\u73b0\u9ad8\u8fbe11%\u7684\u7f13\u5b58\u547d\u4e2d\u7387\u63d0\u5347\u548c34%\u7684\u5ef6\u8fdf\u964d\u4f4e", "conclusion": "ToolCaching\u80fd\u6709\u6548\u52a0\u901fLLM\u5de5\u5177\u8c03\u7528\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u7684\u6027\u80fd\uff0c\u89e3\u51b3\u4e86\u4f20\u7edf\u7f13\u5b58\u7b56\u7565\u5728LLM\u5de5\u5177\u8c03\u7528\u573a\u666f\u4e2d\u7684\u5c40\u9650\u6027"}}
