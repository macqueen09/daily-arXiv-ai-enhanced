<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]
- [cs.AI](#cs.AI) [Total: 1]
- [cs.LO](#cs.LO) [Total: 1]
- [cs.SE](#cs.SE) [Total: 2]
- [cs.DC](#cs.DC) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Grammar-Aware Literate Generative Mathematical Programming with Compiler-in-the-Loop](https://arxiv.org/abs/2601.17670)
*Roberto Rossi,Steven D. Prestwich*

Main category: cs.PL

TL;DR: SyntAGM是一个端到端系统，通过生成-编译-评估-修订循环，将自然语言问题描述转换为PyOPL数学模型，利用编译器反馈和LLM对齐判断实现高效准确的模型合成。


<details>
  <summary>Details</summary>
Motivation: 研究生成式数学编程，探索如何通过代数建模语言和编译器引导的模型合成，将自然语言问题描述自动转换为可执行的数学模型，提高数学建模的效率和可访问性。

Method: 开发SyntAGM系统，基于PyOPL代数建模语言编译器，采用生成-编译-评估-修订循环。系统具有语法感知能力（通过BNF语法上下文学习），利用少量示例检索，结合编译器反馈和基于LLM的对齐判断来优化模型生成。

Result: 与现有提示基准相比，SyntAGM在准确性方面表现相当，同时在token使用、成本和延迟方面具有显著优势，实现了更高效的模型合成。

Conclusion: SyntAGM展示了编译器引导的模型合成方法的有效性，将代数建模语言与LLM结合，能够高效准确地将自然语言问题描述转换为数学模型，为生成式数学编程提供了有前景的解决方案。

Abstract: This work investigates generative mathematical programming through the lens of Algebraic Modelling Languages (AMLs) and compiler-guided model synthesis. By leveraging PyOPL, an OPL-like AML compiler that provides detailed syntax diagnostics, we introduce SyntAGM, an end-to-end system that translates natural language problem descriptions into PyOPL models via a generate--compile--assess--revise loop. SyntAGM is grammar-aware thanks to in-context exposure to the PyOPL BNF grammar, and benefits from few-shot retrieval of literate PyOPL model exemplars. To obtain a valid PyOPL model that matches the problem description, SyntAGM mobilises compiler feedback and an LLM-based alignment judge. In a comparative study against established prompting baselines SyntAGM achieves competitive accuracy with superior token, cost, and latency profiles.

</details>


### [2] [Types for Grassroots Logic Programs](https://arxiv.org/abs/2601.17957)
*Ehud Shapiro*

Main category: cs.PL

TL;DR: 该论文提出了Typed GLP（类型化Grassroots Logic Programs），为并发逻辑编程语言GLP引入了基于模态路径的类型系统，以支持AI辅助编程中的复杂通信模式验证。


<details>
  <summary>Details</summary>
Motivation: GLP作为并发逻辑编程语言，支持丰富的多向通信模式，但缺乏类型系统。在AI辅助编程的背景下，让AI直接编写复杂的GLP通信代码风险较高。因此需要建立类型系统，使人类设计师和AI能够基于类型规范协同开发。

Method: 1. 将类型定义为模态路径的正则集合，模态捕获通信方向性（消费或生产）；2. 提供语法上的良类型定义；3. 证明程序良类型当且仅当其模态原子语义的路径抽象满足协变和逆变条件；4. 通过AI从数学规范推导英文规范，再生成Dart实现。

Result: 1. 建立了GLP的类型系统，能够类型化交互式部分计算（包括死锁、失败或永不终止的程序）；2. 实现了类型系统到Dart代码的AI驱动转换；3. 提出了人机协同的编程流程：先定义类型和过程类型声明，再让AI基于这些规范编写代码。

Conclusion: Typed GLP为并发逻辑编程提供了形式化的类型系统，特别适用于AI辅助编程场景。通过类型规范约束AI代码生成，提高了复杂通信模式编程的可靠性和可协作性，为人机协同软件开发提供了方法论框架。

Abstract: Grassroots Logic Programs (GLP) is a concurrent logic programming language in which logic variables are partitioned into paired readers and writers. An assignment is produced at most once via a writer and consumed at most once via its paired reader, and may contain additional readers and/or writers. This enables the concise expression of rich multidirectional communication modalities.
  ``Logic Programs as Types for Logic Programs'' (LICS'91) defined types as regular sets of paths over derivable ground atoms. Here, we define types to be regular sets of moded paths, where a mode captures directionality of communication -- whether a subterm is consumed from or produced to the environment -- enabling the typing of interactive partial computations including those that eventually deadlock or fail, or never terminate. We provide a syntactic definition of well-typing and prove that a program is well-typed iff the path abstraction of its moded-atom semantics satisfies covariance and contravariance conditions with respect to its type.
  The GLP type system was implemented in Dart by AI, starting from a mathematical specification of Typed GLP (this paper), deriving from it an English spec (written by AI), and from the spec deriving Dart code (by AI). While GLP is naturally untyped, the motivation for Typed GLP comes from programming with AI: Asking AI to program complex communication modalities in GLP (and in general) and hoping for the best is a tenuous strategy. The emerging discipline we advocate and employ is for the human designer and AI to jointly develop and agree upon (1)~GLP types; (2)~GLP procedure type declarations; (3)~informal (English) descriptions of the procedures; and only then let AI attempt to write (4)~GLP code based on those.

</details>


### [3] [Handling Scope Checks (Extended Version)](https://arxiv.org/abs/2601.18793)
*Michael Lee,Ningning Xie,Oleg Kiselyov,Jeremy Yallop*

Main category: cs.PL

TL;DR: 本文首次形式化研究动态作用域外泄检查，提出了λ⟨⟨op⟩⟩演算来描述和评估检查，并引入新颖的"Cause-for-Concern"动态检查，证明其正确性，并与静态类型系统比较表达能力。


<details>
  <summary>Details</summary>
Motivation: 元编程和效应处理器的交互会产生意外且不良的结果，如作用域外泄（生成错误作用域的代码）。静态类型系统存在理论和实践问题，而动态检查在实践中存在但缺乏理论研究，导致元语言设计者缺乏指导。

Method: 1) 提出λ⟨⟨op⟩⟩演算形式化框架；2) 引入新颖的"Cause-for-Concern"动态检查；3) 证明该检查的正确性；4) 扩展框架加入精化环境分类器进行静态预防；5) 比较动态检查与静态系统的表达能力。

Result: 1) 建立了首个动态作用域外泄检查的形式化理论框架；2) 提出的"Cause-for-Concern"检查被证明正确且结合了现有动态检查的优点；3) 展示了动态检查与静态系统在表达能力上的比较结果。

Conclusion: 本文填补了动态作用域外泄检查理论研究的空白，为元语言设计者提供了形式化指导，提出的新检查方法在实践中具有优势，并建立了动态与静态方法之间的理论联系。

Abstract: Metaprogramming and effect handlers interact in unexpected, and sometimes undesirable, ways. One example is scope extrusion: the generation of ill-scoped code. Scope extrusion can either be preemptively prevented, via static type systems, or retroactively detected, via dynamic checks. Static type systems exist in theory, but struggle with a range of implementation and usability problems in practice. In contrast, dynamic checks exist in practice (e.g. in MetaOCaml), but are understudied in theory. Designers of metalanguages are thus given little guidance regarding the design and implementation of checks. We present the first formal study of dynamic scope extrusion checks, introducing a calculus ($λ_{\langle\langle\text{op}\rangle\rangle}$) for describing and evaluating checks. Further, we introduce a novel dynamic check $\unicode{x2014}$ the "Cause-for-Concern" check $\unicode{x2014}$ which we prove correct, characterise without reference to its implementation, and argue combines the advantages of existing dynamic checks. Finally, we extend our framework with refined environment classifiers, which statically prevent scope extrusion, and compare their expressivity with the dynamic checks.

</details>


<div id='cs.AI'></div>

# cs.AI [[Back]](#toc)

### [4] [EvolVE: Evolutionary Search for LLM-based Verilog Generation and Optimization](https://arxiv.org/abs/2601.18067)
*Wei-Po Hsin,Ren-Hao Deng,Yao-Ting Hsieh,En-Ming Huang,Shih-Hao Hung*

Main category: cs.AI

TL;DR: EvolVE框架通过多种进化策略（MCTS和IGR）和结构化测试平台生成，在Verilog硬件设计自动化中实现SOTA性能，显著提升功能正确性和PPA优化。


<details>
  <summary>Details</summary>
Motivation: Verilog设计流程劳动密集且需要专业领域知识，现有LLM方法因训练数据有限和顺序推理能力不足，难以处理硬件系统的严格形式逻辑和并发特性。

Method: 提出EvolVE框架，分析多种进化策略：MCTS用于最大化功能正确性，IGR用于优化；采用结构化测试平台生成加速进化过程；引入IC-RTL基准测试套件评估工业级问题。

Result: 在VerilogEval v2达到98.1%，RTLLM v2达到92%；在IC-RTL工业级基准上超越竞赛参与者实现，Huffman编码PPA降低66%，所有问题几何平均PPA降低17%。

Conclusion: EvolVE框架通过进化策略和结构化测试平台生成，成功解决了LLM在硬件设计中的局限性，实现了硬件设计自动化的新SOTA，并在工业级问题上展示了显著优化效果。

Abstract: Verilog's design cycle is inherently labor-intensive and necessitates extensive domain expertise. Although Large Language Models (LLMs) offer a promising pathway toward automation, their limited training data and intrinsic sequential reasoning fail to capture the strict formal logic and concurrency inherent in hardware systems. To overcome these barriers, we present EvolVE, the first framework to analyze multiple evolution strategies on chip design tasks, revealing that Monte Carlo Tree Search (MCTS) excels at maximizing functional correctness, while Idea-Guided Refinement (IGR) proves superior for optimization. We further leverage Structured Testbench Generation (STG) to accelerate the evolutionary process. To address the lack of complex optimization benchmarks, we introduce IC-RTL, targeting industry-scale problems derived from the National Integrated Circuit Contest. Evaluations establish EvolVE as the new state-of-the-art, achieving 98.1% on VerilogEval v2 and 92% on RTLLM v2. Furthermore, on the industry-scale IC-RTL suite, our framework surpasses reference implementations authored by contest participants, reducing the Power, Performance, Area (PPA) product by up to 66% in Huffman Coding and 17% in the geometric mean across all problems. The source code of the IC-RTL benchmark is available at https://github.com/weiber2002/ICRTL.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [5] [Symmetric Proofs of Parameterized Programs](https://arxiv.org/abs/2601.18745)
*Ruotong Cheng,Azadeh Farzan*

Main category: cs.LO

TL;DR: 提出参数化证明空间系统，用于验证基于丰富拓扑结构的无限状态参数化程序的安全性，利用局部对称性重用证明，并给出算法构造和决策条件。


<details>
  <summary>Details</summary>
Motivation: 解决基于复杂拓扑结构的无限状态参数化程序的安全验证问题，传统方法难以处理这类程序的对称性和参数化特性。

Method: 引入参数化证明空间系统，利用程序的局部对称性重用证明论证；提出基于模型论启发的构造方法，通过无限极限程序进行验证；无需对底层拓扑进行公理化。

Result: 证明了证明系统相对于一类全称量化不变量的相对完备性；展示了如何构造和检查证明；给出了算法成为决策程序的条件。

Conclusion: 参数化证明空间系统为验证基于拓扑结构的参数化程序提供了有效框架，能够利用对称性简化验证过程，并在特定条件下成为决策程序。

Abstract: We investigate the problem of safety verification of infinite-state parameterized programs that are formed based on a rich class of topologies. We introduce a new proof system, called parametric proof spaces, which exploits the underlying symmetry in such programs. This is a local notion of symmetry which enables the proof system to reuse proof arguments for isomorphic neighbourhoods in program topologies. We prove a sophisticated relative completeness result for the proof system with respect to a class of universally quantified invariants. We also investigate the problem of algorithmic construction of these proofs. We present a construction, inspired by classic results in model theory, where an infinitary limit program can be soundly and completely verified in place of the parameterized family, under some conditions. Furthermore, we demonstrate how these proofs can be constructed and checked against these programs without the need for axiomatization of the underlying topology for proofs or the programs. Finally, we present conditions under which our algorithm becomes a decision procedure.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [6] [YASA: Scalable Multi-Language Taint Analysis on the Unified AST at Ant Group](https://arxiv.org/abs/2601.17390)
*Yayi Wang,Shenao Wang,Jian Zhao,Shaosen Shi,Ting Li,Yan Cheng,Lizhong Bian,Kan Yu,Yanjie Zhao,Haoyu Wang*

Main category: cs.SE

TL;DR: YASA是一个统一的多语言静态污点分析框架，通过统一抽象语法树(UAST)支持多种编程语言，在工业规模基准测试中优于现有工具，并在蚂蚁集团实际部署中发现了大量未知漏洞。


<details>
  <summary>Details</summary>
Motivation: 现代企业采用多种编程语言技术栈，现有静态应用安全测试(SAST)工具多为单语言设计，多语言工具在中间表示设计、分析精度和可扩展性方面存在限制，难以满足蚂蚁集团大规模工业应用的需求。

Method: 提出YASA框架，引入统一抽象语法树(UAST)提供跨语言兼容性抽象；基于UAST进行指针分析和污点传播，利用统一语义模型处理语言无关结构，同时结合语言特定语义模型处理独特语言特性。

Result: 在行业标准基准测试中，YASA在Java、JavaScript、Python和Go上均优于6个单语言和2个多语言静态分析器；在蚂蚁集团实际部署中，分析了超过1亿行代码，发现了314条未知污点路径，其中92条被确认为0-day漏洞，76个已修复。

Conclusion: YASA是一个有效的工业级多语言静态污点分析框架，能够在大规模工业软件系统中实际应用，显著提升安全测试的覆盖范围和效果。

Abstract: Modern enterprises increasingly adopt diverse technology stacks with various programming languages, posing significant challenges for static application security testing (SAST). Existing taint analysis tools are predominantly designed for single languages, requiring substantial engineering effort that scales with language diversity. While multi-language tools like CodeQL, Joern, and WALA attempt to address these challenges, they face limitations in intermediate representation design, analysis precision, and extensibility, which make them difficult to scale effectively for large-scale industrial applications at Ant Group. To bridge this gap, we present YASA (Yet Another Static Analyzer), a unified multi-language static taint analysis framework designed for industrial-scale deployment. Specifically, YASA introduces the Unified Abstract Syntax Tree (UAST) that provides a unified abstraction for compatibility across diverse programming languages. Building on the UAST, YASA performs point-to analysis and taint propagation, leveraging a unified semantic model to manage language-agnostic constructs, while incorporating language-specific semantic models to handle other unique language features. When compared to 6 single- and 2 multi-language static analyzers on an industry-standard benchmark, YASA consistently outperformed all baselines across Java, JavaScript, Python, and Go. In real-world deployment within Ant Group, YASA analyzed over 100 million lines of code across 7.3K internal applications. It identified 314 previously unknown taint paths, with 92 of them confirmed as 0-day vulnerabilities. All vulnerabilities were responsibly reported, with 76 already patched by internal development teams, demonstrating YASA's practical effectiveness for securing large-scale industrial software systems.

</details>


### [7] [iResolveX: Multi-Layered Indirect Call Resolution via Static Reasoning and Learning-Augmented Refinement](https://arxiv.org/abs/2601.17888)
*Monika Santra,Bokai Zhang,Mark Lim,Vishnu Asutosh Dasu,Dongrui Zeng,Gang Tan*

Main category: cs.SE

TL;DR: iResolveX是一个混合多层框架，结合保守静态分析和学习型精化，用于间接调用解析，在保持高召回率的同时显著减少误报。


<details>
  <summary>Details</summary>
Motivation: 间接调用解析是逆向工程和控制流图恢复的关键挑战。静态分析虽然完备但会产生大量误报，而机器学习方法虽然能提高精度但可能牺牲完备性和泛化能力。需要一种能平衡精度和召回率的解决方案。

Method: iResolveX采用三层混合框架：第一层应用保守的值集分析(BPA)确保高召回率；第二层添加学习型软签名评分器(iScoreGen)和选择性过程间向后分析(iScoreRefine)来减少误报；最终输出p-IndirectCFG为间接边标注置信度分数。

Result: 在SPEC CPU2006和真实二进制文件上，iScoreGen平均减少19.2%的预测目标，同时保持98.2%的BPA级召回率。结合iScoreRefine后，总减少率达到44.3%，召回率为97.8%（仅下降0.4%）。iResolveX支持保守和F1优化配置，优于现有最先进系统。

Conclusion: iResolveX通过结合保守静态分析和学习型精化的混合方法，在间接调用解析中实现了精度和召回率的良好平衡，为下游分析提供了灵活的精度-召回率权衡选择。

Abstract: Indirect call resolution remains a key challenge in reverse engineering and control-flow graph recovery, especially for stripped or optimized binaries. Static analysis is sound but often over-approximates, producing many false positives, whereas machine-learning approaches can improve precision but may sacrifice completeness and generalization. We present iResolveX, a hybrid multi-layered framework that combines conservative static analysis with learning-based refinement. The first layer applies a conservative value-set analysis (BPA) to ensure high recall. The second layer adds a learning-based soft-signature scorer (iScoreGen) and selective inter-procedural backward analysis with memory inspection (iScoreRefine) to reduce false positives. The final output, p-IndirectCFG, annotates indirect edges with confidence scores, enabling downstream analyses to choose appropriate precision--recall trade-offs. Across SPEC CPU2006 and real-world binaries, iScoreGen reduces predicted targets by 19.2% on average while maintaining BPA-level recall (98.2%). Combined with iScoreRefine, the total reduction reaches 44.3% over BPA with 97.8% recall (a 0.4% drop). iResolveX supports both conservative, recall-preserving and F1-optimized configurations and outperforms state-of-the-art systems.

</details>


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [8] [An MLIR Lowering Pipeline for Stencils at Wafer-Scale](https://arxiv.org/abs/2601.17754)
*Nicolai Stawinoga,David Katz,Anton Lydike,Justs Zarins,Nick Brown,George Bisbas,Tobias Grosser*

Main category: cs.DC

TL;DR: 本文提出了一种编译器流水线，能够自动将stencil计算转换为针对Cerebras WSE优化的代码，无需修改应用层代码，性能优于手动优化代码，并在WSE3上比128个Nvidia A100 GPU快14倍。


<details>
  <summary>Details</summary>
Motivation: Cerebras WSE虽然性能强大，但其分布式异步编程模型与传统顺序或BSP程序差异巨大，移植现有代码需要定制化重写。由于MLIR等编译器缺乏WSE支持，自动化这一过程几乎不可能。Stencil计算在HPC中普遍存在，作者假设可以利用其领域特定信息来自动化WSE目标代码生成。

Method: 提出一个编译器流水线，利用stencil计算的领域特定信息，将stencil内核自动转换为高度优化的CSL（Cerebras Software Language）代码。该流水线弥合了问题数学表示与WSE异步执行模型之间的语义鸿沟，支持多种HPC编程技术。

Result: 基于5个基准测试和3种HPC编程技术，在WSE2和WSE3上运行，该方法性能与手动优化代码相当甚至略优。更重要的是，无需应用层代码修改，在WSE3上的性能比128个Nvidia A100 GPU快约14倍，比128个CPU节点的Cray-EX超算快20倍。

Conclusion: 通过利用stencil计算的领域特定信息，可以开发出能够自动为Cerebras WSE生成优化代码的编译器，无需手动重写应用代码，同时实现卓越性能，证明了领域特定编译在弥合新型硬件架构与传统编程模型之间差距方面的有效性。

Abstract: The Cerebras Wafer-Scale Engine (WSE) delivers performance at an unprecedented scale of over 900,000 compute units, all connected via a single-wafer on-chip interconnect. Initially designed for AI, the WSE architecture is also well-suited for High Performance Computing (HPC). However, its distributed asynchronous programming model diverges significantly from the simple sequential or bulk-synchronous programs that one would typically derive for a given mathematical program description. Targeting the WSE requires a bespoke re-implementation when porting existing code. The absence of WSE support in compilers such as MLIR, meant that there was little hope for automating this process.
  Stencils are ubiquitous in HPC, and in this paper we explore the hypothesis that domain specific information about stencils can be leveraged by the compiler to automatically target the WSE without requiring application-level code changes. We present a compiler pipeline that transforms stencil-based kernels into highly optimized CSL code for the WSE, bridging the semantic gap between the mathematical representation of the problem and the WSE's asynchronous execution model. Based upon five benchmarks across three HPC programming technologies, running on both the Cerebras WSE2 and WSE3, our approach delivers comparable, if not slightly better, performance than manually optimized code. Furthermore, without requiring any application level code changes, performance on the WSE3 is around 14 times faster than 128 Nvidia A100 GPUs and 20 times faster than 128 nodes of a CPU-based Cray-EX supercomputer when using our approach.

</details>
