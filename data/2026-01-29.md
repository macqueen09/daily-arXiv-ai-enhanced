<div id=toc></div>

# Table of Contents

- [cs.LO](#cs.LO) [Total: 1]
- [cs.DB](#cs.DB) [Total: 1]
- [cs.AR](#cs.AR) [Total: 1]


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [1] [A Program Logic for Abstract (Hyper)Properties](https://arxiv.org/abs/2601.20370)
*Paolo Baldan,Roberto Bruni,Francesco Ranzato,Diletta Rigo*

Main category: cs.LO

TL;DR: APPL是一种统一的霍尔风格逻辑，它包含了标准霍尔逻辑、不正确性逻辑和多种超霍尔逻辑变体，为基于抽象域的抽象程序逻辑提供了理论基础。


<details>
  <summary>Details</summary>
Motivation: 现有程序逻辑（如霍尔逻辑、不正确性逻辑、超霍尔逻辑）各自独立发展，缺乏统一的框架。需要一种能够统一这些逻辑并支持抽象域参数化的理论基础，以涵盖现有和新型的程序属性及超属性抽象。

Method: 基于语义框架，首先在格基础上定义命令语义，然后通过可加性扩展到完整格。关键创新是使用非幂等且不一定与格并操作一致的单子运算符来解释非确定性选择，从而能够捕捉收集语义、各类抽象语义和超语义。

Result: APPL证明系统是可靠的，当属性语言足够表达时具有相对完备性。当属性语言限制在抽象域时，得到基于最佳正确近似的可靠抽象演绎系统。如果抽象域对单子运算符是完备的，则能恢复相对于相应抽象语义的相对完备性。

Conclusion: APPL为抽象程序逻辑提供了统一的理论基础，能够参数化地支持多种现有和新型的程序属性及超属性抽象，建立了抽象解释与程序逻辑之间的桥梁。

Abstract: We introduce APPL (Abstract Program Property Logic), a unifying Hoare-style logic that subsumes standard Hoare logic, incorrectness logic, and several variants of Hyper Hoare logic. APPL provides a principled foundation for abstract program logics parameterised by an abstract domain, encompassing both existing and novel abstractions of properties and hyperproperties. The logic is grounded in a semantic framework where the meaning of commands is first defined on a lattice basis and then extended to the full lattice via additivity. Crucially, nondeterministic choice is interpreted by a monoidal operator that need not be idempotent nor coincide with the lattice join. This flexibility allows the framework to capture collecting semantics, various classes of abstract semantics, and hypersemantics. The APPL proof system is sound, and it is relatively complete whenever the property language is sufficiently expressive. When the property language is restricted to an abstract domain, the result is a sound abstract deduction system based on best correct approximations. Relative completeness with respect to a corresponding abstract semantics is recovered provided the abstract domain is complete, in the sense of abstract interpretation, for the monoidal operator.

</details>


<div id='cs.DB'></div>

# cs.DB [[Back]](#toc)

### [2] [The Monotone Priority System: Foundations of Contract-Specific Sequencing](https://arxiv.org/abs/2601.20783)
*Naveen Durvasula*

Main category: cs.DB

TL;DR: 提出基于全局优先级的智能合约调用排序系统，通过五条公理证明其唯一性


<details>
  <summary>Details</summary>
Motivation: 现代区块链应用需要为交易设置排序约束，但需要在表达能力和区块生产的可处理性之间取得平衡

Method: 允许合约开发者为每个函数调用设置整数全局优先级，要求调用优先级不高于其引用的任何调用优先级，区块生产者按优先级从高到低排序交易

Result: 该系统是满足五条独立公理的唯一系统

Conclusion: 提出的优先级排序系统在表达性和区块生产可处理性之间取得了良好平衡，并通过公理化方法证明了其唯一性

Abstract: Modern blockchain applications benefit from the ability to specify sequencing constraints on the transactions that interact with them. This paper proposes a principled and axiomatically justified way of adding sequencing constraints on smart contract function calls that balances expressivity with the tractability of block production. Specifically, we propose a system in which contract developers are allowed to set an integer global priority for each of their calls, so long as that the call's chosen priority is no higher than the priority of any of its referenced calls. Block builders must then simply sequence transactions in priority order (from high to low priority), breaking ties however they would like. We show that this system is the unique system that satisfies five independent axioms.

</details>


<div id='cs.AR'></div>

# cs.AR [[Back]](#toc)

### [3] [Bench4HLS: End-to-End Evaluation of LLMs in High-Level Synthesis Code Generation](https://arxiv.org/abs/2601.19941)
*M Zafir Sadik Khan,Kimia Azar,Hadi Kamali*

Main category: cs.AR

TL;DR: Bench4HLS：首个专门评估LLM生成HLS设计的综合基准框架，包含170个测试案例，支持自动化编译、功能验证和PPA分析。


<details>
  <summary>Details</summary>
Motivation: 随着LLM在硬件设计中的应用增长，特别是HLS领域的关注度提升（HLS与RTL研究比例从1:10增至2:10），需要专门针对LLM生成HLS设计的评估框架来推动该领域发展。

Method: 构建包含170个手动编写和验证的测试案例库，涵盖从简单内核到复杂加速器的各种设计。框架支持自动化编译评估、功能正确性仿真验证、综合可行性分析，并集成了可插拔API用于跨不同HLS工具链和架构的PPA分析。

Result: 开发了Bench4HLS框架，已在Xilinx Vitis HLS上演示，并在Catapult HLS上验证。提供了结构化、可扩展的即插即用测试平台。

Conclusion: Bench4HLS为LLM在HLS工作流程中的基准测试建立了基础方法论，有助于推动LLM在高级设计入口中的应用，同时依赖下游综合进行优化。

Abstract: In last two years, large language models (LLMs) have shown strong capabilities in code generation, including hardware design at register-transfer level (RTL). While their use in high-level synthesis (HLS) remains comparatively less mature, the ratio of HLS- to RTL-focused studies has shifted from 1:10 to 2:10 in the past six months, indicating growing interest in leveraging LLMs for high-level design entry while relying on downstream synthesis for optimization. This growing trend highlights the need for a comprehensive benchmarking and evaluation framework dedicated to LLM-based HLS. To address this, We present Bench4HLS for evaluating LLM-generated HLS designs. Bench4HLS comprises 170 manually drafted and validated case studies, spanning small kernels to complex accelerators, curated from widely used public repositories. The framework supports fully automated assessment of compilation success, functional correctness via simulation, and synthesis feasibility/optimization. Crucially, Bench4HLS integrates a pluggable API for power, performance, and area (PPA) analysis across various HLS toolchains and architectures, demonstrated here with Xilinx Vitis HLS and validated on Catapult HLS. By providing a structured, extensible, and plug-and-play testbed, Bench4HLS establishes a foundational methodology for benchmarking LLMs in HLS workflows.

</details>
