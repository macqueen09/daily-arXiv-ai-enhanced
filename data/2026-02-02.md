<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.CR](#cs.CR) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Recursive Mutexes in Separation Logic](https://arxiv.org/abs/2601.22557)
*Ke Du,William Mansky,Paolo G. Giarrusso,Gregory Malecha*

Main category: cs.PL

TL;DR: 该论文为递归互斥锁（recursive mutexes）开发了分离逻辑规范，类似于普通互斥锁的两种规范风格：保护不变式或原子改变锁状态。


<details>
  <summary>Details</summary>
Motivation: 递归互斥锁在C++、Java等面向对象语言中很常见，但现有的分离逻辑规范主要针对普通互斥锁。需要为递归互斥锁开发类似的规范，以支持同一线程多次获取锁的情况。

Method: 采用分离逻辑方法，为递归互斥锁开发两种规范风格：一种是基于保护不变式的规范，另一种是基于原子状态变化的规范。规范设计使得所有获取/释放操作都被统一处理，客户端只需在访问锁不变式时判断是否持有锁。

Result: 成功为递归互斥锁开发了分离逻辑规范，这些规范能够处理同一线程多次获取锁的情况，并保持了与普通互斥锁规范类似的简洁性和实用性。

Conclusion: 递归互斥锁可以在分离逻辑中得到与普通互斥锁类似的优雅规范，支持同一线程多次获取的特性，为面向对象语言中的并发程序验证提供了理论基础。

Abstract: Mutexes (i.e., locks) are well understood in separation logic, and can be specified in terms of either protecting an invariant or atomically changing the state of the lock. In this abstract, we develop the same styles of specifications for \emph{recursive} mutexes, a common variant of mutexes in object-oriented languages such as C++ and Java. A recursive mutex can be acquired any number of times by the same thread, and our specifications treat all acquires/releases uniformly, with clients only needing to determine whether they hold the mutex when accessing the lock invariant.

</details>


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [2] [SpecIBT: Formally Verified Protection Against Speculative Control-Flow Hijacking](https://arxiv.org/abs/2601.22978)
*Jonathan Baumann,Yonghyun Kim,Yan Farba,Catalin Hritcu,Julay Leatherman-Brooks*

Main category: cs.CR

TL;DR: SpecIBT是一个针对Spectre BTB、RSB和PHT攻击的正式验证防御方案，结合了CET风格的硬件辅助控制流完整性和编译器插入的推测加载硬化技术。


<details>
  <summary>Details</summary>
Motivation: Spectre攻击利用现代处理器的推测执行漏洞，通过侧信道泄露敏感信息。现有防御方案要么性能开销大，要么安全保证不足，特别是对于不遵循密码学常数时间编程规范的程序。

Method: 基于CET风格保护下可以精确检测间接调用BTB误推测的新观察，结合硬件辅助控制流完整性和编译器插入的推测加载硬化。在Rocq中形式化SpecIBT转换，并提供机器检查证明。

Result: 实现了相对安全性：任何经过转换的程序在推测执行下泄露的信息不会超过源程序在无推测执行下的泄露。这一强安全保证适用于任意程序，包括不遵循密码学常数时间编程规范的程序。

Conclusion: SpecIBT提供了一个正式验证的防御方案，能够有效对抗Spectre BTB、RSB和PHT攻击，具有广泛适用性和强安全保证。

Abstract: This paper introduces SpecIBT, a formally verified defense against Spectre BTB, RSB, and PHT that combines CET-style hardware-assisted control-flow integrity with compiler-inserted speculative load hardening (SLH). SpecIBT is based on the novel observation that in the presence of CET-style protection, we can precisely detect BTB misspeculation for indirect calls and set the SLH misspeculation flag. We formalize SpecIBT as a transformation in Rocq and provide a machine-checked proof that it achieves relative security: any transformed program running with speculation leaks no more than what the source program leaks without speculation. This strong security guarantee applies to arbitrary programs, even those not following the cryptographic constant-time programming discipline.

</details>
