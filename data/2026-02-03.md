<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.SE](#cs.SE) [Total: 1]
- [cs.LG](#cs.LG) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Phoenix: A Modular and Versatile Framework for C/C++ Pointer Analysis](https://arxiv.org/abs/2602.01720)
*Peisen Yao,Zinan Gu,Qingkai Shi*

Main category: cs.PL

TL;DR: Phoenix是一个模块化的C/C++指针分析框架，统一了多种先进别名分析算法，提供单一稳定接口，解决了现有生态系统碎片化问题。


<details>
  <summary>Details</summary>
Motivation: 当前C/C++指针分析生态系统存在碎片化问题，不同分析工具接口不统一，难以比较、交换和组合，阻碍了指针分析技术的发展和应用。

Method: 采用模块化架构，将IR构建、约束生成、求解器后端和客户端查询清晰分离，支持多种状态最先进的别名分析算法，提供明确的精度-性能权衡。

Result: 在28个GNU coreutils程序上评估，Phoenix在流不敏感和上下文不敏感配置下获得最高2.88倍加速，在更精确的流敏感和上下文敏感配置下也保持竞争力（最高2.91倍），且无系统性运行时开销。

Conclusion: Phoenix成功解决了指针分析生态碎片化问题，已作为静态分析和模糊测试工具的分析基础，在工业工具链中发现了数百个新漏洞，报告了超过1000个bug，证明了其实际价值。

Abstract: We present Phoenix, a modular pointer analysis framework for C/C++ that unifies multiple state-of-the-art alias analysis algorithms behind a single, stable interface. Phoenix addresses the fragmentation of today's C/C++ pointer analysis ecosystem by cleanly separating IR construction, constraint generation, solver backends, and client-facing queries, making analyses easy to compare, swap, and compose while exposing explicit precision-performance trade-offs. We evaluate Phoenix against SVF under two representative configurations: a flow- and context-insensitive setting and a more precise flow- and context-sensitive setting, on 28 GNU coreutils programs. Phoenix delivers robust speedups in the baseline configuration (up to 2.88x) and remains competitive, and often faster, even in the stronger precision regime (up to 2.91x), without a systematic runtime penalty. In production, Phoenix serves as the analysis substrate for static analysis and fuzzing tools that have uncovered hundreds of new bugs and enabled deployments reporting more than 1000 bugs found in an industrial toolchain.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [2] [Towards Analyzing N-language Polyglot Programs](https://arxiv.org/abs/2602.00303)
*Jyoti Prakash,Abhishek Tiwari,Mikkel Baun Kjærgaard*

Main category: cs.SE

TL;DR: 该论文探讨了三种或更多语言的多语言编程系统的静态分析挑战，提出了解决这些问题的概念路线图。


<details>
  <summary>Details</summary>
Motivation: 随着GraalVM等多语言运行时的流行，开发者在系统中集成多种编程语言变得越来越普遍。然而，当前研究主要关注两种语言的分析，忽略了使用三种或更多语言的系统日益增长的复杂性。

Method: 论文识别了分析三语言多语言系统的基本挑战，并提出了一个概念路线图，旨在推进静态分析技术以解决这些问题。

Result: 提出了针对三语言多语言通信系统的分析挑战框架，并规划了未来研究方向。

Conclusion: 论文旨在激发讨论并启发新的研究方向，朝着为下一代多语言系统构建可扩展、语言无关的分析框架发展。

Abstract: Polyglot programming is gaining popularity as developers integrate multiple programming languages to harness their individual strengths. With the recent popularity of platforms like GraalVM and other multi-language runtimes, creating and managing these systems has become much more feasible. However, current research on analyzing multilingual programs mainly focuses on two languages, leaving out the increasing complexity of systems that use three or more. For example, modern web systems often link JavaScript, WebAssembly, and Rust within the same execution chain. This paper envisions the landscape of software systems with three-language polyglot communication. We identify fundamental challenges in analyzing them and propose a conceptual roadmap to advance static analysis techniques to address them. Our vision aims to stimulate discussion and inspire new research directions toward scalable, language-agnostic analysis frameworks for next-generation polyglot systems.

</details>


<div id='cs.LG'></div>

# cs.LG [[Back]](#toc)

### [3] [ECCO: Evidence-Driven Causal Reasoning for Compiler Optimization](https://arxiv.org/abs/2602.00087)
*Haolin Pan,Lianghong Huang,Jinyuan Dong,Mingjie Xing,Yanjun Wu*

Main category: cs.LG

TL;DR: ECCO框架结合可解释推理与组合搜索，通过构建思维链数据集让LLM学习优化决策的因果逻辑，然后让LLM作为策略师指导遗传算法，在编译器自动调优中显著超越传统方法


<details>
  <summary>Details</summary>
Motivation: 编译器自动调优面临传统黑盒搜索方法缺乏语义指导与LLM方法存在表面模式匹配和因果不透明的问题，需要一种能结合可解释推理与组合搜索的方法

Method: 1) 提出逆向工程方法构建思维链数据集，将静态代码特征映射到可验证的性能证据；2) 设计协作推理机制，让LLM作为策略师定义优化意图，动态指导遗传算法的变异操作

Result: 在7个数据集上的实验结果表明，ECCO显著优于LLVM opt -O3基线，平均减少24.44%的周期数

Conclusion: ECCO成功桥接了可解释推理与组合搜索，让LLM学习优化决策的因果逻辑而非简单模仿序列，在编译器自动调优中取得了显著性能提升

Abstract: Compiler auto-tuning faces a dichotomy between traditional black-box search methods, which lack semantic guidance, and recent Large Language Model (LLM) approaches, which often suffer from superficial pattern matching and causal opacity. In this paper, we introduce ECCO, a framework that bridges interpretable reasoning with combinatorial search. We first propose a reverse engineering methodology to construct a Chain-of-Thought dataset, explicitly mapping static code features to verifiable performance evidence. This enables the model to learn the causal logic governing optimization decisions rather than merely imitating sequences. Leveraging this interpretable prior, we design a collaborative inference mechanism where the LLM functions as a strategist, defining optimization intents that dynamically guide the mutation operations of a genetic algorithm. Experimental results on seven datasets demonstrate that ECCO significantly outperforms the LLVM opt -O3 baseline, achieving an average 24.44% reduction in cycles.

</details>
