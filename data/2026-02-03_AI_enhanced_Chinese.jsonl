{"id": "2602.01720", "pdf": "https://arxiv.org/pdf/2602.01720", "abs": "https://arxiv.org/abs/2602.01720", "authors": ["Peisen Yao", "Zinan Gu", "Qingkai Shi"], "title": "Phoenix: A Modular and Versatile Framework for C/C++ Pointer Analysis", "categories": ["cs.PL"], "comment": null, "summary": "We present Phoenix, a modular pointer analysis framework for C/C++ that unifies multiple state-of-the-art alias analysis algorithms behind a single, stable interface. Phoenix addresses the fragmentation of today's C/C++ pointer analysis ecosystem by cleanly separating IR construction, constraint generation, solver backends, and client-facing queries, making analyses easy to compare, swap, and compose while exposing explicit precision-performance trade-offs. We evaluate Phoenix against SVF under two representative configurations: a flow- and context-insensitive setting and a more precise flow- and context-sensitive setting, on 28 GNU coreutils programs. Phoenix delivers robust speedups in the baseline configuration (up to 2.88x) and remains competitive, and often faster, even in the stronger precision regime (up to 2.91x), without a systematic runtime penalty. In production, Phoenix serves as the analysis substrate for static analysis and fuzzing tools that have uncovered hundreds of new bugs and enabled deployments reporting more than 1000 bugs found in an industrial toolchain.", "AI": {"tldr": "Phoenix\u662f\u4e00\u4e2a\u6a21\u5757\u5316\u7684C/C++\u6307\u9488\u5206\u6790\u6846\u67b6\uff0c\u7edf\u4e00\u4e86\u591a\u79cd\u5148\u8fdb\u522b\u540d\u5206\u6790\u7b97\u6cd5\uff0c\u63d0\u4f9b\u5355\u4e00\u7a33\u5b9a\u63a5\u53e3\uff0c\u89e3\u51b3\u4e86\u73b0\u6709\u751f\u6001\u7cfb\u7edf\u788e\u7247\u5316\u95ee\u9898\u3002", "motivation": "\u5f53\u524dC/C++\u6307\u9488\u5206\u6790\u751f\u6001\u7cfb\u7edf\u5b58\u5728\u788e\u7247\u5316\u95ee\u9898\uff0c\u4e0d\u540c\u5206\u6790\u5de5\u5177\u63a5\u53e3\u4e0d\u7edf\u4e00\uff0c\u96be\u4ee5\u6bd4\u8f83\u3001\u4ea4\u6362\u548c\u7ec4\u5408\uff0c\u963b\u788d\u4e86\u6307\u9488\u5206\u6790\u6280\u672f\u7684\u53d1\u5c55\u548c\u5e94\u7528\u3002", "method": "\u91c7\u7528\u6a21\u5757\u5316\u67b6\u6784\uff0c\u5c06IR\u6784\u5efa\u3001\u7ea6\u675f\u751f\u6210\u3001\u6c42\u89e3\u5668\u540e\u7aef\u548c\u5ba2\u6237\u7aef\u67e5\u8be2\u6e05\u6670\u5206\u79bb\uff0c\u652f\u6301\u591a\u79cd\u72b6\u6001\u6700\u5148\u8fdb\u7684\u522b\u540d\u5206\u6790\u7b97\u6cd5\uff0c\u63d0\u4f9b\u660e\u786e\u7684\u7cbe\u5ea6-\u6027\u80fd\u6743\u8861\u3002", "result": "\u572828\u4e2aGNU coreutils\u7a0b\u5e8f\u4e0a\u8bc4\u4f30\uff0cPhoenix\u5728\u6d41\u4e0d\u654f\u611f\u548c\u4e0a\u4e0b\u6587\u4e0d\u654f\u611f\u914d\u7f6e\u4e0b\u83b7\u5f97\u6700\u9ad82.88\u500d\u52a0\u901f\uff0c\u5728\u66f4\u7cbe\u786e\u7684\u6d41\u654f\u611f\u548c\u4e0a\u4e0b\u6587\u654f\u611f\u914d\u7f6e\u4e0b\u4e5f\u4fdd\u6301\u7ade\u4e89\u529b\uff08\u6700\u9ad82.91\u500d\uff09\uff0c\u4e14\u65e0\u7cfb\u7edf\u6027\u8fd0\u884c\u65f6\u5f00\u9500\u3002", "conclusion": "Phoenix\u6210\u529f\u89e3\u51b3\u4e86\u6307\u9488\u5206\u6790\u751f\u6001\u788e\u7247\u5316\u95ee\u9898\uff0c\u5df2\u4f5c\u4e3a\u9759\u6001\u5206\u6790\u548c\u6a21\u7cca\u6d4b\u8bd5\u5de5\u5177\u7684\u5206\u6790\u57fa\u7840\uff0c\u5728\u5de5\u4e1a\u5de5\u5177\u94fe\u4e2d\u53d1\u73b0\u4e86\u6570\u767e\u4e2a\u65b0\u6f0f\u6d1e\uff0c\u62a5\u544a\u4e86\u8d85\u8fc71000\u4e2abug\uff0c\u8bc1\u660e\u4e86\u5176\u5b9e\u9645\u4ef7\u503c\u3002"}}
{"id": "2602.00087", "pdf": "https://arxiv.org/pdf/2602.00087", "abs": "https://arxiv.org/abs/2602.00087", "authors": ["Haolin Pan", "Lianghong Huang", "Jinyuan Dong", "Mingjie Xing", "Yanjun Wu"], "title": "ECCO: Evidence-Driven Causal Reasoning for Compiler Optimization", "categories": ["cs.LG", "cs.AI", "cs.PF", "cs.PL"], "comment": null, "summary": "Compiler auto-tuning faces a dichotomy between traditional black-box search methods, which lack semantic guidance, and recent Large Language Model (LLM) approaches, which often suffer from superficial pattern matching and causal opacity. In this paper, we introduce ECCO, a framework that bridges interpretable reasoning with combinatorial search. We first propose a reverse engineering methodology to construct a Chain-of-Thought dataset, explicitly mapping static code features to verifiable performance evidence. This enables the model to learn the causal logic governing optimization decisions rather than merely imitating sequences. Leveraging this interpretable prior, we design a collaborative inference mechanism where the LLM functions as a strategist, defining optimization intents that dynamically guide the mutation operations of a genetic algorithm. Experimental results on seven datasets demonstrate that ECCO significantly outperforms the LLVM opt -O3 baseline, achieving an average 24.44% reduction in cycles.", "AI": {"tldr": "ECCO\u6846\u67b6\u7ed3\u5408\u53ef\u89e3\u91ca\u63a8\u7406\u4e0e\u7ec4\u5408\u641c\u7d22\uff0c\u901a\u8fc7\u6784\u5efa\u601d\u7ef4\u94fe\u6570\u636e\u96c6\u8ba9LLM\u5b66\u4e60\u4f18\u5316\u51b3\u7b56\u7684\u56e0\u679c\u903b\u8f91\uff0c\u7136\u540e\u8ba9LLM\u4f5c\u4e3a\u7b56\u7565\u5e08\u6307\u5bfc\u9057\u4f20\u7b97\u6cd5\uff0c\u5728\u7f16\u8bd1\u5668\u81ea\u52a8\u8c03\u4f18\u4e2d\u663e\u8457\u8d85\u8d8a\u4f20\u7edf\u65b9\u6cd5", "motivation": "\u7f16\u8bd1\u5668\u81ea\u52a8\u8c03\u4f18\u9762\u4e34\u4f20\u7edf\u9ed1\u76d2\u641c\u7d22\u65b9\u6cd5\u7f3a\u4e4f\u8bed\u4e49\u6307\u5bfc\u4e0eLLM\u65b9\u6cd5\u5b58\u5728\u8868\u9762\u6a21\u5f0f\u5339\u914d\u548c\u56e0\u679c\u4e0d\u900f\u660e\u7684\u95ee\u9898\uff0c\u9700\u8981\u4e00\u79cd\u80fd\u7ed3\u5408\u53ef\u89e3\u91ca\u63a8\u7406\u4e0e\u7ec4\u5408\u641c\u7d22\u7684\u65b9\u6cd5", "method": "1) \u63d0\u51fa\u9006\u5411\u5de5\u7a0b\u65b9\u6cd5\u6784\u5efa\u601d\u7ef4\u94fe\u6570\u636e\u96c6\uff0c\u5c06\u9759\u6001\u4ee3\u7801\u7279\u5f81\u6620\u5c04\u5230\u53ef\u9a8c\u8bc1\u7684\u6027\u80fd\u8bc1\u636e\uff1b2) \u8bbe\u8ba1\u534f\u4f5c\u63a8\u7406\u673a\u5236\uff0c\u8ba9LLM\u4f5c\u4e3a\u7b56\u7565\u5e08\u5b9a\u4e49\u4f18\u5316\u610f\u56fe\uff0c\u52a8\u6001\u6307\u5bfc\u9057\u4f20\u7b97\u6cd5\u7684\u53d8\u5f02\u64cd\u4f5c", "result": "\u57287\u4e2a\u6570\u636e\u96c6\u4e0a\u7684\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0cECCO\u663e\u8457\u4f18\u4e8eLLVM opt -O3\u57fa\u7ebf\uff0c\u5e73\u5747\u51cf\u5c1124.44%\u7684\u5468\u671f\u6570", "conclusion": "ECCO\u6210\u529f\u6865\u63a5\u4e86\u53ef\u89e3\u91ca\u63a8\u7406\u4e0e\u7ec4\u5408\u641c\u7d22\uff0c\u8ba9LLM\u5b66\u4e60\u4f18\u5316\u51b3\u7b56\u7684\u56e0\u679c\u903b\u8f91\u800c\u975e\u7b80\u5355\u6a21\u4eff\u5e8f\u5217\uff0c\u5728\u7f16\u8bd1\u5668\u81ea\u52a8\u8c03\u4f18\u4e2d\u53d6\u5f97\u4e86\u663e\u8457\u6027\u80fd\u63d0\u5347"}}
{"id": "2602.00303", "pdf": "https://arxiv.org/pdf/2602.00303", "abs": "https://arxiv.org/abs/2602.00303", "authors": ["Jyoti Prakash", "Abhishek Tiwari", "Mikkel Baun Kj\u00e6rgaard"], "title": "Towards Analyzing N-language Polyglot Programs", "categories": ["cs.SE", "cs.PL"], "comment": null, "summary": "Polyglot programming is gaining popularity as developers integrate multiple programming languages to harness their individual strengths. With the recent popularity of platforms like GraalVM and other multi-language runtimes, creating and managing these systems has become much more feasible. However, current research on analyzing multilingual programs mainly focuses on two languages, leaving out the increasing complexity of systems that use three or more. For example, modern web systems often link JavaScript, WebAssembly, and Rust within the same execution chain. This paper envisions the landscape of software systems with three-language polyglot communication. We identify fundamental challenges in analyzing them and propose a conceptual roadmap to advance static analysis techniques to address them. Our vision aims to stimulate discussion and inspire new research directions toward scalable, language-agnostic analysis frameworks for next-generation polyglot systems.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63a2\u8ba8\u4e86\u4e09\u79cd\u6216\u66f4\u591a\u8bed\u8a00\u7684\u591a\u8bed\u8a00\u7f16\u7a0b\u7cfb\u7edf\u7684\u9759\u6001\u5206\u6790\u6311\u6218\uff0c\u63d0\u51fa\u4e86\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u7684\u6982\u5ff5\u8def\u7ebf\u56fe\u3002", "motivation": "\u968f\u7740GraalVM\u7b49\u591a\u8bed\u8a00\u8fd0\u884c\u65f6\u7684\u6d41\u884c\uff0c\u5f00\u53d1\u8005\u5728\u7cfb\u7edf\u4e2d\u96c6\u6210\u591a\u79cd\u7f16\u7a0b\u8bed\u8a00\u53d8\u5f97\u8d8a\u6765\u8d8a\u666e\u904d\u3002\u7136\u800c\uff0c\u5f53\u524d\u7814\u7a76\u4e3b\u8981\u5173\u6ce8\u4e24\u79cd\u8bed\u8a00\u7684\u5206\u6790\uff0c\u5ffd\u7565\u4e86\u4f7f\u7528\u4e09\u79cd\u6216\u66f4\u591a\u8bed\u8a00\u7684\u7cfb\u7edf\u65e5\u76ca\u589e\u957f\u7684\u590d\u6742\u6027\u3002", "method": "\u8bba\u6587\u8bc6\u522b\u4e86\u5206\u6790\u4e09\u8bed\u8a00\u591a\u8bed\u8a00\u7cfb\u7edf\u7684\u57fa\u672c\u6311\u6218\uff0c\u5e76\u63d0\u51fa\u4e86\u4e00\u4e2a\u6982\u5ff5\u8def\u7ebf\u56fe\uff0c\u65e8\u5728\u63a8\u8fdb\u9759\u6001\u5206\u6790\u6280\u672f\u4ee5\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002", "result": "\u63d0\u51fa\u4e86\u9488\u5bf9\u4e09\u8bed\u8a00\u591a\u8bed\u8a00\u901a\u4fe1\u7cfb\u7edf\u7684\u5206\u6790\u6311\u6218\u6846\u67b6\uff0c\u5e76\u89c4\u5212\u4e86\u672a\u6765\u7814\u7a76\u65b9\u5411\u3002", "conclusion": "\u8bba\u6587\u65e8\u5728\u6fc0\u53d1\u8ba8\u8bba\u5e76\u542f\u53d1\u65b0\u7684\u7814\u7a76\u65b9\u5411\uff0c\u671d\u7740\u4e3a\u4e0b\u4e00\u4ee3\u591a\u8bed\u8a00\u7cfb\u7edf\u6784\u5efa\u53ef\u6269\u5c55\u3001\u8bed\u8a00\u65e0\u5173\u7684\u5206\u6790\u6846\u67b6\u53d1\u5c55\u3002"}}
