<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]
- [cs.CL](#cs.CL) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Layered Modal ML: Syntax and Full Abstraction](https://arxiv.org/abs/2602.03033)
*Haoxuan Yin,Andrzej S. Murawski,C. -H. Luke Ong*

Main category: cs.PL

TL;DR: LMML是第一个支持在强类型安全保证下存储和运行开放代码的元编程语言，并建立了首个命令式MetaML风格语言的完全抽象语义模型。


<details>
  <summary>Details</summary>
Motivation: 在支持高阶代码引用的元编程语言中，确保类型安全具有挑战性，因为自由变量可能逃逸其绑定器。同时，基于元编程的程序优化需要确保优化后的程序保持原始程序的意义，这需要程序等价性概念和推理技术。

Method: 提出Layered Modal ML (LMML)，使用上下文模态类型显式跟踪和推理代码中的自由变量。基于操作博弈语义的迹构建语义模型，捕获上下文等价性，并建立新的闭实例使用定理，同时考虑按值和按名的闭替换。

Result: LMML是第一个支持在强类型安全保证下存储和运行开放代码的元编程语言。建立了首个命令式MetaML风格语言的完全抽象结果，提供了捕获LMML上下文等价的语义模型。

Conclusion: 该工作通过上下文模态类型解决了元编程中的类型安全问题，并通过基于博弈语义的语义模型为程序等价性推理提供了理论基础，为元编程语言的可靠性和优化验证做出了重要贡献。

Abstract: MetaML-style metaprogramming languages allow programmers to construct, manipulate and run code. In the presence of higher-order references for code, ensuring type safety is challenging, as free variables can escape their binders. In this paper, we present Layered Modal ML (LMML), \textit{the first metaprogramming language that supports storing and running open code under a strong type safety guarantee}. The type system utilises contextual modal types to track and reason about free variables in code explicitly.
  A crucial concern in metaprogramming-based program optimisations is whether the optimised program preserves the meaning of the original program. Addressing this question requires a notion of program equivalence and techniques to reason about it. In this paper, we provide a semantic model that captures contextual equivalence for LMML, establishing \textit{the first full abstraction result for an imperative MetaML-style language}. Our model is based on traces derived via operational game semantics, where the meaning of a program is modelled by its possible interactions with the environment. We also establish a novel closed instances of use theorem that accounts for both call-by-value and call-by-name closing substitutions.

</details>


### [2] [From Separate Compilation to Sound Language Composition](https://arxiv.org/abs/2602.03777)
*Federico Bruzzone,Walter Cazzola,Luca Favalli*

Main category: cs.PL

TL;DR: 开发了nlgcheck工具，为Neverlang语言工作台提供静态分析，在保持分离编译的同时检测潜在运行时错误


<details>
  <summary>Details</summary>
Motivation: 语言工作台在解决语言扩展问题时常常放松分离编译约束，这影响了构件可重用性和依赖系统集成。现有方法（如Neverlang的动态映射）以灵活性为代价牺牲编译时正确性，可能导致运行时错误

Method: 提出nlgcheck工具，基于数据流分析为Neverlang语言工作台提供理论健全的静态分析，在编译时检测未定义属性访问等潜在运行时错误

Result: 通过基于Neverlang项目的变异测试实验评估表明，nlgcheck有效增强了鲁棒性，没有牺牲模块化或灵活性，性能水平不会阻碍日常开发采用

Conclusion: nlgcheck解决了语言扩展中分离编译的挑战，在保持模块化开发的同时提供强静态正确性保证，平衡了灵活性和安全性

Abstract: The development of programming languages involves complex theoretical and practical challenges, particularly when addressing modularity and reusability through language extensions. While language workbenches aim to enable modular development under the constraints of the language extension problem, one critical constraint -- separate compilation -- is often relaxed due to its complexity. However, this relaxation undermines artifact reusability and integration with common dependency systems. A key difficulty under separate compilation arises from managing attribute grammars, as extensions may introduce new attributes that invalidate previously generated abstract syntax tree structures. Existing approaches, such as the use of dynamic maps in the Neverlang workbench, favor flexibility at the cost of compile-time correctness, leading to potential runtime errors due to undefined attributes. This work addresses this issue by introducing nlgcheck, a theoretically sound static analysis tool based on data-flow analysis for the Neverlang language workbench. nlgcheck detects potential runtime errors -- such as undefined attribute accesses -- at compile time, preserving separate compilation while maintaining strong static correctness guarantees. Experimental evaluation using mutation testing on Neverlang-based projects demonstrates that nlgcheck effectively enhances robustness without sacrificing modularity or flexibility and with a level of performance that does not impede its adoption in daily development activities.

</details>


<div id='cs.CL'></div>

# cs.CL [[Back]](#toc)

### [3] [Efficient Algorithms for Partial Constraint Satisfaction Problems over Control-flow Graphs](https://arxiv.org/abs/2602.03588)
*Xuran Cai,Amir Goharshady*

Main category: cs.CL

TL;DR: 本文提出了一种针对程序控制流图（CFG）上部分约束满足问题（PCSP）的通用算法，利用SPL分解实现O(|G|·|D|^6)时间复杂度，统一了寄存器分配和LOSPRE等编译器优化任务。


<details>
  <summary>Details</summary>
Motivation: 许多经典编译器优化任务（如寄存器分配、LOSPRE、最优库选择指令放置）都可以建模为控制流图上的PCSP问题。控制流图具有稀疏性和可分解性，特别是结构化程序的SPL分解特性，为高效算法设计提供了机会。

Method: 基于Series-Parallel-Loop（SPL）分解技术，提出通用PCSP算法。算法利用控制流图的结构化特性，通过动态规划在分解后的图上求解，时间复杂度为O(|G|·|D|^6)，对于固定域D是线性时间。

Result: 算法在最优库选择任务上的实验结果显示，运行时间比现有最优方法快4倍。该算法统一了先前基于SPL的寄存器分配和LOSPRE方法，提供了更通用的解决方案。

Conclusion: SPL分解为控制流图上的PCSP问题提供了高效的通用算法框架，能够统一处理多种编译器优化问题，并在实际任务中显著提升性能。

Abstract: In this work, we focus on the Partial Constraint Satisfaction Problem (PCSP) over control-flow graphs (CFGs) of programs. PCSP serves as a generalization of the well-known Constraint Satisfaction Problem (CSP). In the CSP framework, we define a set of variables, a set of constraints, and a finite domain $D$ that encompasses all possible values for each variable. The objective is to assign a value to each variable in such a way that all constraints are satisfied. In the graph variant of CSP, an underlying graph is considered and we have one variable corresponding to each vertex of the graph and one or several constraints corresponding to each edge. In PCSPs, we allow for certain constraints to be violated at a specified cost, aiming to find a solution that minimizes the total cost. Numerous classical compiler optimization tasks can be framed as PCSPs over control-flow graphs. Examples include Register Allocation, Lifetime-optimal Speculative Partial Redundancy Elimination (LOSPRE), and Optimal Placement of Bank Selection Instructions. On the other hand, it is well-known that control-flow graphs of structured programs are sparse and decomposable in a variety of ways. In this work, we rely on the Series-Parallel-Loop (SPL) decompositions as introduced by~\cite{RegisterAllocation}. Our main contribution is a general algorithm for PCSPs over SPL graphs with a time complexity of \(O(|G| \cdot |D|^6)\), where \(|G|\) represents the size of the control-flow graph. Note that for any fixed domain $D,$ this yields a linear-time solution. Our algorithm can be seen as a generalization and unification of previous SPL-based approaches for register allocation and LOSPRE. In addition, we provide experimental results over another classical PCSP task, i.e. Optimal Bank Selection, achieving runtimes four times better than the previous state of the art.

</details>
