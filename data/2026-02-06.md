<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Doc2Spec: Synthesizing Formal Programming Specifications from Natural Language via Grammar Induction](https://arxiv.org/abs/2602.04892)
*Shihao Xia,Mengting He,Haomin Jia,Linhai Song*

Main category: cs.PL

TL;DR: Doc2Spec：一个多智能体框架，使用LLM从自然语言规则自动推导规范语法，然后基于该语法生成形式化规范，提高API实现和使用的合规性验证效率。


<details>
  <summary>Details</summary>
Motivation: 确保API实现和使用符合自然语言编程规则对软件正确性、安全性和可靠性至关重要。形式化验证能提供强保证但需要精确规范，而手动编写这些规范既困难又成本高昂。

Method: Doc2Spec采用多智能体框架，使用LLM从自然语言规则自动推导规范语法，然后基于推导出的语法生成形式化规范。该语法捕获关键领域知识，约束规范空间，并确保表示一致性。

Result: 在三种编程语言的七个基准测试中，Doc2Spec优于无语法推导的基线方法，并与使用手动构建语法的技术取得竞争性结果，证明了自动语法推导在形式化自然语言规则方面的有效性。

Conclusion: Doc2Spec通过自动推导规范语法，显著提高了形式化规范生成的可靠性和质量，为解决形式化验证中规范编写困难的问题提供了有效解决方案。

Abstract: Ensuring that API implementations and usage comply with natural language programming rules is critical for software correctness, security, and reliability. Formal verification can provide strong guarantees but requires precise specifications, which are difficult and costly to write manually. To address this challenge, we present Doc2Spec, a multi-agent framework that uses LLMs to automatically induce a specification grammar from natural-language rules and then generates formal specifications guided by the induced grammar. The grammar captures essential domain knowledge, constrains the specification space, and enforces consistent representations, thereby improving the reliability and quality of generated specifications. Evaluated on seven benchmarks across three programming languages, Doc2Spec outperforms a baseline without grammar induction and achieves competitive results against a technique with a manually crafted grammar, demonstrating the effectiveness of automated grammar induction for formalizing natural-language rules.

</details>


### [2] [Strong Normalisation for Asynchronous Effects](https://arxiv.org/abs/2602.05528)
*Danel Ahman,Ilja Sobolev*

Main category: cs.PL

TL;DR: 该论文研究了Ahman和Pretnar提出的异步效应演算的归一化性质，证明了在移除一般递归后该演算是强归一化的，并且其顺序片段在重新引入受控的中断驱动递归行为后仍保持强归一化。


<details>
  <summary>Details</summary>
Motivation: Ahman和Pretnar的异步效应演算为代数计算效应提供了异步处理能力，能够建模抢占式多线程、可取消远程函数调用等场景。然而，该演算的归一化性质尚未被研究，这对于理解其终止性和计算行为至关重要。

Method: 采用Lindley和Stark基于⊤⊤-提升的方法来证明强归一化性质。首先证明移除一般递归后的完整演算（包括顺序和并行部分）是强归一化的，然后证明顺序片段在重新引入受控的中断驱动递归后仍保持强归一化。所有证明都在Agda中形式化验证。

Result: 1. 移除一般递归后的异步效应演算是强归一化的；2. 顺序片段在重新引入受控的中断驱动递归行为后仍保持强归一化；3. 这些结果为异步效应演算的终止性提供了理论基础。

Conclusion: 该研究为异步效应演算建立了坚实的归一化理论基础，证明了在适当限制下该演算具有良好的终止性质，为异步效应编程语言的设计和实现提供了理论保证。所有结果都经过形式化验证，增强了可靠性。

Abstract: Asynchronous effects of Ahman and Pretnar complement the conventional synchronous treatment of algebraic computational effects with asynchrony based on decoupling the execution of algebraic operation calls into signalling that an operation's implementation needs to be executed, and into interrupting a running computation with the operation's result, to which the computation can react by installing matching interrupt handlers. Beyond providing asynchrony for algebraic effects, the resulting core calculus also naturally models examples such as pre-emptive multi-threading, (cancellable) remote function calls, multi-party applications, and even a parallel variant of runners of algebraic effects. In this paper, we study the normalisation properties of this calculus. We prove that if one removes general recursion from the original calculus, then the remaining calculus is strongly normalising, including both its sequential and parallel parts. However, this only guarantees termination for very simple asynchronous examples. To improve on this result, we also prove that the sequential fragment of the calculus remains strongly normalising when a controlled amount of interrupt-driven recursive behaviour is reintroduced. Our strong normalisation proofs are structured compositionally as a natural extension of Lindley and Stark's $\top\top$-lifting based approach for proving strong normalisation of effectful languages. All our results are also formalised in Agda.

</details>


### [3] [An Equational Axiomatization of Dynamic Threads via Algebraic Effects: Presheaves on Finite Relations, Labelled Posets, and Parameterized Algebraic Theories](https://arxiv.org/abs/2602.05850)
*Ohad Kammar,Jack Liell-Cock,Sam Lindley,Cristina Matache,Sam Staton*

Main category: cs.PL

TL;DR: 使用代数效应理论为动态线程提供完整的等式公理化，基于参数化代数理论，通过fork和wait原语构建并发程序，证明模型完备性和语法完备性


<details>
  <summary>Details</summary>
Motivation: 为动态线程提供完整的等式公理化，建立并发程序的代数理论基础，使语义分析能够专注于fork和wait的代数操作

Method: 基于参数化代数理论，构建包含fork和wait原语的代数理论，提供操作语义和指称语义，证明完备性

Result: 实现了对动态线程的完整等式公理化：模型完备性（闭表达式完全捕获标记偏序集的相等性）和语法完备性（开表达式在所有闭替换下相等时可证明相等）

Conclusion: 代数效应为并发程序提供了有效的理论基础，参数化代数理论能够简洁地处理名称和绑定，建立的语义是健全、充分且一阶完全抽象的

Abstract: We use the theory of algebraic effects to give a complete equational axiomatization for dynamic threads. Our method is based on parameterized algebraic theories, which give a concrete syntax for strong monads on functor categories, and are a convenient framework for names and binding. Our programs are built from the key primitives `fork' and `wait'. `Fork' creates a child thread and passes its name (thread ID) to the parent thread. `Wait' allows us to wait for given child threads to finish. We provide a parameterized algebraic theory built from fork and wait, together with basic atomic actions and laws such as associativity of `fork'. Our equational axiomatization is complete in two senses. First, for closed expressions, it completely captures equality of labelled posets (pomsets), an established model of concurrency: model complete. Second, any two open expressions are provably equal if they are equal under all closing substitutions: syntactically complete. The benefit of algebraic effects is that the semantic analysis can focus on the algebraic operations of fork and wait. We then extend the analysis to a simple concurrent programming language by giving operational and denotational semantics. The denotational semantics is built using the methods of parameterized algebraic theories and we show that it is sound, adequate, and fully abstract at first order for labelled-poset observations.

</details>
