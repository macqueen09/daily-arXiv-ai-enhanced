<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Doc2Spec: Synthesizing Formal Programming Specifications from Natural Language via Grammar Induction](https://arxiv.org/abs/2602.04892)
*Shihao Xia,Mengting He,Haomin Jia,Linhai Song*

Main category: cs.PL

TL;DR: Doc2Spec：一个多智能体框架，使用LLM从自然语言规则自动推导规范语法，然后生成形式化规范，在三个编程语言的七个基准测试中表现优异。


<details>
  <summary>Details</summary>
Motivation: 确保API实现和使用符合自然语言编程规则对软件正确性、安全性和可靠性至关重要。形式化验证能提供强保证但需要精确规范，而手动编写这些规范既困难又昂贵。

Method: 提出Doc2Spec多智能体框架，使用LLM从自然语言规则自动推导规范语法，然后在推导出的语法指导下生成形式化规范。该语法捕获关键领域知识，约束规范空间，并强制执行一致表示。

Result: 在三个编程语言的七个基准测试中，Doc2Spec优于没有语法推导的基线方法，并与使用手动构建语法的技术取得竞争性结果，证明了自动语法推导在形式化自然语言规则方面的有效性。

Conclusion: 自动语法推导是形式化自然语言规则的有效方法，Doc2Spec框架通过多智能体LLM方法实现了高质量的规范生成，减少了手动编写规范的成本和难度。

Abstract: Ensuring that API implementations and usage comply with natural language programming rules is critical for software correctness, security, and reliability. Formal verification can provide strong guarantees but requires precise specifications, which are difficult and costly to write manually. To address this challenge, we present Doc2Spec, a multi-agent framework that uses LLMs to automatically induce a specification grammar from natural-language rules and then generates formal specifications guided by the induced grammar. The grammar captures essential domain knowledge, constrains the specification space, and enforces consistent representations, thereby improving the reliability and quality of generated specifications. Evaluated on seven benchmarks across three programming languages, Doc2Spec outperforms a baseline without grammar induction and achieves competitive results against a technique with a manually crafted grammar, demonstrating the effectiveness of automated grammar induction for formalizing natural-language rules.

</details>


### [2] [Strong Normalisation for Asynchronous Effects](https://arxiv.org/abs/2602.05528)
*Danel Ahman,Ilja Sobolev*

Main category: cs.PL

TL;DR: 该论文研究了Ahman和Pretnar提出的异步效应演算的归一化性质，证明了在移除一般递归后该演算是强归一化的，并且其顺序片段在引入受控的中断驱动递归行为后仍保持强归一化。


<details>
  <summary>Details</summary>
Motivation: 异步效应演算为代数计算效应提供了异步处理能力，能够自然地建模抢占式多线程、可取消远程函数调用、多方应用等场景。然而，该演算的终止性性质尚未得到充分研究，需要建立其归一化理论以保证计算的可靠性。

Method: 采用Lindley和Stark的⊤⊤-提升方法的结构化组合扩展，首先证明移除一般递归后的完整演算（包括顺序和并行部分）是强归一化的。然后进一步证明在顺序片段中重新引入受控的中断驱动递归行为后，系统仍保持强归一化。所有证明都在Agda中进行了形式化验证。

Result: 1. 移除一般递归后的异步效应演算是强归一化的，包括其顺序和并行部分；2. 顺序片段在引入受控的中断驱动递归行为后仍保持强归一化；3. 所有结果都在Agda中得到了形式化验证。

Conclusion: 该研究为异步效应演算建立了坚实的归一化理论基础，证明了在适当限制递归形式的情况下，该演算能够保证计算的终止性。这为异步效应在实际编程语言中的应用提供了理论保证，同时扩展了⊤⊤-提升方法在异步效应领域的适用性。

Abstract: Asynchronous effects of Ahman and Pretnar complement the conventional synchronous treatment of algebraic computational effects with asynchrony based on decoupling the execution of algebraic operation calls into signalling that an operation's implementation needs to be executed, and into interrupting a running computation with the operation's result, to which the computation can react by installing matching interrupt handlers. Beyond providing asynchrony for algebraic effects, the resulting core calculus also naturally models examples such as pre-emptive multi-threading, (cancellable) remote function calls, multi-party applications, and even a parallel variant of runners of algebraic effects. In this paper, we study the normalisation properties of this calculus. We prove that if one removes general recursion from the original calculus, then the remaining calculus is strongly normalising, including both its sequential and parallel parts. However, this only guarantees termination for very simple asynchronous examples. To improve on this result, we also prove that the sequential fragment of the calculus remains strongly normalising when a controlled amount of interrupt-driven recursive behaviour is reintroduced. Our strong normalisation proofs are structured compositionally as a natural extension of Lindley and Stark's $\top\top$-lifting based approach for proving strong normalisation of effectful languages. All our results are also formalised in Agda.

</details>


### [3] [An Equational Axiomatization of Dynamic Threads via Algebraic Effects: Presheaves on Finite Relations, Labelled Posets, and Parameterized Algebraic Theories](https://arxiv.org/abs/2602.05850)
*Ohad Kammar,Jack Liell-Cock,Sam Lindley,Cristina Matache,Sam Staton*

Main category: cs.PL

TL;DR: 使用代数效应理论为动态线程提供完整的等式公理化，基于参数化代数理论，通过fork和wait原语建模并发，证明模型完备性和语法完备性，并扩展到简单并发语言的语义。


<details>
  <summary>Details</summary>
Motivation: 为动态线程提供完整的等式公理化，使用代数效应理论来形式化并发编程中的线程创建和等待操作，建立可靠的数学基础。

Method: 基于参数化代数理论，构建包含fork和wait原语的代数理论，提供基本原子操作和定律（如fork的结合律），证明模型完备性和语法完备性，并扩展到简单并发语言的运算和指称语义。

Result: 实现了两个完备性：1）对闭表达式，完全捕获标记偏序集（pomsets）的相等性（模型完备）；2）对开表达式，在所有闭化替换下相等的表达式都可证明相等（语法完备）。建立了并发语言的健全、充分和完全抽象的指称语义。

Conclusion: 代数效应理论为动态线程提供了有效的等式公理化框架，参数化代数理论是处理名称和绑定的便捷工具，建立的并发语义具有良好的数学性质，为并发编程的形式化验证提供了基础。

Abstract: We use the theory of algebraic effects to give a complete equational axiomatization for dynamic threads. Our method is based on parameterized algebraic theories, which give a concrete syntax for strong monads on functor categories, and are a convenient framework for names and binding. Our programs are built from the key primitives `fork' and `wait'. `Fork' creates a child thread and passes its name (thread ID) to the parent thread. `Wait' allows us to wait for given child threads to finish. We provide a parameterized algebraic theory built from fork and wait, together with basic atomic actions and laws such as associativity of `fork'. Our equational axiomatization is complete in two senses. First, for closed expressions, it completely captures equality of labelled posets (pomsets), an established model of concurrency: model complete. Second, any two open expressions are provably equal if they are equal under all closing substitutions: syntactically complete. The benefit of algebraic effects is that the semantic analysis can focus on the algebraic operations of fork and wait. We then extend the analysis to a simple concurrent programming language by giving operational and denotational semantics. The denotational semantics is built using the methods of parameterized algebraic theories and we show that it is sound, adequate, and fully abstract at first order for labelled-poset observations.

</details>
