<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.CR](#cs.CR) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Compiler-Guided Inference-Time Adaptation: Improving GPT-5 Programming Performance in Idris](https://arxiv.org/abs/2602.11481)
*Minda Li,Bhaskar Krishnamachari*

Main category: cs.PL

TL;DR: GPT-5在低资源函数式编程语言Idris中表现不佳，但通过基于编译器错误的迭代提示策略，性能大幅提升至接近完美


<details>
  <summary>Details</summary>
Motivation: 研究GPT-5在低资源或不常用编程语言（如Idris）中的能力，这些语言相对于Python、C++、Java等高资源语言研究不足

Method: 使用Exercism平台的Idris练习，评估多种精炼策略：基于平台反馈的迭代提示、添加文档和错误分类指南、使用本地编译错误和失败测试用例的迭代提示

Result: 零次提示仅解决22/56个问题，而使用本地编译错误的迭代提示策略将性能提升至54/56个问题，接近完美解决率

Conclusion: 虽然大语言模型在低资源环境中可能表现不佳，但结构化的编译器级反馈对于解锁其能力至关重要

Abstract: GPT-5, a state of the art large language model from OpenAI, demonstrates strong performance in widely used programming languages such as Python, C++, and Java; however, its ability to operate in low resource or less commonly used languages remains underexplored. This work investigates whether GPT-5 can effectively acquire proficiency in an unfamiliar functional programming language, Idris, through iterative, feedback driven prompting. We first establish a baseline showing that with zero shot prompting the model solves only 22 out of 56 Idris exercises using the platform Exercism, substantially underperforming relative to higher resource languages (45 out of 50 in Python and 35 out of 47 in Erlang). We then evaluate several refinement strategies, including iterative prompting based on platform feedback, augmenting prompts with documentation and error classification guides, and iterative prompting using local compilation errors and failed test cases. Among these approaches, incorporating local compilation errors yields the most substantial improvements. Using this structured, error guided refinement loop, GPT-5 performance increased to an impressive 54 solved problems out of 56. These results suggest that while large language models may initially struggle in low resource settings, structured compiler level feedback can play a critical role in unlocking their capabilities.

</details>


<div id='cs.CR'></div>

# cs.CR [[Back]](#toc)

### [2] [Yaksha-Prashna: Understanding eBPF Bytecode Network Function Behavior](https://arxiv.org/abs/2602.11232)
*Animesh Singh,K Shiv Kumar,S. VenkataKeerthy,Pragna Mamidipaka,R V B R N Aaseesh,Sayandeep Sen,Palanivel Kodeswaran,Theophilus A. Benson,Ramakrishna Upadrasta,Praveen Tammana*

Main category: cs.CR

TL;DR: Yaksha-Prashna 是一个系统，允许操作员/开发者验证和查询eBPF字节码是否符合其规范以及与其他字节码的依赖关系，通过领域特定模型实现可扩展的程序分析，在标准和非标准eBPF网络功能上表达24个属性，比现有技术快200-1000倍。


<details>
  <summary>Details</summary>
Motivation: 云基础设施组织越来越依赖第三方eBPF网络功能（如安全、可观测性、负载均衡），但第三方提供的字节码格式让云操作员难以理解其功能正确性和与其他网络功能的交互。同时，eBPF开发者希望在不公开源代码的情况下证明其网络功能的功能正确性。

Method: 设计Yaksha-Prashna系统，构建领域特定模型，采用可扩展的程序分析技术来提取和建模eBPF程序。使用Yaksha-Prashna语言表达属性，验证字节码是否符合规范及其依赖关系。

Result: 在标准和非标准eBPF网络功能上成功表达了24个属性，相比现有技术实现了200-1000倍的性能提升。

Conclusion: Yaksha-Prashna系统有效解决了第三方eBPF网络功能的功能正确性验证问题，既保护了开发者的源代码隐私，又为操作员提供了验证工具，显著提升了验证效率。

Abstract: Many cloud infrastructure organizations increasingly rely on third-party eBPF-based network functions for use cases like security, observability, and load balancing, so that not everyone requires a team of highly skilled eBPF experts. However, the network functions from third parties (e.g., F5, Palo Alto) are available in bytecode format to cloud operators, giving little or no understanding of their functional correctness and interaction with other network functions in a chain. Also, eBPF developers want to provide proof of functional correctness for their developed network functions without disclosing the source code to the operators. We design Yaksha-Prashna, a system that allows operators/developers to assert and query bytecode's conformance to its specification and dependencies on other bytecodes. Our work builds domain-specific models that enable us to employ scalable program analysis to extract and model eBPF programs. Using Yaksha-Prashna language, we express 24 properties on standard and non-standard eBPF-based network functions with 200-1000x speedup over the state-of-the-art work.

</details>
