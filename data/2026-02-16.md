<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Meta-Monomorphizing Specializations](https://arxiv.org/abs/2602.12973)
*Federico Bruzzone,Walter Cazzola*

Main category: cs.PL

TL;DR: 该论文提出了一种名为"元单态化特化"的新框架，通过编译时元编程重新利用单态化来实现零成本特化，解决了条件编译与静态分发交互时的类型系统一致性问题。


<details>
  <summary>Details</summary>
Motivation: 实现零成本特化是编程语言和编译器设计的基本挑战，通常需要在表达能力与类型系统健全性之间进行权衡。条件编译与静态分发的交互容易导致不可预见的一致性违规，并增加形式模型的复杂性。

Method: 提出元单态化特化框架，通过编译时元编程重新利用单态化过程。该方法不修改宿主编译器，而是生成编码特化约束到类型结构中的元单态化特质和实现，实现确定性、一致的分发而无需重叠实例。形式化了基于一阶、谓词和高阶多态特化的方法，包括生命周期参数。

Result: 基于Rust实现（仅使用现有宏设施）的评估表明，元单态化能够实现之前被编译器拒绝的表达性特化模式，同时保持与标准优化管道的完全兼容。对公共Rust代码库的全面研究验证了该方法，揭示了元单态化可以消除的众多变通方案，从而产生更惯用和高效的代码。

Conclusion: 特化可以作为一个有纪律的元编程层实现，为高性能抽象提供了一条实用、语言无关的路径。元单态化特化为零成本特化问题提供了一个新颖的解决方案，平衡了表达能力与类型系统健全性。

Abstract: Achieving zero-cost specialization remains a fundamental challenge in programming language and compiler design. It often necessitates trade-offs between expressive power and type system soundness, as the interaction between conditional compilation and static dispatch can easily lead to unforeseen coherence violations and increased complexity in the formal model. This paper introduces meta-monomorphizing specializations, a novel framework that achieves specialization by repurposing monomorphization through compile-time metaprogramming. Instead of modifying the host compiler, our approach generates meta-monomorphized traits and implementations that encode specialization constraints directly into the type structure, enabling deterministic, coherent dispatch without overlapping instances. We formalize this method for first-order, predicate-based, and higher-ranked polymorphic specialization, also in presence of lifetime parameters. Our evaluation, based on a Rust implementation using only existing macro facilities, demonstrates that meta-monomorphization enables expressive specialization patterns -- previously rejected by the compiler -- while maintaining full compatibility with standard optimization pipelines. We show that specialization can be realized as a disciplined metaprogramming layer, offering a practical, language-agnostic path to high-performance abstraction. A comprehensive study of public Rust codebases further validates our approach, revealing numerous workarounds that meta-monomorphization can eliminate, leading to more idiomatic and efficient code.

</details>
