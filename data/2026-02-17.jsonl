{"id": "2602.14573", "pdf": "https://arxiv.org/pdf/2602.14573", "abs": "https://arxiv.org/abs/2602.14573", "authors": ["Marcel Moosbrugger", "Julian Müllner", "Ezio Bartocci", "Laura Kovács"], "title": "Polar: An Algebraic Analyzer for (Probabilistic) Loops", "categories": ["cs.PL"], "comment": "Published in \"Principles of Verification: Cycling the Probabilistic Landscape\"", "summary": "We present the Polar framework for fully automating the analysis of classical and probabilistic loops using algebraic reasoning. The central theme in Polar comes with handling algebraic recurrences that precisely capture the loop semantics. To this end, our work implements a variety of techniques to compute exact closed-forms of recurrences over higher-order moments of variables, infer invariants, and derive loop sensitivities with respect to unknown parameters. Polar can analyze probabilistic loops containing if-statements, polynomial arithmetic, and common probability distributions. By translating loop analysis into linear recurrence solving, Polar uses the derived closed-forms of recurrences to compute the strongest polynomial invariant or to infer parameter sensitivity. Polar is both sound and complete within well-defined programming model restrictions. Lifting any of these restrictions results in significant hardness limits of computation. To overcome computational burdens for the sake of efficiency, Polar also provides incomplete but sound techniques to compute moments of combinations of variables."}
{"id": "2602.14717", "pdf": "https://arxiv.org/pdf/2602.14717", "abs": "https://arxiv.org/abs/2602.14717", "authors": ["Stephen Mell", "Steve Zdancewic", "Osbert Bastani"], "title": "Optimal Program Synthesis via Abstract Interpretation", "categories": ["cs.PL"], "comment": null, "summary": "We consider the problem of synthesizing programs with numerical constants that optimize a quantitative objective, such as accuracy, over a set of input-output examples. We propose a general framework for optimal synthesis of such programs in a given domain specific language (DSL), with provable optimality guarantees. Our framework enumerates programs in a general search graph, where nodes represent subsets of concrete programs. To improve scalability, it uses A* search in conjunction with a search heuristic based on abstract interpretation; intuitively, this heuristic establishes upper bounds on the value of subtrees in the search graph, enabling the synthesizer to identify and prune subtrees that are provably suboptimal. In addition, we propose a natural strategy for constructing abstract transformers for monotonic semantics, which is a common property for components in DSLs for data classification. Finally, we implement our approach in the context of two such existing DSLs, demonstrating that our algorithm is more scalable than existing optimal synthesizers."}
