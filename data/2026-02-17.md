<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Polar: An Algebraic Analyzer for (Probabilistic) Loops](https://arxiv.org/abs/2602.14573)
*Marcel Moosbrugger,Julian Müllner,Ezio Bartocci,Laura Kovács*

Main category: cs.PL

TL;DR: Polar框架通过代数推理自动化分析经典和概率循环，使用线性递推求解计算变量高阶矩的精确闭式、推断不变量和参数敏感性。


<details>
  <summary>Details</summary>
Motivation: 需要自动化分析包含条件语句、多项式运算和概率分布的复杂循环，传统方法难以处理概率循环的精确分析。

Method: 将循环分析转化为线性递推求解，计算变量高阶矩的精确闭式，基于闭式推导最强多项式不变量和参数敏感性。

Result: Polar能分析包含if语句、多项式运算和常见概率分布的循环，在限定编程模型内是完备且可靠的，超出限制时提供不完全但可靠的技术。

Conclusion: Polar框架通过代数推理实现了循环分析的自动化，在限定模型内具有完备性，并为复杂情况提供了实用的近似方法。

Abstract: We present the Polar framework for fully automating the analysis of classical and probabilistic loops using algebraic reasoning. The central theme in Polar comes with handling algebraic recurrences that precisely capture the loop semantics. To this end, our work implements a variety of techniques to compute exact closed-forms of recurrences over higher-order moments of variables, infer invariants, and derive loop sensitivities with respect to unknown parameters. Polar can analyze probabilistic loops containing if-statements, polynomial arithmetic, and common probability distributions. By translating loop analysis into linear recurrence solving, Polar uses the derived closed-forms of recurrences to compute the strongest polynomial invariant or to infer parameter sensitivity. Polar is both sound and complete within well-defined programming model restrictions. Lifting any of these restrictions results in significant hardness limits of computation. To overcome computational burdens for the sake of efficiency, Polar also provides incomplete but sound techniques to compute moments of combinations of variables.

</details>


### [2] [Optimal Program Synthesis via Abstract Interpretation](https://arxiv.org/abs/2602.14717)
*Stephen Mell,Steve Zdancewic,Osbert Bastani*

Main category: cs.PL

TL;DR: 提出一个基于A*搜索和抽象解释的程序合成框架，用于在给定DSL中合成包含数值常数的最优程序，具有可证明的最优性保证。


<details>
  <summary>Details</summary>
Motivation: 解决在给定输入输出示例上合成包含数值常数的最优程序（如最大化准确率）的问题，现有最优合成器在可扩展性方面存在不足。

Method: 提出通用框架：1) 在搜索图中枚举程序，节点表示具体程序的子集；2) 结合A*搜索和基于抽象解释的启发式函数；3) 为单调语义构造抽象转换器的策略；4) 在现有DSL中实现验证。

Result: 该方法比现有最优合成器更具可扩展性，在两个现有DSL中验证了有效性。

Conclusion: 提出的框架能够高效合成包含数值常数的最优程序，通过抽象解释的启发式剪枝和单调语义的抽象转换器，实现了可证明的最优性和更好的可扩展性。

Abstract: We consider the problem of synthesizing programs with numerical constants that optimize a quantitative objective, such as accuracy, over a set of input-output examples. We propose a general framework for optimal synthesis of such programs in a given domain specific language (DSL), with provable optimality guarantees. Our framework enumerates programs in a general search graph, where nodes represent subsets of concrete programs. To improve scalability, it uses A* search in conjunction with a search heuristic based on abstract interpretation; intuitively, this heuristic establishes upper bounds on the value of subtrees in the search graph, enabling the synthesizer to identify and prune subtrees that are provably suboptimal. In addition, we propose a natural strategy for constructing abstract transformers for monotonic semantics, which is a common property for components in DSLs for data classification. Finally, we implement our approach in the context of two such existing DSLs, demonstrating that our algorithm is more scalable than existing optimal synthesizers.

</details>
