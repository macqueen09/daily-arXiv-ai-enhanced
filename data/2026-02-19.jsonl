{"id": "2602.16291", "pdf": "https://arxiv.org/pdf/2602.16291", "abs": "https://arxiv.org/abs/2602.16291", "authors": ["Bo Yang"], "title": "A Calculus of Overlays", "categories": ["cs.PL", "cs.SE"], "comment": null, "summary": "Just as the $λ$-calculus uses three primitives (abstraction, application, variable) as the foundation of functional programming, Overlay-Calculus uses three primitives (record, definition, inheritance) as the foundation of declarative programming. It trivially embeds the $λ$-calculus, although the entire semantics builds on only naive set theory; as a consequence, all constructs including inheritance are inherently commutative, idempotent, and associative; the linearization problem of multiple inheritance simply does not arise. This induces a fully abstract semantics of the lazy $λ$-calculus with respect to Böhm tree equivalence. Overlay-Calculus is distilled from the Overlay language, a practical implementation in which we observed further emergent phenomena: the Expression Problem dissolves, programs are CPS-agnostic, records natively encode random-access memory, and self-reference resolves to multiple targets. These properties suggest applications to configuration languages, dependency injection, object-oriented programming, composable effect systems, modular software architectures, file-system-as-compiler, general-purpose programming, and no-code development."}
{"id": "2602.16707", "pdf": "https://arxiv.org/pdf/2602.16707", "abs": "https://arxiv.org/abs/2602.16707", "authors": ["Jules Merckx", "Alexandre Lopoukhine", "Samuel Coward", "Jianyi Cheng", "Bjorn De Sutter", "Tobias Grosser"], "title": "E-Graphs as a Persistent Compiler Abstraction", "categories": ["cs.PL"], "comment": null, "summary": "Recent algorithmic advances have made equality saturation an appealing approach to program optimization because it avoids the phase-ordering problem. Existing work uses external equality saturation libraries, or custom implementations that are deeply tied to the specific application. However, these works only apply equality saturation at a single level of abstraction, or discard the discovered equalities when code is transformed by other compiler passes. We propose an alternative approach that represents an e-graph natively in the compiler's intermediate representation, facilitating the application of constructive compiler passes that maintain the e-graph state throughout the compilation flow. We build on a Python-based MLIR framework, xDSL, and introduce a new MLIR dialect, eqsat, that represents e-graphs in MLIR code. We show that this representation expands the scope of equality saturation in the compiler, allowing us to interleave pattern rewriting with other compiler transformations. The eqsat dialect provides a unified abstraction for compilers to utilize equality saturation across various levels of intermediate representations concurrently within the same MLIR flow."}
