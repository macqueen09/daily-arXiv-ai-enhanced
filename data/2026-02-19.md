<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [A Calculus of Overlays](https://arxiv.org/abs/2602.16291)
*Bo Yang*

Main category: cs.PL

TL;DR: Overlay-Calculus提出基于记录、定义、继承三个原语的声明式编程基础，继承λ演算但基于朴素集合论，解决了多重继承的线性化问题，并具有多种实用特性。


<details>
  <summary>Details</summary>
Motivation: 为声明式编程建立理论基础，解决传统编程语言中的多重继承线性化问题，提供更简洁、一致的语义模型。

Method: 基于朴素集合论，使用记录、定义、继承三个原语构建计算模型，从Overlay语言中提炼出Overlay-Calculus。

Result: 成功嵌入λ演算，继承操作具有交换性、幂等性和结合性，消除了多重继承的线性化问题，实现了惰性λ演算的完全抽象语义。

Conclusion: Overlay-Calculus为声明式编程提供了坚实的理论基础，具有广泛的应用前景，包括配置语言、依赖注入、面向对象编程、可组合效应系统等领域。

Abstract: Just as the $λ$-calculus uses three primitives (abstraction, application, variable) as the foundation of functional programming, Overlay-Calculus uses three primitives (record, definition, inheritance) as the foundation of declarative programming. It trivially embeds the $λ$-calculus, although the entire semantics builds on only naive set theory; as a consequence, all constructs including inheritance are inherently commutative, idempotent, and associative; the linearization problem of multiple inheritance simply does not arise. This induces a fully abstract semantics of the lazy $λ$-calculus with respect to Böhm tree equivalence. Overlay-Calculus is distilled from the Overlay language, a practical implementation in which we observed further emergent phenomena: the Expression Problem dissolves, programs are CPS-agnostic, records natively encode random-access memory, and self-reference resolves to multiple targets. These properties suggest applications to configuration languages, dependency injection, object-oriented programming, composable effect systems, modular software architectures, file-system-as-compiler, general-purpose programming, and no-code development.

</details>


### [2] [E-Graphs as a Persistent Compiler Abstraction](https://arxiv.org/abs/2602.16707)
*Jules Merckx,Alexandre Lopoukhine,Samuel Coward,Jianyi Cheng,Bjorn De Sutter,Tobias Grosser*

Main category: cs.PL

TL;DR: 提出在编译器IR中本地表示e-graph的方法，通过MLIR的eqsat方言实现跨抽象层次的等式饱和优化


<details>
  <summary>Details</summary>
Motivation: 现有等式饱和方法要么依赖外部库，要么与特定应用深度绑定，且只在单一抽象层次应用，或在其他编译器pass转换代码时丢弃已发现的等式

Method: 在xDSL（基于Python的MLIR框架）上构建eqsat方言，在编译器中间表示中本地表示e-graph，使构造性编译器pass能在整个编译流程中维护e-graph状态

Result: eqsat方言扩展了编译器中等式饱和的范围，允许将模式重写与其他编译器转换交错进行，为编译器提供了跨不同中间表示层次统一使用等式饱和的抽象

Conclusion: 在编译器IR中本地表示e-graph的方法能够促进等式饱和在编译器中更广泛的应用，实现跨抽象层次的优化

Abstract: Recent algorithmic advances have made equality saturation an appealing approach to program optimization because it avoids the phase-ordering problem. Existing work uses external equality saturation libraries, or custom implementations that are deeply tied to the specific application. However, these works only apply equality saturation at a single level of abstraction, or discard the discovered equalities when code is transformed by other compiler passes. We propose an alternative approach that represents an e-graph natively in the compiler's intermediate representation, facilitating the application of constructive compiler passes that maintain the e-graph state throughout the compilation flow. We build on a Python-based MLIR framework, xDSL, and introduce a new MLIR dialect, eqsat, that represents e-graphs in MLIR code. We show that this representation expands the scope of equality saturation in the compiler, allowing us to interleave pattern rewriting with other compiler transformations. The eqsat dialect provides a unified abstraction for compilers to utilize equality saturation across various levels of intermediate representations concurrently within the same MLIR flow.

</details>
