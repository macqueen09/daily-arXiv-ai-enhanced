<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Haskell meets Evariste](https://arxiv.org/abs/2602.16809)
*Paulo R. Pereira,Jose N. Oliveira*

Main category: cs.PL

TL;DR: 论文提出了一种名为"easy-hard-split"的形式化策略，用于改进函数式编程中软件库文档的质量，通过清晰的概念设计和文档组织提升代码可理解性和复用性。


<details>
  <summary>Details</summary>
Motivation: 编程已成为多学科基础技能，但编程困难、易出错，代码复用对生产力至关重要。然而软件库文档质量通常不高，需要改进文档的清晰度和概念设计。

Method: 以Hackage仓库中的Haskell函数为案例研究，与其他语言类似函数进行比较，展示如何通过"easy-hard-split"形式化策略实现清晰的概念设计和文档组织。该策略在函数式编程中易于使用，可应用于程序分析和综合。

Result: 通过案例研究展示了"easy-hard-split"策略能够有效提高文档清晰度和概念设计质量，该策略具有通用性和生产力，即使非正式使用也能产生良好效果。

Conclusion: "easy-hard-split"策略是一种通用且高效的方法，能够显著改善函数式编程中软件库文档的质量，促进代码理解和复用，适用于程序分析和综合任务。

Abstract: Since its birth as a new scientific body of knowledge in the late 1950s, computer programming has become a fundamental skill needed in many other disciplines. However, programming is not easy, it is prone to errors and code re-use is key for productivity. This calls for high-quality documentation in software libraries, which is quite often not the case. Taking a few Haskell functions available from the Hackage repository as case-studies, and comparing their descriptions with similar functions in other languages, this paper shows how clarity and good conceptual design can be achieved by following a so-called easy-hard-split formal strategy that is quite general and productive, even if used informally. This strategy is easy to use in functional programming and can be applied to both program analysis and synthesis.

</details>


### [2] [A Reversible Semantics for Janus](https://arxiv.org/abs/2602.16913)
*Ivan Lanese,Germán Vidal*

Main category: cs.PL

TL;DR: Janus语言的小步语义原本不可逆，本文提出了一种新的可逆小步语义，解决了程序计数器在高级语言中的定义挑战


<details>
  <summary>Details</summary>
Motivation: Janus作为可逆编程语言的典范，其程序可以正向和反向执行。然而，现有小步语义在正向计算时会丢失信息，导致不可逆，不满足可逆进程演算中的循环引理（Loop Lemma），这限制了其在调试和并发扩展中的应用。

Method: 提出了一种新颖的小步语义，基于"程序计数器"的概念，为高级编程语言设计可逆语义。该方法需要解决在高级语言中定义程序计数器的非平凡挑战，同时保持与原有语义的等价性。

Result: 成功定义了一个实际可逆的小步语义，满足循环引理（任何规约都有逆规约），同时与先前语义保持等价。解决了在高级语言中基于程序计数器定义语义的技术难题。

Conclusion: 本文为Janus语言提供了真正可逆的小步语义，填补了现有语义的不足，为调试、并发扩展等应用提供了更好的理论基础，同时解决了高级语言中程序计数器语义定义的技术挑战。

Abstract: Janus is a paradigmatic example of reversible programming language. Indeed, Janus programs can be executed backwards as well as forwards. However, its small-step semantics (useful, e.g., for debugging or as a basis for extensions with concurrency primitives) is not reversible, since it loses information while computing forwards. E.g., it does not satisfy the Loop Lemma, stating that any reduction has an inverse, a main property of reversibility in process calculi, where small-step semantics is commonly used. We present here a novel small-step semantics which is actually reversible, while remaining equivalent to the previous one. It involves the non-trivial challenge of defining a semantics based on a "program counter" for a high-level programming language.

</details>


### [3] [Mason: Type- and Name-Guided Program Synthesis](https://arxiv.org/abs/2602.16981)
*Jasper Geer,Fox Huston,Jeffrey S. Foster*

Main category: cs.PL

TL;DR: Mason是一个通过类型和名称引导的合成技术，自动将设计模式插入面向对象程序的工具，减少了实现设计模式所需的样板代码编写工作。


<details>
  <summary>Details</summary>
Motivation: 面向对象编程中实现设计模式通常需要编写大量重复的样板代码，这会分散程序员对核心逻辑的注意力，因此需要自动化工具来简化这一过程。

Method: Mason采用类型和名称引导的合成技术：枚举求解器遍历部分程序生成类型约束；通过受约束类型和成员名称引导的程序转换来解除约束；当约束被违反或候选程序未通过单元测试时进行回溯。还引入了两种扩展：使用执行跟踪的非本地回溯启发式方法，以及对缺失名称施加语法限制的模式语言。

Result: 评估显示，当满足类型约束的候选程序很少时，Mason表现良好；当不满足此条件时，其扩展能显著提升性能。Mason在合成使用设计模式的多类面向对象程序方面取得了重要进展。

Conclusion: Mason在通过设计模式合成多类面向对象程序方面迈出了重要一步，能够有效减少实现设计模式所需的样板代码编写工作。

Abstract: Object-oriented programs tend to be written using many common coding idioms, such as those captured by design patterns. While design patterns are useful, implementing them is often tedious and repetitive, requiring boilerplate code that distracts the programmer from more essential details. In this paper, we introduce Mason, a tool that synthesizes object-oriented programs from partial program pieces, and we apply it to automatically insert design patterns into programs. At the core of Mason is a novel technique we call type- and name-guided synthesis, in which an enumerative solver traverses a partial program to generate typing constraints; discharges constraints via program transformations guided by the names of constrained types and members; and backtracks when a constraint is violated or a candidate program fails unit tests. We also introduce two extensions to Mason: a non-local backtracking heuristic that uses execution traces, and a language of patterns that impose syntactic restrictions on missing names. We evaluate Mason on a suite of benchmarks to which Mason must add various well-known design patterns implemented as a library of program pieces. We find that Mason performs well when very few candidate programs satisfy its typing constraints and that our extensions can improve Mason's performance significantly when this is not the case. We believe that Mason takes an important step forward in synthesizing multi-class object-oriented programs using design patterns.

</details>
