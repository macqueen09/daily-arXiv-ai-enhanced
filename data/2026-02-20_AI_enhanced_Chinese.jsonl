{"id": "2602.16809", "pdf": "https://arxiv.org/pdf/2602.16809", "abs": "https://arxiv.org/abs/2602.16809", "authors": ["Paulo R. Pereira", "Jose N. Oliveira"], "title": "Haskell meets Evariste", "categories": ["cs.PL"], "comment": null, "summary": "Since its birth as a new scientific body of knowledge in the late 1950s, computer programming has become a fundamental skill needed in many other disciplines. However, programming is not easy, it is prone to errors and code re-use is key for productivity. This calls for high-quality documentation in software libraries, which is quite often not the case. Taking a few Haskell functions available from the Hackage repository as case-studies, and comparing their descriptions with similar functions in other languages, this paper shows how clarity and good conceptual design can be achieved by following a so-called easy-hard-split formal strategy that is quite general and productive, even if used informally. This strategy is easy to use in functional programming and can be applied to both program analysis and synthesis.", "AI": {"tldr": "\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u540d\u4e3a\"easy-hard-split\"\u7684\u5f62\u5f0f\u5316\u7b56\u7565\uff0c\u7528\u4e8e\u6539\u8fdb\u51fd\u6570\u5f0f\u7f16\u7a0b\u4e2d\u8f6f\u4ef6\u5e93\u6587\u6863\u7684\u8d28\u91cf\uff0c\u901a\u8fc7\u6e05\u6670\u7684\u6982\u5ff5\u8bbe\u8ba1\u548c\u6587\u6863\u7ec4\u7ec7\u63d0\u5347\u4ee3\u7801\u53ef\u7406\u89e3\u6027\u548c\u590d\u7528\u6027\u3002", "motivation": "\u7f16\u7a0b\u5df2\u6210\u4e3a\u591a\u5b66\u79d1\u57fa\u7840\u6280\u80fd\uff0c\u4f46\u7f16\u7a0b\u56f0\u96be\u3001\u6613\u51fa\u9519\uff0c\u4ee3\u7801\u590d\u7528\u5bf9\u751f\u4ea7\u529b\u81f3\u5173\u91cd\u8981\u3002\u7136\u800c\u8f6f\u4ef6\u5e93\u6587\u6863\u8d28\u91cf\u901a\u5e38\u4e0d\u9ad8\uff0c\u9700\u8981\u6539\u8fdb\u6587\u6863\u7684\u6e05\u6670\u5ea6\u548c\u6982\u5ff5\u8bbe\u8ba1\u3002", "method": "\u4ee5Hackage\u4ed3\u5e93\u4e2d\u7684Haskell\u51fd\u6570\u4e3a\u6848\u4f8b\u7814\u7a76\uff0c\u4e0e\u5176\u4ed6\u8bed\u8a00\u7c7b\u4f3c\u51fd\u6570\u8fdb\u884c\u6bd4\u8f83\uff0c\u5c55\u793a\u5982\u4f55\u901a\u8fc7\"easy-hard-split\"\u5f62\u5f0f\u5316\u7b56\u7565\u5b9e\u73b0\u6e05\u6670\u7684\u6982\u5ff5\u8bbe\u8ba1\u548c\u6587\u6863\u7ec4\u7ec7\u3002\u8be5\u7b56\u7565\u5728\u51fd\u6570\u5f0f\u7f16\u7a0b\u4e2d\u6613\u4e8e\u4f7f\u7528\uff0c\u53ef\u5e94\u7528\u4e8e\u7a0b\u5e8f\u5206\u6790\u548c\u7efc\u5408\u3002", "result": "\u901a\u8fc7\u6848\u4f8b\u7814\u7a76\u5c55\u793a\u4e86\"easy-hard-split\"\u7b56\u7565\u80fd\u591f\u6709\u6548\u63d0\u9ad8\u6587\u6863\u6e05\u6670\u5ea6\u548c\u6982\u5ff5\u8bbe\u8ba1\u8d28\u91cf\uff0c\u8be5\u7b56\u7565\u5177\u6709\u901a\u7528\u6027\u548c\u751f\u4ea7\u529b\uff0c\u5373\u4f7f\u975e\u6b63\u5f0f\u4f7f\u7528\u4e5f\u80fd\u4ea7\u751f\u826f\u597d\u6548\u679c\u3002", "conclusion": "\"easy-hard-split\"\u7b56\u7565\u662f\u4e00\u79cd\u901a\u7528\u4e14\u9ad8\u6548\u7684\u65b9\u6cd5\uff0c\u80fd\u591f\u663e\u8457\u6539\u5584\u51fd\u6570\u5f0f\u7f16\u7a0b\u4e2d\u8f6f\u4ef6\u5e93\u6587\u6863\u7684\u8d28\u91cf\uff0c\u4fc3\u8fdb\u4ee3\u7801\u7406\u89e3\u548c\u590d\u7528\uff0c\u9002\u7528\u4e8e\u7a0b\u5e8f\u5206\u6790\u548c\u7efc\u5408\u4efb\u52a1\u3002"}}
{"id": "2602.16913", "pdf": "https://arxiv.org/pdf/2602.16913", "abs": "https://arxiv.org/abs/2602.16913", "authors": ["Ivan Lanese", "Germ\u00e1n Vidal"], "title": "A Reversible Semantics for Janus", "categories": ["cs.PL", "cs.AI", "cs.LO"], "comment": "Submitted for publication", "summary": "Janus is a paradigmatic example of reversible programming language. Indeed, Janus programs can be executed backwards as well as forwards. However, its small-step semantics (useful, e.g., for debugging or as a basis for extensions with concurrency primitives) is not reversible, since it loses information while computing forwards. E.g., it does not satisfy the Loop Lemma, stating that any reduction has an inverse, a main property of reversibility in process calculi, where small-step semantics is commonly used. We present here a novel small-step semantics which is actually reversible, while remaining equivalent to the previous one. It involves the non-trivial challenge of defining a semantics based on a \"program counter\" for a high-level programming language.", "AI": {"tldr": "Janus\u8bed\u8a00\u7684\u5c0f\u6b65\u8bed\u4e49\u539f\u672c\u4e0d\u53ef\u9006\uff0c\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u53ef\u9006\u5c0f\u6b65\u8bed\u4e49\uff0c\u89e3\u51b3\u4e86\u7a0b\u5e8f\u8ba1\u6570\u5668\u5728\u9ad8\u7ea7\u8bed\u8a00\u4e2d\u7684\u5b9a\u4e49\u6311\u6218", "motivation": "Janus\u4f5c\u4e3a\u53ef\u9006\u7f16\u7a0b\u8bed\u8a00\u7684\u5178\u8303\uff0c\u5176\u7a0b\u5e8f\u53ef\u4ee5\u6b63\u5411\u548c\u53cd\u5411\u6267\u884c\u3002\u7136\u800c\uff0c\u73b0\u6709\u5c0f\u6b65\u8bed\u4e49\u5728\u6b63\u5411\u8ba1\u7b97\u65f6\u4f1a\u4e22\u5931\u4fe1\u606f\uff0c\u5bfc\u81f4\u4e0d\u53ef\u9006\uff0c\u4e0d\u6ee1\u8db3\u53ef\u9006\u8fdb\u7a0b\u6f14\u7b97\u4e2d\u7684\u5faa\u73af\u5f15\u7406\uff08Loop Lemma\uff09\uff0c\u8fd9\u9650\u5236\u4e86\u5176\u5728\u8c03\u8bd5\u548c\u5e76\u53d1\u6269\u5c55\u4e2d\u7684\u5e94\u7528\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u9896\u7684\u5c0f\u6b65\u8bed\u4e49\uff0c\u57fa\u4e8e\"\u7a0b\u5e8f\u8ba1\u6570\u5668\"\u7684\u6982\u5ff5\uff0c\u4e3a\u9ad8\u7ea7\u7f16\u7a0b\u8bed\u8a00\u8bbe\u8ba1\u53ef\u9006\u8bed\u4e49\u3002\u8be5\u65b9\u6cd5\u9700\u8981\u89e3\u51b3\u5728\u9ad8\u7ea7\u8bed\u8a00\u4e2d\u5b9a\u4e49\u7a0b\u5e8f\u8ba1\u6570\u5668\u7684\u975e\u5e73\u51e1\u6311\u6218\uff0c\u540c\u65f6\u4fdd\u6301\u4e0e\u539f\u6709\u8bed\u4e49\u7684\u7b49\u4ef7\u6027\u3002", "result": "\u6210\u529f\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5b9e\u9645\u53ef\u9006\u7684\u5c0f\u6b65\u8bed\u4e49\uff0c\u6ee1\u8db3\u5faa\u73af\u5f15\u7406\uff08\u4efb\u4f55\u89c4\u7ea6\u90fd\u6709\u9006\u89c4\u7ea6\uff09\uff0c\u540c\u65f6\u4e0e\u5148\u524d\u8bed\u4e49\u4fdd\u6301\u7b49\u4ef7\u3002\u89e3\u51b3\u4e86\u5728\u9ad8\u7ea7\u8bed\u8a00\u4e2d\u57fa\u4e8e\u7a0b\u5e8f\u8ba1\u6570\u5668\u5b9a\u4e49\u8bed\u4e49\u7684\u6280\u672f\u96be\u9898\u3002", "conclusion": "\u672c\u6587\u4e3aJanus\u8bed\u8a00\u63d0\u4f9b\u4e86\u771f\u6b63\u53ef\u9006\u7684\u5c0f\u6b65\u8bed\u4e49\uff0c\u586b\u8865\u4e86\u73b0\u6709\u8bed\u4e49\u7684\u4e0d\u8db3\uff0c\u4e3a\u8c03\u8bd5\u3001\u5e76\u53d1\u6269\u5c55\u7b49\u5e94\u7528\u63d0\u4f9b\u4e86\u66f4\u597d\u7684\u7406\u8bba\u57fa\u7840\uff0c\u540c\u65f6\u89e3\u51b3\u4e86\u9ad8\u7ea7\u8bed\u8a00\u4e2d\u7a0b\u5e8f\u8ba1\u6570\u5668\u8bed\u4e49\u5b9a\u4e49\u7684\u6280\u672f\u6311\u6218\u3002"}}
{"id": "2602.16981", "pdf": "https://arxiv.org/pdf/2602.16981", "abs": "https://arxiv.org/abs/2602.16981", "authors": ["Jasper Geer", "Fox Huston", "Jeffrey S. Foster"], "title": "Mason: Type- and Name-Guided Program Synthesis", "categories": ["cs.PL"], "comment": null, "summary": "Object-oriented programs tend to be written using many common coding idioms, such as those captured by design patterns. While design patterns are useful, implementing them is often tedious and repetitive, requiring boilerplate code that distracts the programmer from more essential details. In this paper, we introduce Mason, a tool that synthesizes object-oriented programs from partial program pieces, and we apply it to automatically insert design patterns into programs. At the core of Mason is a novel technique we call type- and name-guided synthesis, in which an enumerative solver traverses a partial program to generate typing constraints; discharges constraints via program transformations guided by the names of constrained types and members; and backtracks when a constraint is violated or a candidate program fails unit tests. We also introduce two extensions to Mason: a non-local backtracking heuristic that uses execution traces, and a language of patterns that impose syntactic restrictions on missing names. We evaluate Mason on a suite of benchmarks to which Mason must add various well-known design patterns implemented as a library of program pieces. We find that Mason performs well when very few candidate programs satisfy its typing constraints and that our extensions can improve Mason's performance significantly when this is not the case. We believe that Mason takes an important step forward in synthesizing multi-class object-oriented programs using design patterns.", "AI": {"tldr": "Mason\u662f\u4e00\u4e2a\u901a\u8fc7\u7c7b\u578b\u548c\u540d\u79f0\u5f15\u5bfc\u7684\u5408\u6210\u6280\u672f\uff0c\u81ea\u52a8\u5c06\u8bbe\u8ba1\u6a21\u5f0f\u63d2\u5165\u9762\u5411\u5bf9\u8c61\u7a0b\u5e8f\u7684\u5de5\u5177\uff0c\u51cf\u5c11\u4e86\u5b9e\u73b0\u8bbe\u8ba1\u6a21\u5f0f\u6240\u9700\u7684\u6837\u677f\u4ee3\u7801\u7f16\u5199\u5de5\u4f5c\u3002", "motivation": "\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u4e2d\u5b9e\u73b0\u8bbe\u8ba1\u6a21\u5f0f\u901a\u5e38\u9700\u8981\u7f16\u5199\u5927\u91cf\u91cd\u590d\u7684\u6837\u677f\u4ee3\u7801\uff0c\u8fd9\u4f1a\u5206\u6563\u7a0b\u5e8f\u5458\u5bf9\u6838\u5fc3\u903b\u8f91\u7684\u6ce8\u610f\u529b\uff0c\u56e0\u6b64\u9700\u8981\u81ea\u52a8\u5316\u5de5\u5177\u6765\u7b80\u5316\u8fd9\u4e00\u8fc7\u7a0b\u3002", "method": "Mason\u91c7\u7528\u7c7b\u578b\u548c\u540d\u79f0\u5f15\u5bfc\u7684\u5408\u6210\u6280\u672f\uff1a\u679a\u4e3e\u6c42\u89e3\u5668\u904d\u5386\u90e8\u5206\u7a0b\u5e8f\u751f\u6210\u7c7b\u578b\u7ea6\u675f\uff1b\u901a\u8fc7\u53d7\u7ea6\u675f\u7c7b\u578b\u548c\u6210\u5458\u540d\u79f0\u5f15\u5bfc\u7684\u7a0b\u5e8f\u8f6c\u6362\u6765\u89e3\u9664\u7ea6\u675f\uff1b\u5f53\u7ea6\u675f\u88ab\u8fdd\u53cd\u6216\u5019\u9009\u7a0b\u5e8f\u672a\u901a\u8fc7\u5355\u5143\u6d4b\u8bd5\u65f6\u8fdb\u884c\u56de\u6eaf\u3002\u8fd8\u5f15\u5165\u4e86\u4e24\u79cd\u6269\u5c55\uff1a\u4f7f\u7528\u6267\u884c\u8ddf\u8e2a\u7684\u975e\u672c\u5730\u56de\u6eaf\u542f\u53d1\u5f0f\u65b9\u6cd5\uff0c\u4ee5\u53ca\u5bf9\u7f3a\u5931\u540d\u79f0\u65bd\u52a0\u8bed\u6cd5\u9650\u5236\u7684\u6a21\u5f0f\u8bed\u8a00\u3002", "result": "\u8bc4\u4f30\u663e\u793a\uff0c\u5f53\u6ee1\u8db3\u7c7b\u578b\u7ea6\u675f\u7684\u5019\u9009\u7a0b\u5e8f\u5f88\u5c11\u65f6\uff0cMason\u8868\u73b0\u826f\u597d\uff1b\u5f53\u4e0d\u6ee1\u8db3\u6b64\u6761\u4ef6\u65f6\uff0c\u5176\u6269\u5c55\u80fd\u663e\u8457\u63d0\u5347\u6027\u80fd\u3002Mason\u5728\u5408\u6210\u4f7f\u7528\u8bbe\u8ba1\u6a21\u5f0f\u7684\u591a\u7c7b\u9762\u5411\u5bf9\u8c61\u7a0b\u5e8f\u65b9\u9762\u53d6\u5f97\u4e86\u91cd\u8981\u8fdb\u5c55\u3002", "conclusion": "Mason\u5728\u901a\u8fc7\u8bbe\u8ba1\u6a21\u5f0f\u5408\u6210\u591a\u7c7b\u9762\u5411\u5bf9\u8c61\u7a0b\u5e8f\u65b9\u9762\u8fc8\u51fa\u4e86\u91cd\u8981\u4e00\u6b65\uff0c\u80fd\u591f\u6709\u6548\u51cf\u5c11\u5b9e\u73b0\u8bbe\u8ba1\u6a21\u5f0f\u6240\u9700\u7684\u6837\u677f\u4ee3\u7801\u7f16\u5199\u5de5\u4f5c\u3002"}}
