<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Haskell meets Evariste](https://arxiv.org/abs/2602.16809)
*Paulo R. Pereira,Jose N. Oliveira*

Main category: cs.PL

TL;DR: 论文提出了一种easy-hard-split策略，通过改进Haskell函数文档的清晰度和概念设计，提升编程的可理解性和复用性。


<details>
  <summary>Details</summary>
Motivation: 编程已成为多学科基础技能，但编程困难、易出错且代码复用对生产力至关重要。软件库文档质量往往不高，需要改进文档的清晰度和概念设计。

Method: 以Hackage仓库中的Haskell函数为案例研究，与其他语言类似函数比较，采用easy-hard-split形式化策略来提升文档清晰度和概念设计。

Result: easy-hard-split策略能够显著提升函数文档的清晰度和概念设计质量，该策略通用且高效，即使在非正式使用中也能发挥作用。

Conclusion: easy-hard-split策略在函数式编程中易于使用，可应用于程序分析和综合，是提升软件库文档质量和编程效率的有效方法。

Abstract: Since its birth as a new scientific body of knowledge in the late 1950s, computer programming has become a fundamental skill needed in many other disciplines. However, programming is not easy, it is prone to errors and code re-use is key for productivity. This calls for high-quality documentation in software libraries, which is quite often not the case. Taking a few Haskell functions available from the Hackage repository as case-studies, and comparing their descriptions with similar functions in other languages, this paper shows how clarity and good conceptual design can be achieved by following a so-called easy-hard-split formal strategy that is quite general and productive, even if used informally. This strategy is easy to use in functional programming and can be applied to both program analysis and synthesis.

</details>


### [2] [A Reversible Semantics for Janus](https://arxiv.org/abs/2602.16913)
*Ivan Lanese,Germán Vidal*

Main category: cs.PL

TL;DR: 提出Janus可逆编程语言的新型小步语义，使其真正可逆并保持与原有语义等价


<details>
  <summary>Details</summary>
Motivation: Janus作为可逆编程语言的典范，其程序可以正向和反向执行。然而，现有的小步语义在正向计算时会丢失信息，导致不可逆，不满足可逆性的核心性质（如Loop Lemma），限制了其在调试和并发扩展中的应用。

Method: 设计了一种基于"程序计数器"的新型小步语义，通过精心设计语义规则来保持可逆性，同时确保与原有语义的等价性。

Result: 成功实现了真正可逆的小步语义，满足Loop Lemma等可逆性核心性质，同时保持了与原有Janus语义的等价性。

Conclusion: 为Janus可逆编程语言提供了真正可逆的小步语义，解决了原有语义不可逆的问题，为调试和并发扩展等应用提供了更好的基础。

Abstract: Janus is a paradigmatic example of reversible programming language. Indeed, Janus programs can be executed backwards as well as forwards. However, its small-step semantics (useful, e.g., for debugging or as a basis for extensions with concurrency primitives) is not reversible, since it loses information while computing forwards. E.g., it does not satisfy the Loop Lemma, stating that any reduction has an inverse, a main property of reversibility in process calculi, where small-step semantics is commonly used. We present here a novel small-step semantics which is actually reversible, while remaining equivalent to the previous one. It involves the non-trivial challenge of defining a semantics based on a "program counter" for a high-level programming language.

</details>


### [3] [Mason: Type- and Name-Guided Program Synthesis](https://arxiv.org/abs/2602.16981)
*Jasper Geer,Fox Huston,Jeffrey S. Foster*

Main category: cs.PL

TL;DR: Mason是一个通过类型和名称引导的合成技术，自动将设计模式插入面向对象程序的工具，减少了实现设计模式所需的样板代码。


<details>
  <summary>Details</summary>
Motivation: 面向对象程序中设计模式的实现通常需要大量重复的样板代码，这分散了程序员对核心逻辑的注意力。现有的设计模式实现过程繁琐且重复，需要一个自动化工具来简化这一过程。

Method: Mason采用类型和名称引导的合成技术：枚举求解器遍历部分程序生成类型约束；通过受约束类型和成员名称引导的程序转换来满足约束；当约束违反或候选程序未通过单元测试时进行回溯。还引入了两个扩展：使用执行跟踪的非局部回溯启发式方法，以及对缺失名称施加语法限制的模式语言。

Result: Mason在需要添加各种知名设计模式的基准测试套件上表现良好，特别是在满足其类型约束的候选程序很少的情况下效果显著。扩展功能在候选程序较多时能显著提升性能。

Conclusion: Mason在通过设计模式合成多类面向对象程序方面迈出了重要一步，能够有效减少实现设计模式所需的样板代码，提高开发效率。

Abstract: Object-oriented programs tend to be written using many common coding idioms, such as those captured by design patterns. While design patterns are useful, implementing them is often tedious and repetitive, requiring boilerplate code that distracts the programmer from more essential details. In this paper, we introduce Mason, a tool that synthesizes object-oriented programs from partial program pieces, and we apply it to automatically insert design patterns into programs. At the core of Mason is a novel technique we call type- and name-guided synthesis, in which an enumerative solver traverses a partial program to generate typing constraints; discharges constraints via program transformations guided by the names of constrained types and members; and backtracks when a constraint is violated or a candidate program fails unit tests. We also introduce two extensions to Mason: a non-local backtracking heuristic that uses execution traces, and a language of patterns that impose syntactic restrictions on missing names. We evaluate Mason on a suite of benchmarks to which Mason must add various well-known design patterns implemented as a library of program pieces. We find that Mason performs well when very few candidate programs satisfy its typing constraints and that our extensions can improve Mason's performance significantly when this is not the case. We believe that Mason takes an important step forward in synthesizing multi-class object-oriented programs using design patterns.

</details>
