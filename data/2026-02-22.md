<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Haskell meets Evariste](https://arxiv.org/abs/2602.16809)
*Paulo R. Pereira,Jose N. Oliveira*

Main category: cs.PL

TL;DR: 本文提出了一种"易难分离"的形式化策略，用于改进函数式编程中的文档质量和概念设计，通过Haskell函数案例研究展示了该策略的有效性。


<details>
  <summary>Details</summary>
Motivation: 编程已成为多学科的基础技能，但编程本身困难且易错，代码重用对生产力至关重要。然而软件库文档质量往往不高，需要改进文档清晰度和概念设计。

Method: 采用"易难分离"的形式化策略，以Hackage仓库中的Haskell函数为案例研究，并与其它语言中的类似函数进行比较分析。

Result: 研究表明，遵循易难分离策略可以显著提高文档清晰度和概念设计质量，该策略在函数式编程中易于使用，且适用于程序分析和综合。

Conclusion: 易难分离策略是一种通用且高效的方法，即使非正式使用也能显著改善编程文档和设计质量，特别适用于函数式编程环境。

Abstract: Since its birth as a new scientific body of knowledge in the late 1950s, computer programming has become a fundamental skill needed in many other disciplines. However, programming is not easy, it is prone to errors and code re-use is key for productivity. This calls for high-quality documentation in software libraries, which is quite often not the case. Taking a few Haskell functions available from the Hackage repository as case-studies, and comparing their descriptions with similar functions in other languages, this paper shows how clarity and good conceptual design can be achieved by following a so-called easy-hard-split formal strategy that is quite general and productive, even if used informally. This strategy is easy to use in functional programming and can be applied to both program analysis and synthesis.

</details>


### [2] [A Reversible Semantics for Janus](https://arxiv.org/abs/2602.16913)
*Ivan Lanese,Germán Vidal*

Main category: cs.PL

TL;DR: 提出Janus可逆编程语言的新颖小步语义，使其真正可逆并满足循环引理，解决了原有语义在向前计算时丢失信息的问题。


<details>
  <summary>Details</summary>
Motivation: Janus作为可逆编程语言的典型代表，其程序可以向前和向后执行。然而，现有小步语义在向前计算时会丢失信息，不满足可逆性（如循环引理），这限制了其在调试或并发扩展中的应用。

Method: 提出一种新颖的小步语义，基于"程序计数器"的概念，为高级编程语言定义可逆语义。新语义保持与原有语义的等价性，但真正实现了可逆性。

Result: 新语义实现了真正的可逆性，满足循环引理（任何规约都有逆操作），同时与原有语义保持等价。这解决了在高级语言中定义基于程序计数器的可逆语义的非平凡挑战。

Conclusion: 成功为Janus可逆编程语言设计了真正可逆的小步语义，填补了原有语义的缺陷，为调试和并发扩展提供了更好的基础，同时保持了语言的表达能力。

Abstract: Janus is a paradigmatic example of reversible programming language. Indeed, Janus programs can be executed backwards as well as forwards. However, its small-step semantics (useful, e.g., for debugging or as a basis for extensions with concurrency primitives) is not reversible, since it loses information while computing forwards. E.g., it does not satisfy the Loop Lemma, stating that any reduction has an inverse, a main property of reversibility in process calculi, where small-step semantics is commonly used. We present here a novel small-step semantics which is actually reversible, while remaining equivalent to the previous one. It involves the non-trivial challenge of defining a semantics based on a "program counter" for a high-level programming language.

</details>


### [3] [Mason: Type- and Name-Guided Program Synthesis](https://arxiv.org/abs/2602.16981)
*Jasper Geer,Fox Huston,Jeffrey S. Foster*

Main category: cs.PL

TL;DR: Mason是一个从部分程序片段合成面向对象程序的工具，专注于自动插入设计模式，通过类型和名称引导的合成技术解决实现设计模式时的重复样板代码问题。


<details>
  <summary>Details</summary>
Motivation: 面向对象编程中设计模式的实现通常需要大量重复的样板代码，这分散了程序员对核心逻辑的注意力。现有的设计模式实现过程繁琐且重复，需要工具来自动化这一过程。

Method: Mason采用类型和名称引导的合成技术：枚举求解器遍历部分程序生成类型约束；通过受约束类型和成员名称引导的程序转换来满足约束；当约束违反或候选程序未通过单元测试时进行回溯。还引入了两个扩展：使用执行跟踪的非局部回溯启发式方法，以及对缺失名称施加语法限制的模式语言。

Result: 在包含各种知名设计模式的基准测试套件上评估Mason，发现当满足类型约束的候选程序很少时，Mason表现良好；当不满足此条件时，其扩展功能能显著提升性能。

Conclusion: Mason在利用设计模式合成多类面向对象程序方面迈出了重要一步，为自动化设计模式实现提供了有效的工具支持。

Abstract: Object-oriented programs tend to be written using many common coding idioms, such as those captured by design patterns. While design patterns are useful, implementing them is often tedious and repetitive, requiring boilerplate code that distracts the programmer from more essential details. In this paper, we introduce Mason, a tool that synthesizes object-oriented programs from partial program pieces, and we apply it to automatically insert design patterns into programs. At the core of Mason is a novel technique we call type- and name-guided synthesis, in which an enumerative solver traverses a partial program to generate typing constraints; discharges constraints via program transformations guided by the names of constrained types and members; and backtracks when a constraint is violated or a candidate program fails unit tests. We also introduce two extensions to Mason: a non-local backtracking heuristic that uses execution traces, and a language of patterns that impose syntactic restrictions on missing names. We evaluate Mason on a suite of benchmarks to which Mason must add various well-known design patterns implemented as a library of program pieces. We find that Mason performs well when very few candidate programs satisfy its typing constraints and that our extensions can improve Mason's performance significantly when this is not the case. We believe that Mason takes an important step forward in synthesizing multi-class object-oriented programs using design patterns.

</details>
