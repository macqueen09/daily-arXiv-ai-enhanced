{"id": "2602.21630", "pdf": "https://arxiv.org/pdf/2602.21630", "abs": "https://arxiv.org/abs/2602.21630", "authors": ["Marco Bertoni", "Saverio Giallorenzo", "Marco Peressotti"], "title": "Type-Based Enforcement of Non-Interference for Choreographic Programming", "categories": ["cs.PL", "cs.CR", "cs.DC"], "comment": null, "summary": "Choreographies describe distributed protocols from a global viewpoint, enabling correct-by-construction synthesis of local behaviours. We develop a policy-parametric type system that prevents information leaks from high-security data to low-security observers, handling both explicit and implicit flows through a program-counter discipline. The system supports recursive procedures via a procedure context that we reconstruct through constraint generation. We prove termination-insensitive non-interference with respect to a standard small-step semantics.", "AI": {"tldr": "\u5f00\u53d1\u4e86\u4e00\u4e2a\u7b56\u7565\u53c2\u6570\u5316\u7684\u7c7b\u578b\u7cfb\u7edf\uff0c\u7528\u4e8e\u9632\u6b62\u9ad8\u5b89\u5168\u6570\u636e\u5411\u4f4e\u5b89\u5168\u89c2\u5bdf\u8005\u7684\u4fe1\u606f\u6cc4\u9732\uff0c\u652f\u6301\u9012\u5f52\u8fc7\u7a0b\u5e76\u901a\u8fc7\u7ea6\u675f\u751f\u6210\u91cd\u5efa\u8fc7\u7a0b\u4e0a\u4e0b\u6587\uff0c\u8bc1\u660e\u4e86\u7ec8\u6b62\u4e0d\u654f\u611f\u7684\u975e\u5e72\u6270\u6027\u3002", "motivation": "\u7f16\u6392\uff08choreographies\uff09\u4ece\u5168\u5c40\u89c6\u89d2\u63cf\u8ff0\u5206\u5e03\u5f0f\u534f\u8bae\uff0c\u652f\u6301\u6b63\u786e\u6027\u6784\u9020\u7684\u672c\u5730\u884c\u4e3a\u5408\u6210\u3002\u7136\u800c\uff0c\u9700\u8981\u9632\u6b62\u9ad8\u5b89\u5168\u6570\u636e\u5411\u4f4e\u5b89\u5168\u89c2\u5bdf\u8005\u7684\u4fe1\u606f\u6cc4\u9732\uff0c\u5305\u62ec\u663e\u5f0f\u548c\u9690\u5f0f\u6d41\uff0c\u540c\u65f6\u652f\u6301\u9012\u5f52\u8fc7\u7a0b\u3002", "method": "\u5f00\u53d1\u4e86\u4e00\u4e2a\u7b56\u7565\u53c2\u6570\u5316\u7684\u7c7b\u578b\u7cfb\u7edf\uff0c\u901a\u8fc7\u7a0b\u5e8f\u8ba1\u6570\u5668\u673a\u5236\u5904\u7406\u663e\u5f0f\u548c\u9690\u5f0f\u6d41\u3002\u7cfb\u7edf\u652f\u6301\u9012\u5f52\u8fc7\u7a0b\uff0c\u901a\u8fc7\u7ea6\u675f\u751f\u6210\u91cd\u5efa\u8fc7\u7a0b\u4e0a\u4e0b\u6587\u3002\u57fa\u4e8e\u6807\u51c6\u5c0f\u6b65\u8bed\u4e49\u8fdb\u884c\u5f62\u5f0f\u5316\u9a8c\u8bc1\u3002", "result": "\u8bc1\u660e\u4e86\u7ec8\u6b62\u4e0d\u654f\u611f\u7684\u975e\u5e72\u6270\u6027\uff08termination-insensitive non-interference\uff09\uff0c\u786e\u4fdd\u9ad8\u5b89\u5168\u6570\u636e\u4e0d\u4f1a\u901a\u8fc7\u4fe1\u606f\u6d41\u6cc4\u9732\u7ed9\u4f4e\u5b89\u5168\u89c2\u5bdf\u8005\u3002", "conclusion": "\u63d0\u51fa\u7684\u7b56\u7565\u53c2\u6570\u5316\u7c7b\u578b\u7cfb\u7edf\u80fd\u591f\u6709\u6548\u9632\u6b62\u7f16\u6392\u4e2d\u7684\u4fe1\u606f\u6cc4\u9732\uff0c\u652f\u6301\u9012\u5f52\u8fc7\u7a0b\u5e76\u901a\u8fc7\u5f62\u5f0f\u5316\u9a8c\u8bc1\u4fdd\u8bc1\u4e86\u5b89\u5168\u6027\u3002"}}
{"id": "2602.22075", "pdf": "https://arxiv.org/pdf/2602.22075", "abs": "https://arxiv.org/abs/2602.22075", "authors": ["Daniel Drodt", "Reiner H\u00e4hnle"], "title": "RustyDL: A Program Logic for Rust", "categories": ["cs.PL", "cs.LO"], "comment": "Long version of paper published at 27th International Symposium on Formal Methods (FM 2026)", "summary": "Rust is a modern programming language that guarantees memory safety and the absence of data races with a strong type system. We present RustyDL, a program logic for Rust, as a foundation for an auto-interactive, deductive verification tool for Rust. RustyDL reasons about Rust programs directly on the source code level, in contrast to other tools that are all based on translation to an intermediate language. A source-level program logic for Rust is crucial for a human-in-the-loop (HIL) style of verification that permits proving highly complex functional properties. We discuss specific Rust challenges in designing a program logic and calculus for HIL-style verification and propose a solution in each case. We provide a proof-of-concept of our ideas in the form of a prototype of a Rust instance of the deductive verification tool KeY.", "AI": {"tldr": "RustyDL\u662f\u4e00\u4e2a\u7528\u4e8eRust\u7a0b\u5e8f\u7684\u6e90\u7ea7\u7a0b\u5e8f\u903b\u8f91\uff0c\u652f\u6301\u4eba\u673a\u4ea4\u4e92\u5f0f\u9a8c\u8bc1\uff0c\u53ef\u76f4\u63a5\u5728\u6e90\u4ee3\u7801\u5c42\u9762\u8fdb\u884c\u63a8\u7406\uff0c\u65e0\u9700\u8f6c\u6362\u4e3a\u4e2d\u95f4\u8bed\u8a00\u3002", "motivation": "\u73b0\u6709Rust\u9a8c\u8bc1\u5de5\u5177\u90fd\u57fa\u4e8e\u8f6c\u6362\u4e3a\u4e2d\u95f4\u8bed\u8a00\uff0c\u7f3a\u4e4f\u76f4\u63a5\u5728\u6e90\u4ee3\u7801\u5c42\u9762\u8fdb\u884c\u63a8\u7406\u7684\u7a0b\u5e8f\u903b\u8f91\uff0c\u8fd9\u5bf9\u4e8e\u9700\u8981\u8bc1\u660e\u590d\u6742\u529f\u80fd\u5c5e\u6027\u7684\u4eba\u673a\u4ea4\u4e92\u5f0f\u9a8c\u8bc1\u81f3\u5173\u91cd\u8981\u3002", "method": "\u8bbe\u8ba1RustyDL\u7a0b\u5e8f\u903b\u8f91\u548c\u6f14\u7b97\uff0c\u89e3\u51b3Rust\u7279\u5b9a\u6311\u6218\uff0c\u5728KeY\u9a8c\u8bc1\u5de5\u5177\u4e2d\u5b9e\u73b0Rust\u5b9e\u4f8b\u539f\u578b\u3002", "result": "\u5f00\u53d1\u4e86RustyDL\u7a0b\u5e8f\u903b\u8f91\u539f\u578b\uff0c\u53ef\u76f4\u63a5\u5728Rust\u6e90\u4ee3\u7801\u5c42\u9762\u8fdb\u884c\u63a8\u7406\uff0c\u652f\u6301\u4eba\u673a\u4ea4\u4e92\u5f0f\u9a8c\u8bc1\u590d\u6742\u529f\u80fd\u5c5e\u6027\u3002", "conclusion": "RustyDL\u4e3aRust\u7a0b\u5e8f\u63d0\u4f9b\u4e86\u6e90\u7ea7\u7a0b\u5e8f\u903b\u8f91\u57fa\u7840\uff0c\u652f\u6301\u4eba\u673a\u4ea4\u4e92\u5f0f\u9a8c\u8bc1\uff0c\u662f\u9a8c\u8bc1\u590d\u6742Rust\u7a0b\u5e8f\u529f\u80fd\u5c5e\u6027\u7684\u91cd\u8981\u5de5\u5177\u3002"}}
{"id": "2602.21251", "pdf": "https://arxiv.org/pdf/2602.21251", "abs": "https://arxiv.org/abs/2602.21251", "authors": ["Clemens Pohle"], "title": "AgenticTyper: Automated Typing of Legacy Software Projects Using Agentic AI", "categories": ["cs.SE", "cs.AI", "cs.MA", "cs.PL"], "comment": "Accepted at ICSE 2026 Student Research Competition (SRC)", "summary": "Legacy JavaScript systems lack type safety, making maintenance risky. While TypeScript can help, manually adding types is expensive. Previous automated typing research focuses on type inference but rarely addresses type checking setup, definition generation, bug identification, or behavioral correctness at repository scale. We present AgenticTyper, a Large Language Model (LLM)-based agentic system that addresses these gaps through iterative error correction and behavior preservation via transpilation comparison. Evaluation on two proprietary repositories (81K LOC) shows that AgenticTyper resolves all 633 initial type errors in 20 minutes, reducing manual effort from one working day.", "AI": {"tldr": "AgenticTyper\u662f\u4e00\u4e2a\u57fa\u4e8eLLM\u7684\u4ee3\u7406\u7cfb\u7edf\uff0c\u901a\u8fc7\u8fed\u4ee3\u9519\u8bef\u7ea0\u6b63\u548c\u8f6c\u8bd1\u6bd4\u8f83\u6765\u4e3aJavaScript\u4ee3\u7801\u5e93\u81ea\u52a8\u6dfb\u52a0TypeScript\u7c7b\u578b\uff0c\u663e\u8457\u51cf\u5c11\u4eba\u5de5\u5de5\u4f5c\u91cf\u3002", "motivation": "\u4f20\u7edfJavaScript\u7cfb\u7edf\u7f3a\u4e4f\u7c7b\u578b\u5b89\u5168\u6027\uff0c\u7ef4\u62a4\u98ce\u9669\u9ad8\u3002\u867d\u7136TypeScript\u53ef\u4ee5\u63d0\u4f9b\u5e2e\u52a9\uff0c\u4f46\u624b\u52a8\u6dfb\u52a0\u7c7b\u578b\u6210\u672c\u9ad8\u6602\u3002\u73b0\u6709\u7684\u81ea\u52a8\u5316\u7c7b\u578b\u7814\u7a76\u4e3b\u8981\u5173\u6ce8\u7c7b\u578b\u63a8\u65ad\uff0c\u5f88\u5c11\u89e3\u51b3\u7c7b\u578b\u68c0\u67e5\u8bbe\u7f6e\u3001\u5b9a\u4e49\u751f\u6210\u3001\u9519\u8bef\u8bc6\u522b\u6216\u4ed3\u5e93\u7ea7\u522b\u7684\u884c\u4e3a\u6b63\u786e\u6027\u95ee\u9898\u3002", "method": "\u57fa\u4e8e\u5927\u578b\u8bed\u8a00\u6a21\u578b\u7684\u4ee3\u7406\u7cfb\u7edf\uff0c\u901a\u8fc7\u8fed\u4ee3\u9519\u8bef\u7ea0\u6b63\u548c\u8f6c\u8bd1\u6bd4\u8f83\u6765\u4fdd\u6301\u884c\u4e3a\u6b63\u786e\u6027\u3002\u7cfb\u7edf\u80fd\u591f\u5904\u7406\u7c7b\u578b\u68c0\u67e5\u8bbe\u7f6e\u3001\u5b9a\u4e49\u751f\u6210\u548c\u9519\u8bef\u8bc6\u522b\u3002", "result": "\u5728\u4e24\u4e2a\u4e13\u6709\u4ee3\u7801\u5e93\uff0881K\u884c\u4ee3\u7801\uff09\u4e0a\u8bc4\u4f30\uff0cAgenticTyper\u572820\u5206\u949f\u5185\u89e3\u51b3\u4e86\u6240\u6709633\u4e2a\u521d\u59cb\u7c7b\u578b\u9519\u8bef\uff0c\u5c06\u4eba\u5de5\u5de5\u4f5c\u91cf\u4ece\u4e00\u6574\u5929\u51cf\u5c11\u5230\u51e0\u4e4e\u4e3a\u96f6\u3002", "conclusion": "AgenticTyper\u6709\u6548\u5730\u89e3\u51b3\u4e86JavaScript\u4ee3\u7801\u5e93\u81ea\u52a8\u5316TypeScript\u7c7b\u578b\u6dfb\u52a0\u7684\u591a\u4e2a\u5173\u952e\u95ee\u9898\uff0c\u663e\u8457\u63d0\u9ad8\u4e86\u6548\u7387\u548c\u51c6\u786e\u6027\uff0c\u51cf\u5c11\u4e86\u7ef4\u62a4\u98ce\u9669\u3002"}}
{"id": "2602.21257", "pdf": "https://arxiv.org/pdf/2602.21257", "abs": "https://arxiv.org/abs/2602.21257", "authors": ["Wen G. Gong"], "title": "Structured Prompt Language: Declarative Context Management for LLMs", "categories": ["cs.CL", "cs.DB", "cs.PL"], "comment": "44 pages, 6 figures, 14 tables, 15 code-listings", "summary": "We present SPL (Structured Prompt Language), a declarative SQL-inspired language that treats large language models as generative knowledge bases and their context windows as constrained resources. SPL provides explicit WITH BUDGET/LIMIT token management, an automatic query optimizer, EXPLAIN transparency analogous to SQL's EXPLAIN ANALYZE, and native integration of retrieval-augmented generation (RAG) and persistent memory in a single declarative framework. SPL-flow extends SPL into resilient agentic pipelines with a three-tier provider fallback strategy (Ollama -> OpenRouter -> self-healing retry) fully transparent to the .spl script. Five extensions demonstrate the paradigm's breadth: (1) Text2SPL (multilingual NL->SPL translation); (2) Mixture-of-Models (MoM) routing that dispatches each PROMPT to a domain-specialist model at runtime; (3) Logical Chunking, an intelligent strategy for documents exceeding a single context window--expressed naturally through SPL's existing CTE syntax with no new constructs, decomposing a large query into a Map-Reduce pipeline that reduces attention cost from O(N^2) to O(N^2/k) and runs identically on cloud (parallel) or local hardware (sequential); (4) SPL-flow, a declarative agentic orchestration layer with resilient three-tier provider fallback; and (5) BENCHMARK for parallel multi-model comparison with automatic winner persistence. We provide a formal EBNF grammar, two pip-installable Python packages (spl-llm, spl-flow), and comparison against Prompty, DSPy, and LMQL. SPL reduces prompt boilerplate by 65% on average, surfaces a 68x cost spread across model tiers as a pre-execution signal, and runs the identical .spl script at $0.002 on OpenRouter or at zero marginal cost on a local Ollama instance--without modification.", "AI": {"tldr": "SPL\u662f\u4e00\u79cd\u58f0\u660e\u5f0fSQL\u98ce\u683c\u7684\u8bed\u8a00\uff0c\u5c06LLM\u89c6\u4e3a\u751f\u6210\u5f0f\u77e5\u8bc6\u5e93\uff0c\u63d0\u4f9b\u663e\u5f0ftoken\u9884\u7b97\u7ba1\u7406\u3001\u81ea\u52a8\u67e5\u8be2\u4f18\u5316\u3001RAG\u96c6\u6210\u548c\u5f39\u6027\u4ee3\u7406\u7ba1\u9053\uff0c\u663e\u8457\u51cf\u5c11\u63d0\u793a\u6a21\u677f\u4ee3\u7801\u5e76\u5b9e\u73b0\u8de8\u4e91/\u672c\u5730\u73af\u5883\u7684\u65e0\u7f1d\u8fd0\u884c\u3002", "motivation": "\u5f53\u524dLLM\u5e94\u7528\u5f00\u53d1\u9762\u4e34\u63d0\u793a\u5de5\u7a0b\u590d\u6742\u3001token\u7ba1\u7406\u56f0\u96be\u3001\u6210\u672c\u63a7\u5236\u4e0d\u900f\u660e\u3001\u4e91/\u672c\u5730\u73af\u5883\u5207\u6362\u4e0d\u4fbf\u7b49\u95ee\u9898\u3002\u9700\u8981\u4e00\u79cd\u58f0\u660e\u5f0f\u8bed\u8a00\u6765\u7b80\u5316LLM\u7f16\u7a0b\uff0c\u63d0\u4f9b\u7c7b\u4f3cSQL\u7684\u900f\u660e\u5ea6\u548c\u4f18\u5316\u80fd\u529b\u3002", "method": "\u8bbe\u8ba1\u4e86SPL\u58f0\u660e\u5f0f\u8bed\u8a00\uff0c\u5305\u542bWITH BUDGET/LIMIT token\u7ba1\u7406\u3001\u81ea\u52a8\u67e5\u8be2\u4f18\u5316\u5668\u3001EXPLAIN\u900f\u660e\u5ea6\u673a\u5236\u3002\u6269\u5c55\u4e86SPL-flow\u4ee3\u7406\u7ba1\u9053\uff0c\u91c7\u7528\u4e09\u5c42\u56de\u9000\u7b56\u7565\u3002\u5f00\u53d1\u4e86\u4e94\u4e2a\u6269\u5c55\uff1aText2SPL\u3001MoM\u8def\u7531\u3001Logical Chunking\u3001SPL-flow\u548cBENCHMARK\u3002", "result": "SPL\u5e73\u5747\u51cf\u5c1165%\u7684\u63d0\u793a\u6a21\u677f\u4ee3\u7801\uff0c\u5728\u9884\u6267\u884c\u9636\u6bb5\u63ed\u793a68\u500d\u7684\u6210\u672c\u5dee\u5f02\uff0c\u540c\u4e00.spl\u811a\u672c\u53ef\u5728OpenRouter\u4e0a\u4ee5$0.002\u8fd0\u884c\u6216\u5728\u672c\u5730Ollama\u5b9e\u4f8b\u4e0a\u96f6\u8fb9\u9645\u6210\u672c\u8fd0\u884c\u3002\u63d0\u4f9b\u4e86EBNF\u8bed\u6cd5\u548c\u4e24\u4e2aPython\u5305\u3002", "conclusion": "SPL\u4e3aLLM\u5e94\u7528\u5f00\u53d1\u63d0\u4f9b\u4e86\u58f0\u660e\u5f0f\u3001\u900f\u660e\u3001\u53ef\u4f18\u5316\u7684\u6846\u67b6\uff0c\u663e\u8457\u7b80\u5316\u4e86\u63d0\u793a\u5de5\u7a0b\uff0c\u5b9e\u73b0\u4e86\u6210\u672c\u900f\u660e\u548c\u8de8\u73af\u5883\u65e0\u7f1d\u90e8\u7f72\uff0c\u4ee3\u8868\u4e86LLM\u7f16\u7a0b\u8303\u5f0f\u7684\u91cd\u8981\u8fdb\u6b65\u3002"}}
