{"id": "2602.22240", "pdf": "https://arxiv.org/pdf/2602.22240", "abs": "https://arxiv.org/abs/2602.22240", "authors": ["Linus Bantel", "Moritz Strack", "Alexander Strack", "Dirk Pfl\u00fcger"], "title": "From Prompts to Performance: Evaluating LLMs for Task-based Parallel Code Generation", "categories": ["cs.PL", "cs.AI", "cs.DC"], "comment": "12 pages, 4 figures, 2 tables, Workshop on Asynchronous Many-Task Systems and Applications 2026", "summary": "Large Language Models (LLM) show strong abilities in code generation, but their skill in creating efficient parallel programs is less studied. This paper explores how LLMs generate task-based parallel code from three kinds of input prompts: natural language problem descriptions, sequential reference implementations, and parallel pseudo code. We focus on three programming frameworks: OpenMP Tasking, C++ standard parallelism, and the asynchronous many-task runtime HPX. Each framework offers different levels of abstraction and control for task execution. We evaluate LLM-generated solutions for correctness and scalability. Our results reveal both strengths and weaknesses of LLMs with regard to problem complexity and framework. Finally, we discuss what these findings mean for future LLM-assisted development in high-performance and scientific computing.", "AI": {"tldr": "LLM\u5728\u5e76\u884c\u4ee3\u7801\u751f\u6210\u80fd\u529b\u7814\u7a76\uff1a\u8bc4\u4f30\u4ece\u81ea\u7136\u8bed\u8a00\u3001\u987a\u5e8f\u4ee3\u7801\u548c\u5e76\u884c\u4f2a\u4ee3\u7801\u751f\u6210\u4efb\u52a1\u5e76\u884c\u7a0b\u5e8f\u7684\u6548\u679c\uff0c\u6d4b\u8bd5OpenMP\u3001C++\u5e76\u884c\u5e93\u548cHPX\u6846\u67b6\uff0c\u5206\u6790\u6b63\u786e\u6027\u548c\u53ef\u6269\u5c55\u6027\u3002", "motivation": "\u867d\u7136\u5927\u8bed\u8a00\u6a21\u578b\u5728\u4ee3\u7801\u751f\u6210\u65b9\u9762\u8868\u73b0\u51fa\u8272\uff0c\u4f46\u5176\u5728\u751f\u6210\u9ad8\u6548\u5e76\u884c\u7a0b\u5e8f\u65b9\u9762\u7684\u80fd\u529b\u5c1a\u672a\u5f97\u5230\u5145\u5206\u7814\u7a76\u3002\u672c\u6587\u65e8\u5728\u63a2\u7d22LLM\u5982\u4f55\u4ece\u4e0d\u540c\u8f93\u5165\u63d0\u793a\u751f\u6210\u4efb\u52a1\u5e76\u884c\u4ee3\u7801\uff0c\u8bc4\u4f30\u5176\u5728\u9ad8\u6027\u80fd\u548c\u79d1\u5b66\u8ba1\u7b97\u9886\u57df\u7684\u5b9e\u9645\u5e94\u7528\u6f5c\u529b\u3002", "method": "\u7814\u7a76\u4f7f\u7528\u4e09\u79cd\u8f93\u5165\u63d0\u793a\u7c7b\u578b\uff1a\u81ea\u7136\u8bed\u8a00\u95ee\u9898\u63cf\u8ff0\u3001\u987a\u5e8f\u53c2\u8003\u5b9e\u73b0\u548c\u5e76\u884c\u4f2a\u4ee3\u7801\u3002\u9488\u5bf9\u4e09\u4e2a\u7f16\u7a0b\u6846\u67b6\uff08OpenMP Tasking\u3001C++\u6807\u51c6\u5e76\u884c\u5e93\u548cHPX\u8fd0\u884c\u65f6\uff09\u8bc4\u4f30LLM\u751f\u6210\u7684\u89e3\u51b3\u65b9\u6848\u3002\u4e3b\u8981\u8bc4\u4f30\u6307\u6807\u5305\u62ec\u4ee3\u7801\u6b63\u786e\u6027\u548c\u53ef\u6269\u5c55\u6027\u3002", "result": "\u7ed3\u679c\u663e\u793aLLM\u5728\u5e76\u884c\u4ee3\u7801\u751f\u6210\u65b9\u9762\u65e2\u6709\u4f18\u52bf\u4e5f\u6709\u5c40\u9650\uff0c\u6027\u80fd\u8868\u73b0\u4e0e\u95ee\u9898\u590d\u6742\u5ea6\u548c\u6240\u9009\u6846\u67b6\u5bc6\u5207\u76f8\u5173\u3002\u4e0d\u540c\u8f93\u5165\u63d0\u793a\u7c7b\u578b\u548c\u5e76\u884c\u6846\u67b6\u5bf9\u751f\u6210\u7ed3\u679c\u7684\u8d28\u91cf\u6709\u663e\u8457\u5f71\u54cd\u3002", "conclusion": "\u7814\u7a76\u63ed\u793a\u4e86LLM\u5728\u5e76\u884c\u7f16\u7a0b\u65b9\u9762\u7684\u80fd\u529b\u8fb9\u754c\uff0c\u4e3a\u672a\u6765LLM\u8f85\u52a9\u7684\u9ad8\u6027\u80fd\u548c\u79d1\u5b66\u8ba1\u7b97\u5f00\u53d1\u63d0\u4f9b\u4e86\u91cd\u8981\u89c1\u89e3\uff0c\u6307\u51fa\u4e86\u9700\u8981\u6539\u8fdb\u7684\u65b9\u5411\u548c\u5e94\u7528\u6f5c\u529b\u3002"}}
{"id": "2602.23216", "pdf": "https://arxiv.org/pdf/2602.23216", "abs": "https://arxiv.org/abs/2602.23216", "authors": ["Weijie Lu", "Jingyu Ke", "Hongfei Fu", "Zhouyue Sun", "Yi Zhou", "Guoqiang Li", "Haokun Li"], "title": "Array-Carrying Symbolic Execution for Function Contract Generation", "categories": ["cs.PL", "cs.LO", "cs.SE"], "comment": "30 pages, 2 figures. To appear in the 27th International Symposium on Formal Methods (FM 2026)", "summary": "Function contract generation is a classical problem in program analysis that targets the automated analysis of functions in a program with multiple procedures. The problem is fundamental in inter-procedural analysis where properties of functions are first obtained via the generation of function contracts and then the generated contracts are used as building blocks to analyze the whole program. Typical objectives in function contract generation include pre-/post-conditions and assigns information (that specifies the modification information over program variables and memory segments during function execution). In programs with array manipulations, a crucial point in function contract generation is the treatment of array segments that imposes challenges in inferring invariants and assigns information over such segments. To address this challenge, we propose a novel symbolic execution framework that carries invariants and assigns information over contiguous segments of arrays. We implement our framework as a prototype within LLVM, and further integrate our prototype with the ACSL assertion format and the Frama-C software verification platform. Experimental evaluation over a variety of benchmarks from the literature and functions from realistic libraries shows that our framework is capable of handling array manipulating functions that indeed involve the carry of array information and are beyond existing approaches.", "AI": {"tldr": "\u63d0\u51fa\u57fa\u4e8e\u7b26\u53f7\u6267\u884c\u7684\u51fd\u6570\u5951\u7ea6\u751f\u6210\u6846\u67b6\uff0c\u4e13\u95e8\u5904\u7406\u6570\u7ec4\u64cd\u4f5c\u4e2d\u7684\u8fde\u7eed\u6570\u7ec4\u6bb5\uff0c\u89e3\u51b3\u73b0\u6709\u65b9\u6cd5\u96be\u4ee5\u5904\u7406\u6570\u7ec4\u4fe1\u606f\u4f20\u9012\u7684\u95ee\u9898\u3002", "motivation": "\u51fd\u6570\u5951\u7ea6\u751f\u6210\u662f\u7a0b\u5e8f\u5206\u6790\u4e2d\u7684\u7ecf\u5178\u95ee\u9898\uff0c\u5728\u591a\u8fc7\u7a0b\u7a0b\u5e8f\u5206\u6790\u4e2d\u81f3\u5173\u91cd\u8981\u3002\u5bf9\u4e8e\u6d89\u53ca\u6570\u7ec4\u64cd\u4f5c\u7684\u7a0b\u5e8f\uff0c\u5904\u7406\u6570\u7ec4\u6bb5\u5728\u63a8\u65ad\u4e0d\u53d8\u5f0f\u548c\u8d4b\u503c\u4fe1\u606f\u65b9\u9762\u5b58\u5728\u6311\u6218\uff0c\u73b0\u6709\u65b9\u6cd5\u96be\u4ee5\u5904\u7406\u6570\u7ec4\u4fe1\u606f\u7684\u4f20\u9012\u3002", "method": "\u63d0\u51fa\u65b0\u9896\u7684\u7b26\u53f7\u6267\u884c\u6846\u67b6\uff0c\u643a\u5e26\u6570\u7ec4\u8fde\u7eed\u6bb5\u7684\u4e0d\u53d8\u5f0f\u548c\u8d4b\u503c\u4fe1\u606f\u3002\u5728LLVM\u4e2d\u5b9e\u73b0\u539f\u578b\uff0c\u5e76\u4e0eACSL\u65ad\u8a00\u683c\u5f0f\u548cFrama-C\u8f6f\u4ef6\u9a8c\u8bc1\u5e73\u53f0\u96c6\u6210\u3002", "result": "\u5b9e\u9a8c\u8bc4\u4f30\u8868\u660e\uff0c\u8be5\u6846\u67b6\u80fd\u591f\u5904\u7406\u6d89\u53ca\u6570\u7ec4\u4fe1\u606f\u4f20\u9012\u7684\u6570\u7ec4\u64cd\u4f5c\u51fd\u6570\uff0c\u8fd9\u4e9b\u51fd\u6570\u8d85\u51fa\u4e86\u73b0\u6709\u65b9\u6cd5\u7684\u80fd\u529b\u8303\u56f4\u3002", "conclusion": "\u63d0\u51fa\u7684\u7b26\u53f7\u6267\u884c\u6846\u67b6\u6709\u6548\u89e3\u51b3\u4e86\u6570\u7ec4\u64cd\u4f5c\u51fd\u6570\u5951\u7ea6\u751f\u6210\u4e2d\u7684\u6570\u7ec4\u6bb5\u5904\u7406\u6311\u6218\uff0c\u80fd\u591f\u5904\u7406\u590d\u6742\u7684\u6570\u7ec4\u4fe1\u606f\u4f20\u9012\u573a\u666f\u3002"}}
{"id": "2602.22631", "pdf": "https://arxiv.org/pdf/2602.22631", "abs": "https://arxiv.org/abs/2602.22631", "authors": ["Robert Joseph George", "Jennifer Cruden", "Xiangru Zhong", "Huan Zhang", "Anima Anandkumar"], "title": "TorchLean: Formalizing Neural Networks in Lean", "categories": ["cs.MS", "cs.LG", "cs.LO", "cs.PL", "math.NA"], "comment": "35 pages, multiple figures and tables", "summary": "Neural networks are increasingly deployed in safety- and mission-critical pipelines, yet many verification and analysis results are produced outside the programming environment that defines and runs the model. This separation creates a semantic gap between the executed network and the analyzed artifact, so guarantees can hinge on implicit conventions such as operator semantics, tensor layouts, preprocessing, and floating-point corner cases. We introduce TorchLean, a framework in the Lean 4 theorem prover that treats learned models as first-class mathematical objects with a single, precise semantics shared by execution and verification. TorchLean unifies (1) a PyTorch-style verified API with eager and compiled modes that lower to a shared op-tagged SSA/DAG computation-graph IR, (2) explicit Float32 semantics via an executable IEEE-754 binary32 kernel and proof-relevant rounding models, and (3) verification via IBP and CROWN/LiRPA-style bound propagation with certificate checking. We validate TorchLean end-to-end on certified robustness, physics-informed residual bounds for PINNs, and Lyapunov-style neural controller verification, alongside mechanized theoretical results including a universal approximation theorem. These results demonstrate a semantics-first infrastructure for fully formal, end-to-end verification of learning-enabled systems.", "AI": {"tldr": "TorchLean\uff1a\u4e00\u4e2a\u5728Lean 4\u5b9a\u7406\u8bc1\u660e\u5668\u4e2d\u6784\u5efa\u7684\u6846\u67b6\uff0c\u5c06\u5b66\u4e60\u6a21\u578b\u4f5c\u4e3a\u4e00\u7b49\u6570\u5b66\u5bf9\u8c61\uff0c\u4e3a\u6267\u884c\u548c\u9a8c\u8bc1\u63d0\u4f9b\u7edf\u4e00\u7684\u7cbe\u786e\u8bed\u4e49\uff0c\u5b9e\u73b0\u7aef\u5230\u7aef\u7684\u5f62\u5f0f\u5316\u9a8c\u8bc1\u3002", "motivation": "\u795e\u7ecf\u7f51\u7edc\u5728\u5b89\u5168\u548c\u5173\u952e\u4efb\u52a1\u7cfb\u7edf\u4e2d\u90e8\u7f72\u589e\u591a\uff0c\u4f46\u73b0\u6709\u9a8c\u8bc1\u5de5\u5177\u4e0e\u7f16\u7a0b\u73af\u5883\u5206\u79bb\uff0c\u5bfc\u81f4\u8bed\u4e49\u9e3f\u6c9f\u3002\u9a8c\u8bc1\u7ed3\u679c\u53ef\u80fd\u4f9d\u8d56\u4e8e\u9690\u5f0f\u7ea6\u5b9a\uff08\u5982\u7b97\u5b50\u8bed\u4e49\u3001\u5f20\u91cf\u5e03\u5c40\u3001\u9884\u5904\u7406\u3001\u6d6e\u70b9\u7ec6\u8282\uff09\uff0c\u65e0\u6cd5\u4fdd\u8bc1\u771f\u6b63\u7684\u5b89\u5168\u6027\u3002", "method": "1. \u5728Lean 4\u4e2d\u6784\u5efaPyTorch\u98ce\u683c\u7684\u9a8c\u8bc1API\uff0c\u652f\u6301eager\u548ccompiled\u6a21\u5f0f\uff0c\u7edf\u4e00\u5230\u5171\u4eab\u7684op-tagged SSA/DAG\u8ba1\u7b97\u56feIR\uff1b2. \u901a\u8fc7\u53ef\u6267\u884c\u7684IEEE-754 binary32\u5185\u6838\u548c\u8bc1\u660e\u76f8\u5173\u7684\u820d\u5165\u6a21\u578b\u63d0\u4f9b\u660e\u786e\u7684Float32\u8bed\u4e49\uff1b3. \u901a\u8fc7IBP\u548cCROWN/LiRPA\u98ce\u683c\u7684\u8fb9\u754c\u4f20\u64ad\u4e0e\u8bc1\u4e66\u68c0\u67e5\u8fdb\u884c\u9a8c\u8bc1\u3002", "result": "\u5728\u8ba4\u8bc1\u9c81\u68d2\u6027\u3001PINNs\u7684\u7269\u7406\u4fe1\u606f\u6b8b\u5dee\u8fb9\u754c\u3001\u795e\u7ecf\u63a7\u5236\u5668\u7684Lyapunov\u98ce\u683c\u9a8c\u8bc1\u7b49\u4efb\u52a1\u4e0a\u8fdb\u884c\u4e86\u7aef\u5230\u7aef\u9a8c\u8bc1\uff0c\u5e76\u5b9e\u73b0\u4e86\u673a\u68b0\u5316\u7406\u8bba\u7ed3\u679c\uff08\u5305\u62ec\u901a\u7528\u903c\u8fd1\u5b9a\u7406\uff09\u3002", "conclusion": "TorchLean\u63d0\u4f9b\u4e86\u4e00\u4e2a\u8bed\u4e49\u4f18\u5148\u7684\u57fa\u7840\u8bbe\u65bd\uff0c\u5b9e\u73b0\u4e86\u5b66\u4e60\u4f7f\u80fd\u7cfb\u7edf\u7684\u5b8c\u5168\u5f62\u5f0f\u5316\u3001\u7aef\u5230\u7aef\u9a8c\u8bc1\uff0c\u5f25\u5408\u4e86\u6267\u884c\u548c\u9a8c\u8bc1\u4e4b\u95f4\u7684\u8bed\u4e49\u9e3f\u6c9f\u3002"}}
